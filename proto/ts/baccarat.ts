// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               unknown
// source: baccarat.proto

/* eslint-disable */
import * as _m0 from "protobufjs/minimal";
import { Card } from "./chinese_poker";
import { Error } from "./common";
import Long = require("long");

export const protobufPackage = "proto";

export enum BaccaratBetCell {
  BACCARAT_BET_CELL_BACCARAT_CELL_UNSPECIFIED = 0,
  BACCARAT_BET_CELL_BACCARAT_CELL_PLAYER = 1,
  BACCARAT_BET_CELL_BACCARAT_CELL_BANKER = 2,
  BACCARAT_BET_CELL_BACCARAT_CELL_TIE = 3,
  BACCARAT_BET_CELL_BACCARAT_CELL_PLAYER_PAIR = 4,
  BACCARAT_BET_CELL_BACCARAT_CELL_BANKER_PAIR = 5,
  UNRECOGNIZED = -1,
}

export function baccaratBetCellFromJSON(object: any): BaccaratBetCell {
  switch (object) {
    case 0:
    case "BACCARAT_BET_CELL_BACCARAT_CELL_UNSPECIFIED":
      return BaccaratBetCell.BACCARAT_BET_CELL_BACCARAT_CELL_UNSPECIFIED;
    case 1:
    case "BACCARAT_BET_CELL_BACCARAT_CELL_PLAYER":
      return BaccaratBetCell.BACCARAT_BET_CELL_BACCARAT_CELL_PLAYER;
    case 2:
    case "BACCARAT_BET_CELL_BACCARAT_CELL_BANKER":
      return BaccaratBetCell.BACCARAT_BET_CELL_BACCARAT_CELL_BANKER;
    case 3:
    case "BACCARAT_BET_CELL_BACCARAT_CELL_TIE":
      return BaccaratBetCell.BACCARAT_BET_CELL_BACCARAT_CELL_TIE;
    case 4:
    case "BACCARAT_BET_CELL_BACCARAT_CELL_PLAYER_PAIR":
      return BaccaratBetCell.BACCARAT_BET_CELL_BACCARAT_CELL_PLAYER_PAIR;
    case 5:
    case "BACCARAT_BET_CELL_BACCARAT_CELL_BANKER_PAIR":
      return BaccaratBetCell.BACCARAT_BET_CELL_BACCARAT_CELL_BANKER_PAIR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BaccaratBetCell.UNRECOGNIZED;
  }
}

export function baccaratBetCellToJSON(object: BaccaratBetCell): string {
  switch (object) {
    case BaccaratBetCell.BACCARAT_BET_CELL_BACCARAT_CELL_UNSPECIFIED:
      return "BACCARAT_BET_CELL_BACCARAT_CELL_UNSPECIFIED";
    case BaccaratBetCell.BACCARAT_BET_CELL_BACCARAT_CELL_PLAYER:
      return "BACCARAT_BET_CELL_BACCARAT_CELL_PLAYER";
    case BaccaratBetCell.BACCARAT_BET_CELL_BACCARAT_CELL_BANKER:
      return "BACCARAT_BET_CELL_BACCARAT_CELL_BANKER";
    case BaccaratBetCell.BACCARAT_BET_CELL_BACCARAT_CELL_TIE:
      return "BACCARAT_BET_CELL_BACCARAT_CELL_TIE";
    case BaccaratBetCell.BACCARAT_BET_CELL_BACCARAT_CELL_PLAYER_PAIR:
      return "BACCARAT_BET_CELL_BACCARAT_CELL_PLAYER_PAIR";
    case BaccaratBetCell.BACCARAT_BET_CELL_BACCARAT_CELL_BANKER_PAIR:
      return "BACCARAT_BET_CELL_BACCARAT_CELL_BANKER_PAIR";
    case BaccaratBetCell.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TypeWinBaccarat {
  TYPEWIN_BACCARAT_NONE = 0,
  BANKER = 1,
  PLAYER = 2,
  TIE = 3,
  /** PLAYER_P - Player win + Banker pair */
  PLAYER_P = 102,
  /** PLAYER_B - Player win + Player pair */
  PLAYER_B = 12,
  /** PLAYER_PB - Player win + Both pair */
  PLAYER_PB = 112,
  /** BANKER_P - Banker win + Banker pair */
  BANKER_P = 101,
  /** BANKER_B - Banker win + Player pair */
  BANKER_B = 11,
  /** BANKER_PB - Banker win + Both pair */
  BANKER_PB = 111,
  /** TIE_P - Tie + Banker pair */
  TIE_P = 103,
  /** TIE_B - Tie + Player pair */
  TIE_B = 13,
  /** TIE_PB - Tie + Both pair */
  TIE_PB = 113,
  UNRECOGNIZED = -1,
}

export function typeWinBaccaratFromJSON(object: any): TypeWinBaccarat {
  switch (object) {
    case 0:
    case "TYPEWIN_BACCARAT_NONE":
      return TypeWinBaccarat.TYPEWIN_BACCARAT_NONE;
    case 1:
    case "BANKER":
      return TypeWinBaccarat.BANKER;
    case 2:
    case "PLAYER":
      return TypeWinBaccarat.PLAYER;
    case 3:
    case "TIE":
      return TypeWinBaccarat.TIE;
    case 102:
    case "PLAYER_P":
      return TypeWinBaccarat.PLAYER_P;
    case 12:
    case "PLAYER_B":
      return TypeWinBaccarat.PLAYER_B;
    case 112:
    case "PLAYER_PB":
      return TypeWinBaccarat.PLAYER_PB;
    case 101:
    case "BANKER_P":
      return TypeWinBaccarat.BANKER_P;
    case 11:
    case "BANKER_B":
      return TypeWinBaccarat.BANKER_B;
    case 111:
    case "BANKER_PB":
      return TypeWinBaccarat.BANKER_PB;
    case 103:
    case "TIE_P":
      return TypeWinBaccarat.TIE_P;
    case 13:
    case "TIE_B":
      return TypeWinBaccarat.TIE_B;
    case 113:
    case "TIE_PB":
      return TypeWinBaccarat.TIE_PB;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TypeWinBaccarat.UNRECOGNIZED;
  }
}

export function typeWinBaccaratToJSON(object: TypeWinBaccarat): string {
  switch (object) {
    case TypeWinBaccarat.TYPEWIN_BACCARAT_NONE:
      return "TYPEWIN_BACCARAT_NONE";
    case TypeWinBaccarat.BANKER:
      return "BANKER";
    case TypeWinBaccarat.PLAYER:
      return "PLAYER";
    case TypeWinBaccarat.TIE:
      return "TIE";
    case TypeWinBaccarat.PLAYER_P:
      return "PLAYER_P";
    case TypeWinBaccarat.PLAYER_B:
      return "PLAYER_B";
    case TypeWinBaccarat.PLAYER_PB:
      return "PLAYER_PB";
    case TypeWinBaccarat.BANKER_P:
      return "BANKER_P";
    case TypeWinBaccarat.BANKER_B:
      return "BANKER_B";
    case TypeWinBaccarat.BANKER_PB:
      return "BANKER_PB";
    case TypeWinBaccarat.TIE_P:
      return "TIE_P";
    case TypeWinBaccarat.TIE_B:
      return "TIE_B";
    case TypeWinBaccarat.TIE_PB:
      return "TIE_PB";
    case TypeWinBaccarat.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum BaccaratBetActionType {
  BACCARAT_BET_ACTION_TYPE_BACCARAT_BET_NORMAL_UNSPECIFIED = 0,
  BACCARAT_BET_ACTION_TYPE_BACCARAT_BET_REBET = 1,
  BACCARAT_BET_ACTION_TYPE_BACCARAT_BET_DOUBLE = 2,
  UNRECOGNIZED = -1,
}

export function baccaratBetActionTypeFromJSON(object: any): BaccaratBetActionType {
  switch (object) {
    case 0:
    case "BACCARAT_BET_ACTION_TYPE_BACCARAT_BET_NORMAL_UNSPECIFIED":
      return BaccaratBetActionType.BACCARAT_BET_ACTION_TYPE_BACCARAT_BET_NORMAL_UNSPECIFIED;
    case 1:
    case "BACCARAT_BET_ACTION_TYPE_BACCARAT_BET_REBET":
      return BaccaratBetActionType.BACCARAT_BET_ACTION_TYPE_BACCARAT_BET_REBET;
    case 2:
    case "BACCARAT_BET_ACTION_TYPE_BACCARAT_BET_DOUBLE":
      return BaccaratBetActionType.BACCARAT_BET_ACTION_TYPE_BACCARAT_BET_DOUBLE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BaccaratBetActionType.UNRECOGNIZED;
  }
}

export function baccaratBetActionTypeToJSON(object: BaccaratBetActionType): string {
  switch (object) {
    case BaccaratBetActionType.BACCARAT_BET_ACTION_TYPE_BACCARAT_BET_NORMAL_UNSPECIFIED:
      return "BACCARAT_BET_ACTION_TYPE_BACCARAT_BET_NORMAL_UNSPECIFIED";
    case BaccaratBetActionType.BACCARAT_BET_ACTION_TYPE_BACCARAT_BET_REBET:
      return "BACCARAT_BET_ACTION_TYPE_BACCARAT_BET_REBET";
    case BaccaratBetActionType.BACCARAT_BET_ACTION_TYPE_BACCARAT_BET_DOUBLE:
      return "BACCARAT_BET_ACTION_TYPE_BACCARAT_BET_DOUBLE";
    case BaccaratBetActionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum BaccaratBetRejectedReason {
  BACCARAT_BET_REJECTED_REASON_BACCARAT_BET_REJECTED_UNSPECIFIED = 0,
  BACCARAT_BET_REJECTED_REASON_BACCARAT_BET_REJECTED_BALANCE_NOT_ENOUGH = 1,
  BACCARAT_BET_REJECTED_REASON_BACCARAT_BET_REJECTED_PREVIOUS_BET_NOT_EXIST = 2,
  BACCARAT_BET_REJECTED_REASON_BACCARAT_BET_REJECTED_ALREADY_BET = 3,
  BACCARAT_BET_REJECTED_REASON_BACCARAT_BET_REJECTED_EXCEED_MAX_BET_ALLOWED = 4,
  UNRECOGNIZED = -1,
}

export function baccaratBetRejectedReasonFromJSON(object: any): BaccaratBetRejectedReason {
  switch (object) {
    case 0:
    case "BACCARAT_BET_REJECTED_REASON_BACCARAT_BET_REJECTED_UNSPECIFIED":
      return BaccaratBetRejectedReason.BACCARAT_BET_REJECTED_REASON_BACCARAT_BET_REJECTED_UNSPECIFIED;
    case 1:
    case "BACCARAT_BET_REJECTED_REASON_BACCARAT_BET_REJECTED_BALANCE_NOT_ENOUGH":
      return BaccaratBetRejectedReason.BACCARAT_BET_REJECTED_REASON_BACCARAT_BET_REJECTED_BALANCE_NOT_ENOUGH;
    case 2:
    case "BACCARAT_BET_REJECTED_REASON_BACCARAT_BET_REJECTED_PREVIOUS_BET_NOT_EXIST":
      return BaccaratBetRejectedReason.BACCARAT_BET_REJECTED_REASON_BACCARAT_BET_REJECTED_PREVIOUS_BET_NOT_EXIST;
    case 3:
    case "BACCARAT_BET_REJECTED_REASON_BACCARAT_BET_REJECTED_ALREADY_BET":
      return BaccaratBetRejectedReason.BACCARAT_BET_REJECTED_REASON_BACCARAT_BET_REJECTED_ALREADY_BET;
    case 4:
    case "BACCARAT_BET_REJECTED_REASON_BACCARAT_BET_REJECTED_EXCEED_MAX_BET_ALLOWED":
      return BaccaratBetRejectedReason.BACCARAT_BET_REJECTED_REASON_BACCARAT_BET_REJECTED_EXCEED_MAX_BET_ALLOWED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BaccaratBetRejectedReason.UNRECOGNIZED;
  }
}

export function baccaratBetRejectedReasonToJSON(object: BaccaratBetRejectedReason): string {
  switch (object) {
    case BaccaratBetRejectedReason.BACCARAT_BET_REJECTED_REASON_BACCARAT_BET_REJECTED_UNSPECIFIED:
      return "BACCARAT_BET_REJECTED_REASON_BACCARAT_BET_REJECTED_UNSPECIFIED";
    case BaccaratBetRejectedReason.BACCARAT_BET_REJECTED_REASON_BACCARAT_BET_REJECTED_BALANCE_NOT_ENOUGH:
      return "BACCARAT_BET_REJECTED_REASON_BACCARAT_BET_REJECTED_BALANCE_NOT_ENOUGH";
    case BaccaratBetRejectedReason.BACCARAT_BET_REJECTED_REASON_BACCARAT_BET_REJECTED_PREVIOUS_BET_NOT_EXIST:
      return "BACCARAT_BET_REJECTED_REASON_BACCARAT_BET_REJECTED_PREVIOUS_BET_NOT_EXIST";
    case BaccaratBetRejectedReason.BACCARAT_BET_REJECTED_REASON_BACCARAT_BET_REJECTED_ALREADY_BET:
      return "BACCARAT_BET_REJECTED_REASON_BACCARAT_BET_REJECTED_ALREADY_BET";
    case BaccaratBetRejectedReason.BACCARAT_BET_REJECTED_REASON_BACCARAT_BET_REJECTED_EXCEED_MAX_BET_ALLOWED:
      return "BACCARAT_BET_REJECTED_REASON_BACCARAT_BET_REJECTED_EXCEED_MAX_BET_ALLOWED";
    case BaccaratBetRejectedReason.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface BaccaratBet {
  chips: number;
  cell: BaccaratBetCell;
}

export interface BaccaratBetResult {
  bet: BaccaratBet | undefined;
  isWin: boolean;
}

export interface BaccaratPlayerBet {
  userId: string;
  actionType: BaccaratBetActionType;
  bets: BaccaratBet[];
}

export interface BaccaratPlayerBetResult {
  userId: string;
  lists: BaccaratBetResult[];
}

export interface BaccaratHand {
  cards: Card[];
  point: number;
  isPair: boolean;
}

export interface BaccaratHands {
  banker: BaccaratHand | undefined;
  player: BaccaratHand | undefined;
}

export interface BaccaratGameFinish {
  hand: BaccaratHands | undefined;
  winCells: BaccaratBetCell[];
  listBetResults: BaccaratPlayerBetResult[];
}

export interface BaccaratBetCellInfo {
  cell: BaccaratBetCell;
  chips: number;
  nUserBet: number;
}

export interface BaccaratSimpleHistory {
  bankerWin: number;
  playerWin: number;
  tie: number;
  bankerPair: number;
  playerPair: number;
}

export interface BaccaratUpdateDesk {
  nPlayers: number;
  isUpdateUserBet: boolean;
  isUpdateDeskCell: boolean;
  isUpdateGameHistory: boolean;
  userBet: BaccaratPlayerBet | undefined;
  deskCells: BaccaratBetCellInfo[];
  history: BaccaratSimpleHistory | undefined;
  detailedHistory: TypeWinBaccarat[];
  error: Error | undefined;
}

export interface BaccaratBetActionReject {
  reason: BaccaratBetRejectedReason;
}

/**
 * send deal card server->client, is_player = true mean that that card is for
 * player, else banker append those card into respectively player hand hands
 * field is purely for sync between server and client, use it as u want
 */
export interface BaccaratUpdateDeal {
  isPlayer: boolean;
  cards: Card[];
  hands: BaccaratHands | undefined;
}

function createBaseBaccaratBet(): BaccaratBet {
  return { chips: 0, cell: 0 };
}

export const BaccaratBet = {
  encode(message: BaccaratBet, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chips !== 0) {
      writer.uint32(16).int64(message.chips);
    }
    if (message.cell !== 0) {
      writer.uint32(24).int32(message.cell);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BaccaratBet {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBaccaratBet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 16) {
            break;
          }

          message.chips = longToNumber(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.cell = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BaccaratBet {
    return {
      chips: isSet(object.chips) ? globalThis.Number(object.chips) : 0,
      cell: isSet(object.cell) ? baccaratBetCellFromJSON(object.cell) : 0,
    };
  },

  toJSON(message: BaccaratBet): unknown {
    const obj: any = {};
    if (message.chips !== 0) {
      obj.chips = Math.round(message.chips);
    }
    if (message.cell !== 0) {
      obj.cell = baccaratBetCellToJSON(message.cell);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BaccaratBet>, I>>(base?: I): BaccaratBet {
    return BaccaratBet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BaccaratBet>, I>>(object: I): BaccaratBet {
    const message = createBaseBaccaratBet();
    message.chips = object.chips ?? 0;
    message.cell = object.cell ?? 0;
    return message;
  },
};

function createBaseBaccaratBetResult(): BaccaratBetResult {
  return { bet: undefined, isWin: false };
}

export const BaccaratBetResult = {
  encode(message: BaccaratBetResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.bet !== undefined) {
      BaccaratBet.encode(message.bet, writer.uint32(10).fork()).ldelim();
    }
    if (message.isWin !== false) {
      writer.uint32(16).bool(message.isWin);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BaccaratBetResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBaccaratBetResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.bet = BaccaratBet.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.isWin = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BaccaratBetResult {
    return {
      bet: isSet(object.bet) ? BaccaratBet.fromJSON(object.bet) : undefined,
      isWin: isSet(object.isWin) ? globalThis.Boolean(object.isWin) : false,
    };
  },

  toJSON(message: BaccaratBetResult): unknown {
    const obj: any = {};
    if (message.bet !== undefined) {
      obj.bet = BaccaratBet.toJSON(message.bet);
    }
    if (message.isWin !== false) {
      obj.isWin = message.isWin;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BaccaratBetResult>, I>>(base?: I): BaccaratBetResult {
    return BaccaratBetResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BaccaratBetResult>, I>>(object: I): BaccaratBetResult {
    const message = createBaseBaccaratBetResult();
    message.bet = (object.bet !== undefined && object.bet !== null) ? BaccaratBet.fromPartial(object.bet) : undefined;
    message.isWin = object.isWin ?? false;
    return message;
  },
};

function createBaseBaccaratPlayerBet(): BaccaratPlayerBet {
  return { userId: "", actionType: 0, bets: [] };
}

export const BaccaratPlayerBet = {
  encode(message: BaccaratPlayerBet, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.actionType !== 0) {
      writer.uint32(16).int32(message.actionType);
    }
    for (const v of message.bets) {
      BaccaratBet.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BaccaratPlayerBet {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBaccaratPlayerBet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.actionType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.bets.push(BaccaratBet.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BaccaratPlayerBet {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      actionType: isSet(object.actionType) ? baccaratBetActionTypeFromJSON(object.actionType) : 0,
      bets: globalThis.Array.isArray(object?.bets) ? object.bets.map((e: any) => BaccaratBet.fromJSON(e)) : [],
    };
  },

  toJSON(message: BaccaratPlayerBet): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.actionType !== 0) {
      obj.actionType = baccaratBetActionTypeToJSON(message.actionType);
    }
    if (message.bets?.length) {
      obj.bets = message.bets.map((e) => BaccaratBet.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BaccaratPlayerBet>, I>>(base?: I): BaccaratPlayerBet {
    return BaccaratPlayerBet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BaccaratPlayerBet>, I>>(object: I): BaccaratPlayerBet {
    const message = createBaseBaccaratPlayerBet();
    message.userId = object.userId ?? "";
    message.actionType = object.actionType ?? 0;
    message.bets = object.bets?.map((e) => BaccaratBet.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBaccaratPlayerBetResult(): BaccaratPlayerBetResult {
  return { userId: "", lists: [] };
}

export const BaccaratPlayerBetResult = {
  encode(message: BaccaratPlayerBetResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    for (const v of message.lists) {
      BaccaratBetResult.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BaccaratPlayerBetResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBaccaratPlayerBetResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.lists.push(BaccaratBetResult.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BaccaratPlayerBetResult {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      lists: globalThis.Array.isArray(object?.lists) ? object.lists.map((e: any) => BaccaratBetResult.fromJSON(e)) : [],
    };
  },

  toJSON(message: BaccaratPlayerBetResult): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.lists?.length) {
      obj.lists = message.lists.map((e) => BaccaratBetResult.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BaccaratPlayerBetResult>, I>>(base?: I): BaccaratPlayerBetResult {
    return BaccaratPlayerBetResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BaccaratPlayerBetResult>, I>>(object: I): BaccaratPlayerBetResult {
    const message = createBaseBaccaratPlayerBetResult();
    message.userId = object.userId ?? "";
    message.lists = object.lists?.map((e) => BaccaratBetResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBaccaratHand(): BaccaratHand {
  return { cards: [], point: 0, isPair: false };
}

export const BaccaratHand = {
  encode(message: BaccaratHand, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.cards) {
      Card.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.point !== 0) {
      writer.uint32(16).int32(message.point);
    }
    if (message.isPair !== false) {
      writer.uint32(24).bool(message.isPair);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BaccaratHand {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBaccaratHand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cards.push(Card.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.point = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.isPair = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BaccaratHand {
    return {
      cards: globalThis.Array.isArray(object?.cards) ? object.cards.map((e: any) => Card.fromJSON(e)) : [],
      point: isSet(object.point) ? globalThis.Number(object.point) : 0,
      isPair: isSet(object.isPair) ? globalThis.Boolean(object.isPair) : false,
    };
  },

  toJSON(message: BaccaratHand): unknown {
    const obj: any = {};
    if (message.cards?.length) {
      obj.cards = message.cards.map((e) => Card.toJSON(e));
    }
    if (message.point !== 0) {
      obj.point = Math.round(message.point);
    }
    if (message.isPair !== false) {
      obj.isPair = message.isPair;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BaccaratHand>, I>>(base?: I): BaccaratHand {
    return BaccaratHand.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BaccaratHand>, I>>(object: I): BaccaratHand {
    const message = createBaseBaccaratHand();
    message.cards = object.cards?.map((e) => Card.fromPartial(e)) || [];
    message.point = object.point ?? 0;
    message.isPair = object.isPair ?? false;
    return message;
  },
};

function createBaseBaccaratHands(): BaccaratHands {
  return { banker: undefined, player: undefined };
}

export const BaccaratHands = {
  encode(message: BaccaratHands, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.banker !== undefined) {
      BaccaratHand.encode(message.banker, writer.uint32(10).fork()).ldelim();
    }
    if (message.player !== undefined) {
      BaccaratHand.encode(message.player, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BaccaratHands {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBaccaratHands();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.banker = BaccaratHand.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.player = BaccaratHand.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BaccaratHands {
    return {
      banker: isSet(object.banker) ? BaccaratHand.fromJSON(object.banker) : undefined,
      player: isSet(object.player) ? BaccaratHand.fromJSON(object.player) : undefined,
    };
  },

  toJSON(message: BaccaratHands): unknown {
    const obj: any = {};
    if (message.banker !== undefined) {
      obj.banker = BaccaratHand.toJSON(message.banker);
    }
    if (message.player !== undefined) {
      obj.player = BaccaratHand.toJSON(message.player);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BaccaratHands>, I>>(base?: I): BaccaratHands {
    return BaccaratHands.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BaccaratHands>, I>>(object: I): BaccaratHands {
    const message = createBaseBaccaratHands();
    message.banker = (object.banker !== undefined && object.banker !== null)
      ? BaccaratHand.fromPartial(object.banker)
      : undefined;
    message.player = (object.player !== undefined && object.player !== null)
      ? BaccaratHand.fromPartial(object.player)
      : undefined;
    return message;
  },
};

function createBaseBaccaratGameFinish(): BaccaratGameFinish {
  return { hand: undefined, winCells: [], listBetResults: [] };
}

export const BaccaratGameFinish = {
  encode(message: BaccaratGameFinish, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.hand !== undefined) {
      BaccaratHands.encode(message.hand, writer.uint32(10).fork()).ldelim();
    }
    writer.uint32(26).fork();
    for (const v of message.winCells) {
      writer.int32(v);
    }
    writer.ldelim();
    for (const v of message.listBetResults) {
      BaccaratPlayerBetResult.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BaccaratGameFinish {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBaccaratGameFinish();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hand = BaccaratHands.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag === 24) {
            message.winCells.push(reader.int32() as any);

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.winCells.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.listBetResults.push(BaccaratPlayerBetResult.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BaccaratGameFinish {
    return {
      hand: isSet(object.hand) ? BaccaratHands.fromJSON(object.hand) : undefined,
      winCells: globalThis.Array.isArray(object?.winCells)
        ? object.winCells.map((e: any) => baccaratBetCellFromJSON(e))
        : [],
      listBetResults: globalThis.Array.isArray(object?.listBetResults)
        ? object.listBetResults.map((e: any) => BaccaratPlayerBetResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BaccaratGameFinish): unknown {
    const obj: any = {};
    if (message.hand !== undefined) {
      obj.hand = BaccaratHands.toJSON(message.hand);
    }
    if (message.winCells?.length) {
      obj.winCells = message.winCells.map((e) => baccaratBetCellToJSON(e));
    }
    if (message.listBetResults?.length) {
      obj.listBetResults = message.listBetResults.map((e) => BaccaratPlayerBetResult.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BaccaratGameFinish>, I>>(base?: I): BaccaratGameFinish {
    return BaccaratGameFinish.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BaccaratGameFinish>, I>>(object: I): BaccaratGameFinish {
    const message = createBaseBaccaratGameFinish();
    message.hand = (object.hand !== undefined && object.hand !== null)
      ? BaccaratHands.fromPartial(object.hand)
      : undefined;
    message.winCells = object.winCells?.map((e) => e) || [];
    message.listBetResults = object.listBetResults?.map((e) => BaccaratPlayerBetResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBaccaratBetCellInfo(): BaccaratBetCellInfo {
  return { cell: 0, chips: 0, nUserBet: 0 };
}

export const BaccaratBetCellInfo = {
  encode(message: BaccaratBetCellInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cell !== 0) {
      writer.uint32(8).int32(message.cell);
    }
    if (message.chips !== 0) {
      writer.uint32(16).int64(message.chips);
    }
    if (message.nUserBet !== 0) {
      writer.uint32(24).int32(message.nUserBet);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BaccaratBetCellInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBaccaratBetCellInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.cell = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.chips = longToNumber(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.nUserBet = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BaccaratBetCellInfo {
    return {
      cell: isSet(object.cell) ? baccaratBetCellFromJSON(object.cell) : 0,
      chips: isSet(object.chips) ? globalThis.Number(object.chips) : 0,
      nUserBet: isSet(object.nUserBet) ? globalThis.Number(object.nUserBet) : 0,
    };
  },

  toJSON(message: BaccaratBetCellInfo): unknown {
    const obj: any = {};
    if (message.cell !== 0) {
      obj.cell = baccaratBetCellToJSON(message.cell);
    }
    if (message.chips !== 0) {
      obj.chips = Math.round(message.chips);
    }
    if (message.nUserBet !== 0) {
      obj.nUserBet = Math.round(message.nUserBet);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BaccaratBetCellInfo>, I>>(base?: I): BaccaratBetCellInfo {
    return BaccaratBetCellInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BaccaratBetCellInfo>, I>>(object: I): BaccaratBetCellInfo {
    const message = createBaseBaccaratBetCellInfo();
    message.cell = object.cell ?? 0;
    message.chips = object.chips ?? 0;
    message.nUserBet = object.nUserBet ?? 0;
    return message;
  },
};

function createBaseBaccaratSimpleHistory(): BaccaratSimpleHistory {
  return { bankerWin: 0, playerWin: 0, tie: 0, bankerPair: 0, playerPair: 0 };
}

export const BaccaratSimpleHistory = {
  encode(message: BaccaratSimpleHistory, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.bankerWin !== 0) {
      writer.uint32(8).int32(message.bankerWin);
    }
    if (message.playerWin !== 0) {
      writer.uint32(16).int32(message.playerWin);
    }
    if (message.tie !== 0) {
      writer.uint32(24).int32(message.tie);
    }
    if (message.bankerPair !== 0) {
      writer.uint32(32).int32(message.bankerPair);
    }
    if (message.playerPair !== 0) {
      writer.uint32(40).int32(message.playerPair);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BaccaratSimpleHistory {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBaccaratSimpleHistory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.bankerWin = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.playerWin = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.tie = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.bankerPair = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.playerPair = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BaccaratSimpleHistory {
    return {
      bankerWin: isSet(object.bankerWin) ? globalThis.Number(object.bankerWin) : 0,
      playerWin: isSet(object.playerWin) ? globalThis.Number(object.playerWin) : 0,
      tie: isSet(object.tie) ? globalThis.Number(object.tie) : 0,
      bankerPair: isSet(object.bankerPair) ? globalThis.Number(object.bankerPair) : 0,
      playerPair: isSet(object.playerPair) ? globalThis.Number(object.playerPair) : 0,
    };
  },

  toJSON(message: BaccaratSimpleHistory): unknown {
    const obj: any = {};
    if (message.bankerWin !== 0) {
      obj.bankerWin = Math.round(message.bankerWin);
    }
    if (message.playerWin !== 0) {
      obj.playerWin = Math.round(message.playerWin);
    }
    if (message.tie !== 0) {
      obj.tie = Math.round(message.tie);
    }
    if (message.bankerPair !== 0) {
      obj.bankerPair = Math.round(message.bankerPair);
    }
    if (message.playerPair !== 0) {
      obj.playerPair = Math.round(message.playerPair);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BaccaratSimpleHistory>, I>>(base?: I): BaccaratSimpleHistory {
    return BaccaratSimpleHistory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BaccaratSimpleHistory>, I>>(object: I): BaccaratSimpleHistory {
    const message = createBaseBaccaratSimpleHistory();
    message.bankerWin = object.bankerWin ?? 0;
    message.playerWin = object.playerWin ?? 0;
    message.tie = object.tie ?? 0;
    message.bankerPair = object.bankerPair ?? 0;
    message.playerPair = object.playerPair ?? 0;
    return message;
  },
};

function createBaseBaccaratUpdateDesk(): BaccaratUpdateDesk {
  return {
    nPlayers: 0,
    isUpdateUserBet: false,
    isUpdateDeskCell: false,
    isUpdateGameHistory: false,
    userBet: undefined,
    deskCells: [],
    history: undefined,
    detailedHistory: [],
    error: undefined,
  };
}

export const BaccaratUpdateDesk = {
  encode(message: BaccaratUpdateDesk, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.nPlayers !== 0) {
      writer.uint32(8).int32(message.nPlayers);
    }
    if (message.isUpdateUserBet !== false) {
      writer.uint32(16).bool(message.isUpdateUserBet);
    }
    if (message.isUpdateDeskCell !== false) {
      writer.uint32(24).bool(message.isUpdateDeskCell);
    }
    if (message.isUpdateGameHistory !== false) {
      writer.uint32(32).bool(message.isUpdateGameHistory);
    }
    if (message.userBet !== undefined) {
      BaccaratPlayerBet.encode(message.userBet, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.deskCells) {
      BaccaratBetCellInfo.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    if (message.history !== undefined) {
      BaccaratSimpleHistory.encode(message.history, writer.uint32(58).fork()).ldelim();
    }
    writer.uint32(66).fork();
    for (const v of message.detailedHistory) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BaccaratUpdateDesk {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBaccaratUpdateDesk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.nPlayers = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.isUpdateUserBet = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.isUpdateDeskCell = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.isUpdateGameHistory = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.userBet = BaccaratPlayerBet.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.deskCells.push(BaccaratBetCellInfo.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.history = BaccaratSimpleHistory.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag === 64) {
            message.detailedHistory.push(reader.int32() as any);

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.detailedHistory.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BaccaratUpdateDesk {
    return {
      nPlayers: isSet(object.nPlayers) ? globalThis.Number(object.nPlayers) : 0,
      isUpdateUserBet: isSet(object.isUpdateUserBet) ? globalThis.Boolean(object.isUpdateUserBet) : false,
      isUpdateDeskCell: isSet(object.isUpdateDeskCell) ? globalThis.Boolean(object.isUpdateDeskCell) : false,
      isUpdateGameHistory: isSet(object.isUpdateGameHistory) ? globalThis.Boolean(object.isUpdateGameHistory) : false,
      userBet: isSet(object.userBet) ? BaccaratPlayerBet.fromJSON(object.userBet) : undefined,
      deskCells: globalThis.Array.isArray(object?.deskCells)
        ? object.deskCells.map((e: any) => BaccaratBetCellInfo.fromJSON(e))
        : [],
      history: isSet(object.history) ? BaccaratSimpleHistory.fromJSON(object.history) : undefined,
      detailedHistory: globalThis.Array.isArray(object?.detailedHistory)
        ? object.detailedHistory.map((e: any) => typeWinBaccaratFromJSON(e))
        : [],
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: BaccaratUpdateDesk): unknown {
    const obj: any = {};
    if (message.nPlayers !== 0) {
      obj.nPlayers = Math.round(message.nPlayers);
    }
    if (message.isUpdateUserBet !== false) {
      obj.isUpdateUserBet = message.isUpdateUserBet;
    }
    if (message.isUpdateDeskCell !== false) {
      obj.isUpdateDeskCell = message.isUpdateDeskCell;
    }
    if (message.isUpdateGameHistory !== false) {
      obj.isUpdateGameHistory = message.isUpdateGameHistory;
    }
    if (message.userBet !== undefined) {
      obj.userBet = BaccaratPlayerBet.toJSON(message.userBet);
    }
    if (message.deskCells?.length) {
      obj.deskCells = message.deskCells.map((e) => BaccaratBetCellInfo.toJSON(e));
    }
    if (message.history !== undefined) {
      obj.history = BaccaratSimpleHistory.toJSON(message.history);
    }
    if (message.detailedHistory?.length) {
      obj.detailedHistory = message.detailedHistory.map((e) => typeWinBaccaratToJSON(e));
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BaccaratUpdateDesk>, I>>(base?: I): BaccaratUpdateDesk {
    return BaccaratUpdateDesk.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BaccaratUpdateDesk>, I>>(object: I): BaccaratUpdateDesk {
    const message = createBaseBaccaratUpdateDesk();
    message.nPlayers = object.nPlayers ?? 0;
    message.isUpdateUserBet = object.isUpdateUserBet ?? false;
    message.isUpdateDeskCell = object.isUpdateDeskCell ?? false;
    message.isUpdateGameHistory = object.isUpdateGameHistory ?? false;
    message.userBet = (object.userBet !== undefined && object.userBet !== null)
      ? BaccaratPlayerBet.fromPartial(object.userBet)
      : undefined;
    message.deskCells = object.deskCells?.map((e) => BaccaratBetCellInfo.fromPartial(e)) || [];
    message.history = (object.history !== undefined && object.history !== null)
      ? BaccaratSimpleHistory.fromPartial(object.history)
      : undefined;
    message.detailedHistory = object.detailedHistory?.map((e) => e) || [];
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseBaccaratBetActionReject(): BaccaratBetActionReject {
  return { reason: 0 };
}

export const BaccaratBetActionReject = {
  encode(message: BaccaratBetActionReject, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reason !== 0) {
      writer.uint32(8).int32(message.reason);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BaccaratBetActionReject {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBaccaratBetActionReject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reason = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BaccaratBetActionReject {
    return { reason: isSet(object.reason) ? baccaratBetRejectedReasonFromJSON(object.reason) : 0 };
  },

  toJSON(message: BaccaratBetActionReject): unknown {
    const obj: any = {};
    if (message.reason !== 0) {
      obj.reason = baccaratBetRejectedReasonToJSON(message.reason);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BaccaratBetActionReject>, I>>(base?: I): BaccaratBetActionReject {
    return BaccaratBetActionReject.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BaccaratBetActionReject>, I>>(object: I): BaccaratBetActionReject {
    const message = createBaseBaccaratBetActionReject();
    message.reason = object.reason ?? 0;
    return message;
  },
};

function createBaseBaccaratUpdateDeal(): BaccaratUpdateDeal {
  return { isPlayer: false, cards: [], hands: undefined };
}

export const BaccaratUpdateDeal = {
  encode(message: BaccaratUpdateDeal, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.isPlayer !== false) {
      writer.uint32(8).bool(message.isPlayer);
    }
    for (const v of message.cards) {
      Card.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.hands !== undefined) {
      BaccaratHands.encode(message.hands, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BaccaratUpdateDeal {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBaccaratUpdateDeal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.isPlayer = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cards.push(Card.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.hands = BaccaratHands.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BaccaratUpdateDeal {
    return {
      isPlayer: isSet(object.isPlayer) ? globalThis.Boolean(object.isPlayer) : false,
      cards: globalThis.Array.isArray(object?.cards) ? object.cards.map((e: any) => Card.fromJSON(e)) : [],
      hands: isSet(object.hands) ? BaccaratHands.fromJSON(object.hands) : undefined,
    };
  },

  toJSON(message: BaccaratUpdateDeal): unknown {
    const obj: any = {};
    if (message.isPlayer !== false) {
      obj.isPlayer = message.isPlayer;
    }
    if (message.cards?.length) {
      obj.cards = message.cards.map((e) => Card.toJSON(e));
    }
    if (message.hands !== undefined) {
      obj.hands = BaccaratHands.toJSON(message.hands);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BaccaratUpdateDeal>, I>>(base?: I): BaccaratUpdateDeal {
    return BaccaratUpdateDeal.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BaccaratUpdateDeal>, I>>(object: I): BaccaratUpdateDeal {
    const message = createBaseBaccaratUpdateDeal();
    message.isPlayer = object.isPlayer ?? false;
    message.cards = object.cards?.map((e) => Card.fromPartial(e)) || [];
    message.hands = (object.hands !== undefined && object.hands !== null)
      ? BaccaratHands.fromPartial(object.hands)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
