// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               unknown
// source: game_common.proto

/* eslint-disable */
import * as _m0 from "protobufjs/minimal";
import Long = require("long");

export const protobufPackage = "proto";

export enum CardStatus {
  STATUS_HOLD = 0,
  STATUS_UNHOLD = 1,
  UNRECOGNIZED = -1,
}

export function cardStatusFromJSON(object: any): CardStatus {
  switch (object) {
    case 0:
    case "STATUS_HOLD":
      return CardStatus.STATUS_HOLD;
    case 1:
    case "STATUS_UNHOLD":
      return CardStatus.STATUS_UNHOLD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CardStatus.UNRECOGNIZED;
  }
}

export function cardStatusToJSON(object: CardStatus): string {
  switch (object) {
    case CardStatus.STATUS_HOLD:
      return "STATUS_HOLD";
    case CardStatus.STATUS_UNHOLD:
      return "STATUS_UNHOLD";
    case CardStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum GameState {
  GAME_STATE_UNKNOWN = 0,
  GAME_STATE_IDLE = 1,
  GAME_STATE_MATCHING = 2,
  GAME_STATE_PREPARING = 3,
  GAME_STATE_PLAY = 4,
  GAME_STATE_REWARD = 5,
  GAME_STATE_FINISH = 6,
  UNRECOGNIZED = -1,
}

export function gameStateFromJSON(object: any): GameState {
  switch (object) {
    case 0:
    case "GAME_STATE_UNKNOWN":
      return GameState.GAME_STATE_UNKNOWN;
    case 1:
    case "GAME_STATE_IDLE":
      return GameState.GAME_STATE_IDLE;
    case 2:
    case "GAME_STATE_MATCHING":
      return GameState.GAME_STATE_MATCHING;
    case 3:
    case "GAME_STATE_PREPARING":
      return GameState.GAME_STATE_PREPARING;
    case 4:
    case "GAME_STATE_PLAY":
      return GameState.GAME_STATE_PLAY;
    case 5:
    case "GAME_STATE_REWARD":
      return GameState.GAME_STATE_REWARD;
    case 6:
    case "GAME_STATE_FINISH":
      return GameState.GAME_STATE_FINISH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GameState.UNRECOGNIZED;
  }
}

export function gameStateToJSON(object: GameState): string {
  switch (object) {
    case GameState.GAME_STATE_UNKNOWN:
      return "GAME_STATE_UNKNOWN";
    case GameState.GAME_STATE_IDLE:
      return "GAME_STATE_IDLE";
    case GameState.GAME_STATE_MATCHING:
      return "GAME_STATE_MATCHING";
    case GameState.GAME_STATE_PREPARING:
      return "GAME_STATE_PREPARING";
    case GameState.GAME_STATE_PLAY:
      return "GAME_STATE_PLAY";
    case GameState.GAME_STATE_REWARD:
      return "GAME_STATE_REWARD";
    case GameState.GAME_STATE_FINISH:
      return "GAME_STATE_FINISH";
    case GameState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum OpCodeRequest {
  OPCODE_UNSPECIFIED = 0,
  /** OPCODE_REQUEST_NEW_GAME - New game round starting. */
  OPCODE_REQUEST_NEW_GAME = 1,
  OPCODE_REQUEST_LEAVE_GAME = 2,
  /** OPCODE_REQUEST_PLAY_CARD - client chơi 1 lá */
  OPCODE_REQUEST_PLAY_CARD = 3,
  /** OPCODE_REQUEST_DRAW_CARD - client yêu cầu rút bài */
  OPCODE_REQUEST_DRAW_CARD = 4,
  /** OPCODE_REQUEST_CALL_WHOT - nếu client đánh WHOT, call lựa chọn suit */
  OPCODE_REQUEST_CALL_WHOT = 5,
  /** OPCODE_USER_INTERACT_CARDS - client tương tác với cards */
  OPCODE_USER_INTERACT_CARDS = 6,
  /** OPCODE_REQUEST_SPIN - game slots */
  OPCODE_REQUEST_SPIN = 7,
  OPCODE_REQUEST_BET = 8,
  /** OPCODE_REQUEST_USER_IN_TABLE - get table info */
  OPCODE_REQUEST_USER_IN_TABLE = 9,
  /** OPCODE_REQUEST_INFO_TABLE -  */
  OPCODE_REQUEST_INFO_TABLE = 10,
  /** OPCODE_REQUEST_HISTORY_RESULT -  */
  OPCODE_REQUEST_HISTORY_RESULT = 11,
  OPCODE_REQUEST_BUY_SIXIANG_GEM = 12,
  OPCODE_REQUEST_TIP_INGAME = 13,
  OPCODE_REQUEST_SYNC_TABLE = 14,
  OPCODE_REQUEST_COMBINE_CARDS = 15,
  OPCODE_REQUEST_SHOW_CARDS = 16,
  OPCODE_REQUEST_DECLARE_CARDS = 17,
  UNRECOGNIZED = -1,
}

export function opCodeRequestFromJSON(object: any): OpCodeRequest {
  switch (object) {
    case 0:
    case "OPCODE_UNSPECIFIED":
      return OpCodeRequest.OPCODE_UNSPECIFIED;
    case 1:
    case "OPCODE_REQUEST_NEW_GAME":
      return OpCodeRequest.OPCODE_REQUEST_NEW_GAME;
    case 2:
    case "OPCODE_REQUEST_LEAVE_GAME":
      return OpCodeRequest.OPCODE_REQUEST_LEAVE_GAME;
    case 3:
    case "OPCODE_REQUEST_PLAY_CARD":
      return OpCodeRequest.OPCODE_REQUEST_PLAY_CARD;
    case 4:
    case "OPCODE_REQUEST_DRAW_CARD":
      return OpCodeRequest.OPCODE_REQUEST_DRAW_CARD;
    case 5:
    case "OPCODE_REQUEST_CALL_WHOT":
      return OpCodeRequest.OPCODE_REQUEST_CALL_WHOT;
    case 6:
    case "OPCODE_USER_INTERACT_CARDS":
      return OpCodeRequest.OPCODE_USER_INTERACT_CARDS;
    case 7:
    case "OPCODE_REQUEST_SPIN":
      return OpCodeRequest.OPCODE_REQUEST_SPIN;
    case 8:
    case "OPCODE_REQUEST_BET":
      return OpCodeRequest.OPCODE_REQUEST_BET;
    case 9:
    case "OPCODE_REQUEST_USER_IN_TABLE":
      return OpCodeRequest.OPCODE_REQUEST_USER_IN_TABLE;
    case 10:
    case "OPCODE_REQUEST_INFO_TABLE":
      return OpCodeRequest.OPCODE_REQUEST_INFO_TABLE;
    case 11:
    case "OPCODE_REQUEST_HISTORY_RESULT":
      return OpCodeRequest.OPCODE_REQUEST_HISTORY_RESULT;
    case 12:
    case "OPCODE_REQUEST_BUY_SIXIANG_GEM":
      return OpCodeRequest.OPCODE_REQUEST_BUY_SIXIANG_GEM;
    case 13:
    case "OPCODE_REQUEST_TIP_INGAME":
      return OpCodeRequest.OPCODE_REQUEST_TIP_INGAME;
    case 14:
    case "OPCODE_REQUEST_SYNC_TABLE":
      return OpCodeRequest.OPCODE_REQUEST_SYNC_TABLE;
    case 15:
    case "OPCODE_REQUEST_COMBINE_CARDS":
      return OpCodeRequest.OPCODE_REQUEST_COMBINE_CARDS;
    case 16:
    case "OPCODE_REQUEST_SHOW_CARDS":
      return OpCodeRequest.OPCODE_REQUEST_SHOW_CARDS;
    case 17:
    case "OPCODE_REQUEST_DECLARE_CARDS":
      return OpCodeRequest.OPCODE_REQUEST_DECLARE_CARDS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OpCodeRequest.UNRECOGNIZED;
  }
}

export function opCodeRequestToJSON(object: OpCodeRequest): string {
  switch (object) {
    case OpCodeRequest.OPCODE_UNSPECIFIED:
      return "OPCODE_UNSPECIFIED";
    case OpCodeRequest.OPCODE_REQUEST_NEW_GAME:
      return "OPCODE_REQUEST_NEW_GAME";
    case OpCodeRequest.OPCODE_REQUEST_LEAVE_GAME:
      return "OPCODE_REQUEST_LEAVE_GAME";
    case OpCodeRequest.OPCODE_REQUEST_PLAY_CARD:
      return "OPCODE_REQUEST_PLAY_CARD";
    case OpCodeRequest.OPCODE_REQUEST_DRAW_CARD:
      return "OPCODE_REQUEST_DRAW_CARD";
    case OpCodeRequest.OPCODE_REQUEST_CALL_WHOT:
      return "OPCODE_REQUEST_CALL_WHOT";
    case OpCodeRequest.OPCODE_USER_INTERACT_CARDS:
      return "OPCODE_USER_INTERACT_CARDS";
    case OpCodeRequest.OPCODE_REQUEST_SPIN:
      return "OPCODE_REQUEST_SPIN";
    case OpCodeRequest.OPCODE_REQUEST_BET:
      return "OPCODE_REQUEST_BET";
    case OpCodeRequest.OPCODE_REQUEST_USER_IN_TABLE:
      return "OPCODE_REQUEST_USER_IN_TABLE";
    case OpCodeRequest.OPCODE_REQUEST_INFO_TABLE:
      return "OPCODE_REQUEST_INFO_TABLE";
    case OpCodeRequest.OPCODE_REQUEST_HISTORY_RESULT:
      return "OPCODE_REQUEST_HISTORY_RESULT";
    case OpCodeRequest.OPCODE_REQUEST_BUY_SIXIANG_GEM:
      return "OPCODE_REQUEST_BUY_SIXIANG_GEM";
    case OpCodeRequest.OPCODE_REQUEST_TIP_INGAME:
      return "OPCODE_REQUEST_TIP_INGAME";
    case OpCodeRequest.OPCODE_REQUEST_SYNC_TABLE:
      return "OPCODE_REQUEST_SYNC_TABLE";
    case OpCodeRequest.OPCODE_REQUEST_COMBINE_CARDS:
      return "OPCODE_REQUEST_COMBINE_CARDS";
    case OpCodeRequest.OPCODE_REQUEST_SHOW_CARDS:
      return "OPCODE_REQUEST_SHOW_CARDS";
    case OpCodeRequest.OPCODE_REQUEST_DECLARE_CARDS:
      return "OPCODE_REQUEST_DECLARE_CARDS";
    case OpCodeRequest.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum OpCodeUpdate {
  OPCODE_UPDATE_UNSPECIFIED = 0,
  /** OPCODE_UPDATE_TABLE - message UpdateTable */
  OPCODE_UPDATE_TABLE = 1,
  /** OPCODE_UPDATE_DEAL - message UpdateDeal */
  OPCODE_UPDATE_DEAL = 2,
  /** OPCODE_UPDATE_FINISH - message UpdateFinish */
  OPCODE_UPDATE_FINISH = 3,
  OPCODE_UPDATE_REJECTED = 4,
  OPCODE_UPDATE_GAME_STATE = 5,
  /** OPCODE_UPDATE_CARD_PLAYED - ai đó đã đánh bài */
  OPCODE_UPDATE_CARD_PLAYED = 6,
  /** OPCODE_UPDATE_DRAW_RESULT - kết quả rút bài (ai đó rút) */
  OPCODE_UPDATE_DRAW_RESULT = 7,
  /** OPCODE_UPDATE_CALL_WHOT_RESULT - kết quả chọn suit sau khi đánh WHOT */
  OPCODE_UPDATE_CALL_WHOT_RESULT = 8,
  /** OPCODE_UPDATE_TURN - thông báo tới lượt ai */
  OPCODE_UPDATE_TURN = 9,
  OPCODE_UPDATE_CARD_STATE = 10,
  OPCODE_UPDATE_WALLET = 11,
  OPCODE_KICK_OFF_THE_TABLE = 12,
  OPCODE_UPDATE_USER_INFO = 13,
  OPCODE_USER_IN_TABLE_INFO = 14,
  OPCODE_ERROR = 15,
  OPCODE_BUY_SIXIANG_GEM = 16,
  OPCODE_PLAYER_CHANGE = 17,
  OPCODE_RESPONSE_TIP_INGAME = 18,
  OPCODE_RESPONSE_SYNC_TABLE = 19,
  UNRECOGNIZED = -1,
}

export function opCodeUpdateFromJSON(object: any): OpCodeUpdate {
  switch (object) {
    case 0:
    case "OPCODE_UPDATE_UNSPECIFIED":
      return OpCodeUpdate.OPCODE_UPDATE_UNSPECIFIED;
    case 1:
    case "OPCODE_UPDATE_TABLE":
      return OpCodeUpdate.OPCODE_UPDATE_TABLE;
    case 2:
    case "OPCODE_UPDATE_DEAL":
      return OpCodeUpdate.OPCODE_UPDATE_DEAL;
    case 3:
    case "OPCODE_UPDATE_FINISH":
      return OpCodeUpdate.OPCODE_UPDATE_FINISH;
    case 4:
    case "OPCODE_UPDATE_REJECTED":
      return OpCodeUpdate.OPCODE_UPDATE_REJECTED;
    case 5:
    case "OPCODE_UPDATE_GAME_STATE":
      return OpCodeUpdate.OPCODE_UPDATE_GAME_STATE;
    case 6:
    case "OPCODE_UPDATE_CARD_PLAYED":
      return OpCodeUpdate.OPCODE_UPDATE_CARD_PLAYED;
    case 7:
    case "OPCODE_UPDATE_DRAW_RESULT":
      return OpCodeUpdate.OPCODE_UPDATE_DRAW_RESULT;
    case 8:
    case "OPCODE_UPDATE_CALL_WHOT_RESULT":
      return OpCodeUpdate.OPCODE_UPDATE_CALL_WHOT_RESULT;
    case 9:
    case "OPCODE_UPDATE_TURN":
      return OpCodeUpdate.OPCODE_UPDATE_TURN;
    case 10:
    case "OPCODE_UPDATE_CARD_STATE":
      return OpCodeUpdate.OPCODE_UPDATE_CARD_STATE;
    case 11:
    case "OPCODE_UPDATE_WALLET":
      return OpCodeUpdate.OPCODE_UPDATE_WALLET;
    case 12:
    case "OPCODE_KICK_OFF_THE_TABLE":
      return OpCodeUpdate.OPCODE_KICK_OFF_THE_TABLE;
    case 13:
    case "OPCODE_UPDATE_USER_INFO":
      return OpCodeUpdate.OPCODE_UPDATE_USER_INFO;
    case 14:
    case "OPCODE_USER_IN_TABLE_INFO":
      return OpCodeUpdate.OPCODE_USER_IN_TABLE_INFO;
    case 15:
    case "OPCODE_ERROR":
      return OpCodeUpdate.OPCODE_ERROR;
    case 16:
    case "OPCODE_BUY_SIXIANG_GEM":
      return OpCodeUpdate.OPCODE_BUY_SIXIANG_GEM;
    case 17:
    case "OPCODE_PLAYER_CHANGE":
      return OpCodeUpdate.OPCODE_PLAYER_CHANGE;
    case 18:
    case "OPCODE_RESPONSE_TIP_INGAME":
      return OpCodeUpdate.OPCODE_RESPONSE_TIP_INGAME;
    case 19:
    case "OPCODE_RESPONSE_SYNC_TABLE":
      return OpCodeUpdate.OPCODE_RESPONSE_SYNC_TABLE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OpCodeUpdate.UNRECOGNIZED;
  }
}

export function opCodeUpdateToJSON(object: OpCodeUpdate): string {
  switch (object) {
    case OpCodeUpdate.OPCODE_UPDATE_UNSPECIFIED:
      return "OPCODE_UPDATE_UNSPECIFIED";
    case OpCodeUpdate.OPCODE_UPDATE_TABLE:
      return "OPCODE_UPDATE_TABLE";
    case OpCodeUpdate.OPCODE_UPDATE_DEAL:
      return "OPCODE_UPDATE_DEAL";
    case OpCodeUpdate.OPCODE_UPDATE_FINISH:
      return "OPCODE_UPDATE_FINISH";
    case OpCodeUpdate.OPCODE_UPDATE_REJECTED:
      return "OPCODE_UPDATE_REJECTED";
    case OpCodeUpdate.OPCODE_UPDATE_GAME_STATE:
      return "OPCODE_UPDATE_GAME_STATE";
    case OpCodeUpdate.OPCODE_UPDATE_CARD_PLAYED:
      return "OPCODE_UPDATE_CARD_PLAYED";
    case OpCodeUpdate.OPCODE_UPDATE_DRAW_RESULT:
      return "OPCODE_UPDATE_DRAW_RESULT";
    case OpCodeUpdate.OPCODE_UPDATE_CALL_WHOT_RESULT:
      return "OPCODE_UPDATE_CALL_WHOT_RESULT";
    case OpCodeUpdate.OPCODE_UPDATE_TURN:
      return "OPCODE_UPDATE_TURN";
    case OpCodeUpdate.OPCODE_UPDATE_CARD_STATE:
      return "OPCODE_UPDATE_CARD_STATE";
    case OpCodeUpdate.OPCODE_UPDATE_WALLET:
      return "OPCODE_UPDATE_WALLET";
    case OpCodeUpdate.OPCODE_KICK_OFF_THE_TABLE:
      return "OPCODE_KICK_OFF_THE_TABLE";
    case OpCodeUpdate.OPCODE_UPDATE_USER_INFO:
      return "OPCODE_UPDATE_USER_INFO";
    case OpCodeUpdate.OPCODE_USER_IN_TABLE_INFO:
      return "OPCODE_USER_IN_TABLE_INFO";
    case OpCodeUpdate.OPCODE_ERROR:
      return "OPCODE_ERROR";
    case OpCodeUpdate.OPCODE_BUY_SIXIANG_GEM:
      return "OPCODE_BUY_SIXIANG_GEM";
    case OpCodeUpdate.OPCODE_PLAYER_CHANGE:
      return "OPCODE_PLAYER_CHANGE";
    case OpCodeUpdate.OPCODE_RESPONSE_TIP_INGAME:
      return "OPCODE_RESPONSE_TIP_INGAME";
    case OpCodeUpdate.OPCODE_RESPONSE_SYNC_TABLE:
      return "OPCODE_RESPONSE_SYNC_TABLE";
    case OpCodeUpdate.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Player {
  id: string;
  userName: string;
  wallet: string;
  isPlaying: boolean;
  vipLevel: number;
  avatarId: string;
  sid: number;
  order: number;
  cardStatus: CardStatus;
}

export interface Jackpot {
  id: number;
  userId: string;
  gameCode: string;
  chips: number;
  createTimeUnix: number;
}

export interface BalanceUpdate {
  userId: string;
  amountChipBefore: number;
  amountChipCurrent: number;
  amountChipAdd: number;
  amoutChipBet: number;
  amoutChipFee: number;
  amoutChipAddPrefee: number;
  totalChipInMatch: number;
}

export interface BalanceResult {
  updates: BalanceUpdate[];
  jackpot: Jackpot | undefined;
}

export interface HitJackpotHistory {
  userName: string;
  chips: number;
  createTimeUnix: number;
}

export interface UpdateTable {
  players: Player[];
  playingPlayers: Player[];
  joinPlayers: Player[];
  leavePlayers: Player[];
  /** chip bet info */
  bet: number;
  /** min level vip require join room */
  vip: number;
  /** timestamp play game */
  timePlay: number;
  /** remain time to end game */
  remainTime: number;
  gameState: GameState;
  jpTreasure: Jackpot | undefined;
}

function createBasePlayer(): Player {
  return {
    id: "",
    userName: "",
    wallet: "",
    isPlaying: false,
    vipLevel: 0,
    avatarId: "",
    sid: 0,
    order: 0,
    cardStatus: 0,
  };
}

export const Player = {
  encode(message: Player, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.userName !== "") {
      writer.uint32(18).string(message.userName);
    }
    if (message.wallet !== "") {
      writer.uint32(26).string(message.wallet);
    }
    if (message.isPlaying !== false) {
      writer.uint32(32).bool(message.isPlaying);
    }
    if (message.vipLevel !== 0) {
      writer.uint32(48).int64(message.vipLevel);
    }
    if (message.avatarId !== "") {
      writer.uint32(58).string(message.avatarId);
    }
    if (message.sid !== 0) {
      writer.uint32(64).int64(message.sid);
    }
    if (message.order !== 0) {
      writer.uint32(72).int32(message.order);
    }
    if (message.cardStatus !== 0) {
      writer.uint32(80).int32(message.cardStatus);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Player {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.wallet = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.isPlaying = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.vipLevel = longToNumber(reader.int64() as Long);
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.avatarId = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.sid = longToNumber(reader.int64() as Long);
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.order = reader.int32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.cardStatus = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Player {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      userName: isSet(object.userName) ? globalThis.String(object.userName) : "",
      wallet: isSet(object.wallet) ? globalThis.String(object.wallet) : "",
      isPlaying: isSet(object.isPlaying) ? globalThis.Boolean(object.isPlaying) : false,
      vipLevel: isSet(object.vipLevel) ? globalThis.Number(object.vipLevel) : 0,
      avatarId: isSet(object.avatarId) ? globalThis.String(object.avatarId) : "",
      sid: isSet(object.sid) ? globalThis.Number(object.sid) : 0,
      order: isSet(object.order) ? globalThis.Number(object.order) : 0,
      cardStatus: isSet(object.cardStatus) ? cardStatusFromJSON(object.cardStatus) : 0,
    };
  },

  toJSON(message: Player): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.userName !== "") {
      obj.userName = message.userName;
    }
    if (message.wallet !== "") {
      obj.wallet = message.wallet;
    }
    if (message.isPlaying !== false) {
      obj.isPlaying = message.isPlaying;
    }
    if (message.vipLevel !== 0) {
      obj.vipLevel = Math.round(message.vipLevel);
    }
    if (message.avatarId !== "") {
      obj.avatarId = message.avatarId;
    }
    if (message.sid !== 0) {
      obj.sid = Math.round(message.sid);
    }
    if (message.order !== 0) {
      obj.order = Math.round(message.order);
    }
    if (message.cardStatus !== 0) {
      obj.cardStatus = cardStatusToJSON(message.cardStatus);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Player>, I>>(base?: I): Player {
    return Player.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Player>, I>>(object: I): Player {
    const message = createBasePlayer();
    message.id = object.id ?? "";
    message.userName = object.userName ?? "";
    message.wallet = object.wallet ?? "";
    message.isPlaying = object.isPlaying ?? false;
    message.vipLevel = object.vipLevel ?? 0;
    message.avatarId = object.avatarId ?? "";
    message.sid = object.sid ?? 0;
    message.order = object.order ?? 0;
    message.cardStatus = object.cardStatus ?? 0;
    return message;
  },
};

function createBaseJackpot(): Jackpot {
  return { id: 0, userId: "", gameCode: "", chips: 0, createTimeUnix: 0 };
}

export const Jackpot = {
  encode(message: Jackpot, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).int64(message.id);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.gameCode !== "") {
      writer.uint32(26).string(message.gameCode);
    }
    if (message.chips !== 0) {
      writer.uint32(32).int64(message.chips);
    }
    if (message.createTimeUnix !== 0) {
      writer.uint32(40).int64(message.createTimeUnix);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Jackpot {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJackpot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.gameCode = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.chips = longToNumber(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.createTimeUnix = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Jackpot {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      gameCode: isSet(object.gameCode) ? globalThis.String(object.gameCode) : "",
      chips: isSet(object.chips) ? globalThis.Number(object.chips) : 0,
      createTimeUnix: isSet(object.createTimeUnix) ? globalThis.Number(object.createTimeUnix) : 0,
    };
  },

  toJSON(message: Jackpot): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.gameCode !== "") {
      obj.gameCode = message.gameCode;
    }
    if (message.chips !== 0) {
      obj.chips = Math.round(message.chips);
    }
    if (message.createTimeUnix !== 0) {
      obj.createTimeUnix = Math.round(message.createTimeUnix);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Jackpot>, I>>(base?: I): Jackpot {
    return Jackpot.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Jackpot>, I>>(object: I): Jackpot {
    const message = createBaseJackpot();
    message.id = object.id ?? 0;
    message.userId = object.userId ?? "";
    message.gameCode = object.gameCode ?? "";
    message.chips = object.chips ?? 0;
    message.createTimeUnix = object.createTimeUnix ?? 0;
    return message;
  },
};

function createBaseBalanceUpdate(): BalanceUpdate {
  return {
    userId: "",
    amountChipBefore: 0,
    amountChipCurrent: 0,
    amountChipAdd: 0,
    amoutChipBet: 0,
    amoutChipFee: 0,
    amoutChipAddPrefee: 0,
    totalChipInMatch: 0,
  };
}

export const BalanceUpdate = {
  encode(message: BalanceUpdate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.amountChipBefore !== 0) {
      writer.uint32(16).int64(message.amountChipBefore);
    }
    if (message.amountChipCurrent !== 0) {
      writer.uint32(24).int64(message.amountChipCurrent);
    }
    if (message.amountChipAdd !== 0) {
      writer.uint32(32).int64(message.amountChipAdd);
    }
    if (message.amoutChipBet !== 0) {
      writer.uint32(40).int64(message.amoutChipBet);
    }
    if (message.amoutChipFee !== 0) {
      writer.uint32(48).int64(message.amoutChipFee);
    }
    if (message.amoutChipAddPrefee !== 0) {
      writer.uint32(56).int64(message.amoutChipAddPrefee);
    }
    if (message.totalChipInMatch !== 0) {
      writer.uint32(64).int64(message.totalChipInMatch);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BalanceUpdate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBalanceUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.amountChipBefore = longToNumber(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.amountChipCurrent = longToNumber(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.amountChipAdd = longToNumber(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.amoutChipBet = longToNumber(reader.int64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.amoutChipFee = longToNumber(reader.int64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.amoutChipAddPrefee = longToNumber(reader.int64() as Long);
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.totalChipInMatch = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BalanceUpdate {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      amountChipBefore: isSet(object.amountChipBefore) ? globalThis.Number(object.amountChipBefore) : 0,
      amountChipCurrent: isSet(object.amountChipCurrent) ? globalThis.Number(object.amountChipCurrent) : 0,
      amountChipAdd: isSet(object.amountChipAdd) ? globalThis.Number(object.amountChipAdd) : 0,
      amoutChipBet: isSet(object.amoutChipBet) ? globalThis.Number(object.amoutChipBet) : 0,
      amoutChipFee: isSet(object.amoutChipFee) ? globalThis.Number(object.amoutChipFee) : 0,
      amoutChipAddPrefee: isSet(object.amoutChipAddPrefee) ? globalThis.Number(object.amoutChipAddPrefee) : 0,
      totalChipInMatch: isSet(object.totalChipInMatch) ? globalThis.Number(object.totalChipInMatch) : 0,
    };
  },

  toJSON(message: BalanceUpdate): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.amountChipBefore !== 0) {
      obj.amountChipBefore = Math.round(message.amountChipBefore);
    }
    if (message.amountChipCurrent !== 0) {
      obj.amountChipCurrent = Math.round(message.amountChipCurrent);
    }
    if (message.amountChipAdd !== 0) {
      obj.amountChipAdd = Math.round(message.amountChipAdd);
    }
    if (message.amoutChipBet !== 0) {
      obj.amoutChipBet = Math.round(message.amoutChipBet);
    }
    if (message.amoutChipFee !== 0) {
      obj.amoutChipFee = Math.round(message.amoutChipFee);
    }
    if (message.amoutChipAddPrefee !== 0) {
      obj.amoutChipAddPrefee = Math.round(message.amoutChipAddPrefee);
    }
    if (message.totalChipInMatch !== 0) {
      obj.totalChipInMatch = Math.round(message.totalChipInMatch);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BalanceUpdate>, I>>(base?: I): BalanceUpdate {
    return BalanceUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BalanceUpdate>, I>>(object: I): BalanceUpdate {
    const message = createBaseBalanceUpdate();
    message.userId = object.userId ?? "";
    message.amountChipBefore = object.amountChipBefore ?? 0;
    message.amountChipCurrent = object.amountChipCurrent ?? 0;
    message.amountChipAdd = object.amountChipAdd ?? 0;
    message.amoutChipBet = object.amoutChipBet ?? 0;
    message.amoutChipFee = object.amoutChipFee ?? 0;
    message.amoutChipAddPrefee = object.amoutChipAddPrefee ?? 0;
    message.totalChipInMatch = object.totalChipInMatch ?? 0;
    return message;
  },
};

function createBaseBalanceResult(): BalanceResult {
  return { updates: [], jackpot: undefined };
}

export const BalanceResult = {
  encode(message: BalanceResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.updates) {
      BalanceUpdate.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.jackpot !== undefined) {
      Jackpot.encode(message.jackpot, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BalanceResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBalanceResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updates.push(BalanceUpdate.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.jackpot = Jackpot.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BalanceResult {
    return {
      updates: globalThis.Array.isArray(object?.updates)
        ? object.updates.map((e: any) => BalanceUpdate.fromJSON(e))
        : [],
      jackpot: isSet(object.jackpot) ? Jackpot.fromJSON(object.jackpot) : undefined,
    };
  },

  toJSON(message: BalanceResult): unknown {
    const obj: any = {};
    if (message.updates?.length) {
      obj.updates = message.updates.map((e) => BalanceUpdate.toJSON(e));
    }
    if (message.jackpot !== undefined) {
      obj.jackpot = Jackpot.toJSON(message.jackpot);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BalanceResult>, I>>(base?: I): BalanceResult {
    return BalanceResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BalanceResult>, I>>(object: I): BalanceResult {
    const message = createBaseBalanceResult();
    message.updates = object.updates?.map((e) => BalanceUpdate.fromPartial(e)) || [];
    message.jackpot = (object.jackpot !== undefined && object.jackpot !== null)
      ? Jackpot.fromPartial(object.jackpot)
      : undefined;
    return message;
  },
};

function createBaseHitJackpotHistory(): HitJackpotHistory {
  return { userName: "", chips: 0, createTimeUnix: 0 };
}

export const HitJackpotHistory = {
  encode(message: HitJackpotHistory, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userName !== "") {
      writer.uint32(10).string(message.userName);
    }
    if (message.chips !== 0) {
      writer.uint32(16).int64(message.chips);
    }
    if (message.createTimeUnix !== 0) {
      writer.uint32(24).int64(message.createTimeUnix);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HitJackpotHistory {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHitJackpotHistory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.chips = longToNumber(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.createTimeUnix = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HitJackpotHistory {
    return {
      userName: isSet(object.userName) ? globalThis.String(object.userName) : "",
      chips: isSet(object.chips) ? globalThis.Number(object.chips) : 0,
      createTimeUnix: isSet(object.createTimeUnix) ? globalThis.Number(object.createTimeUnix) : 0,
    };
  },

  toJSON(message: HitJackpotHistory): unknown {
    const obj: any = {};
    if (message.userName !== "") {
      obj.userName = message.userName;
    }
    if (message.chips !== 0) {
      obj.chips = Math.round(message.chips);
    }
    if (message.createTimeUnix !== 0) {
      obj.createTimeUnix = Math.round(message.createTimeUnix);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HitJackpotHistory>, I>>(base?: I): HitJackpotHistory {
    return HitJackpotHistory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HitJackpotHistory>, I>>(object: I): HitJackpotHistory {
    const message = createBaseHitJackpotHistory();
    message.userName = object.userName ?? "";
    message.chips = object.chips ?? 0;
    message.createTimeUnix = object.createTimeUnix ?? 0;
    return message;
  },
};

function createBaseUpdateTable(): UpdateTable {
  return {
    players: [],
    playingPlayers: [],
    joinPlayers: [],
    leavePlayers: [],
    bet: 0,
    vip: 0,
    timePlay: 0,
    remainTime: 0,
    gameState: 0,
    jpTreasure: undefined,
  };
}

export const UpdateTable = {
  encode(message: UpdateTable, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.players) {
      Player.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.playingPlayers) {
      Player.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.joinPlayers) {
      Player.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.leavePlayers) {
      Player.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message.bet !== 0) {
      writer.uint32(40).int64(message.bet);
    }
    if (message.vip !== 0) {
      writer.uint32(48).int64(message.vip);
    }
    if (message.timePlay !== 0) {
      writer.uint32(56).int64(message.timePlay);
    }
    if (message.remainTime !== 0) {
      writer.uint32(64).int64(message.remainTime);
    }
    if (message.gameState !== 0) {
      writer.uint32(72).int32(message.gameState);
    }
    if (message.jpTreasure !== undefined) {
      Jackpot.encode(message.jpTreasure, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateTable {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateTable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.players.push(Player.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.playingPlayers.push(Player.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.joinPlayers.push(Player.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.leavePlayers.push(Player.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.bet = longToNumber(reader.int64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.vip = longToNumber(reader.int64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.timePlay = longToNumber(reader.int64() as Long);
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.remainTime = longToNumber(reader.int64() as Long);
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.gameState = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.jpTreasure = Jackpot.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateTable {
    return {
      players: globalThis.Array.isArray(object?.players) ? object.players.map((e: any) => Player.fromJSON(e)) : [],
      playingPlayers: globalThis.Array.isArray(object?.playingPlayers)
        ? object.playingPlayers.map((e: any) => Player.fromJSON(e))
        : [],
      joinPlayers: globalThis.Array.isArray(object?.joinPlayers)
        ? object.joinPlayers.map((e: any) => Player.fromJSON(e))
        : [],
      leavePlayers: globalThis.Array.isArray(object?.leavePlayers)
        ? object.leavePlayers.map((e: any) => Player.fromJSON(e))
        : [],
      bet: isSet(object.bet) ? globalThis.Number(object.bet) : 0,
      vip: isSet(object.vip) ? globalThis.Number(object.vip) : 0,
      timePlay: isSet(object.timePlay) ? globalThis.Number(object.timePlay) : 0,
      remainTime: isSet(object.remainTime) ? globalThis.Number(object.remainTime) : 0,
      gameState: isSet(object.gameState) ? gameStateFromJSON(object.gameState) : 0,
      jpTreasure: isSet(object.jpTreasure) ? Jackpot.fromJSON(object.jpTreasure) : undefined,
    };
  },

  toJSON(message: UpdateTable): unknown {
    const obj: any = {};
    if (message.players?.length) {
      obj.players = message.players.map((e) => Player.toJSON(e));
    }
    if (message.playingPlayers?.length) {
      obj.playingPlayers = message.playingPlayers.map((e) => Player.toJSON(e));
    }
    if (message.joinPlayers?.length) {
      obj.joinPlayers = message.joinPlayers.map((e) => Player.toJSON(e));
    }
    if (message.leavePlayers?.length) {
      obj.leavePlayers = message.leavePlayers.map((e) => Player.toJSON(e));
    }
    if (message.bet !== 0) {
      obj.bet = Math.round(message.bet);
    }
    if (message.vip !== 0) {
      obj.vip = Math.round(message.vip);
    }
    if (message.timePlay !== 0) {
      obj.timePlay = Math.round(message.timePlay);
    }
    if (message.remainTime !== 0) {
      obj.remainTime = Math.round(message.remainTime);
    }
    if (message.gameState !== 0) {
      obj.gameState = gameStateToJSON(message.gameState);
    }
    if (message.jpTreasure !== undefined) {
      obj.jpTreasure = Jackpot.toJSON(message.jpTreasure);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateTable>, I>>(base?: I): UpdateTable {
    return UpdateTable.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateTable>, I>>(object: I): UpdateTable {
    const message = createBaseUpdateTable();
    message.players = object.players?.map((e) => Player.fromPartial(e)) || [];
    message.playingPlayers = object.playingPlayers?.map((e) => Player.fromPartial(e)) || [];
    message.joinPlayers = object.joinPlayers?.map((e) => Player.fromPartial(e)) || [];
    message.leavePlayers = object.leavePlayers?.map((e) => Player.fromPartial(e)) || [];
    message.bet = object.bet ?? 0;
    message.vip = object.vip ?? 0;
    message.timePlay = object.timePlay ?? 0;
    message.remainTime = object.remainTime ?? 0;
    message.gameState = object.gameState ?? 0;
    message.jpTreasure = (object.jpTreasure !== undefined && object.jpTreasure !== null)
      ? Jackpot.fromPartial(object.jpTreasure)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
