// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v3.21.12
// source: proto/lottery.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "proto";

/** Lottery ticket status */
export enum LotteryTicketStatus {
  LOTTERY_TICKET_STATUS_WAITING = 0,
  LOTTERY_TICKET_STATUS_WIN = 1,
  LOTTERY_TICKET_STATUS_LOSE = 2,
  UNRECOGNIZED = -1,
}

export function lotteryTicketStatusFromJSON(object: any): LotteryTicketStatus {
  switch (object) {
    case 0:
    case "LOTTERY_TICKET_STATUS_WAITING":
      return LotteryTicketStatus.LOTTERY_TICKET_STATUS_WAITING;
    case 1:
    case "LOTTERY_TICKET_STATUS_WIN":
      return LotteryTicketStatus.LOTTERY_TICKET_STATUS_WIN;
    case 2:
    case "LOTTERY_TICKET_STATUS_LOSE":
      return LotteryTicketStatus.LOTTERY_TICKET_STATUS_LOSE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LotteryTicketStatus.UNRECOGNIZED;
  }
}

export function lotteryTicketStatusToJSON(object: LotteryTicketStatus): string {
  switch (object) {
    case LotteryTicketStatus.LOTTERY_TICKET_STATUS_WAITING:
      return "LOTTERY_TICKET_STATUS_WAITING";
    case LotteryTicketStatus.LOTTERY_TICKET_STATUS_WIN:
      return "LOTTERY_TICKET_STATUS_WIN";
    case LotteryTicketStatus.LOTTERY_TICKET_STATUS_LOSE:
      return "LOTTERY_TICKET_STATUS_LOSE";
    case LotteryTicketStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Lottery draw status */
export enum LotteryDrawStatus {
  LOTTERY_DRAW_STATUS_UPCOMING = 0,
  LOTTERY_DRAW_STATUS_CLOSED = 1,
  LOTTERY_DRAW_STATUS_DRAWN = 2,
  UNRECOGNIZED = -1,
}

export function lotteryDrawStatusFromJSON(object: any): LotteryDrawStatus {
  switch (object) {
    case 0:
    case "LOTTERY_DRAW_STATUS_UPCOMING":
      return LotteryDrawStatus.LOTTERY_DRAW_STATUS_UPCOMING;
    case 1:
    case "LOTTERY_DRAW_STATUS_CLOSED":
      return LotteryDrawStatus.LOTTERY_DRAW_STATUS_CLOSED;
    case 2:
    case "LOTTERY_DRAW_STATUS_DRAWN":
      return LotteryDrawStatus.LOTTERY_DRAW_STATUS_DRAWN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LotteryDrawStatus.UNRECOGNIZED;
  }
}

export function lotteryDrawStatusToJSON(object: LotteryDrawStatus): string {
  switch (object) {
    case LotteryDrawStatus.LOTTERY_DRAW_STATUS_UPCOMING:
      return "LOTTERY_DRAW_STATUS_UPCOMING";
    case LotteryDrawStatus.LOTTERY_DRAW_STATUS_CLOSED:
      return "LOTTERY_DRAW_STATUS_CLOSED";
    case LotteryDrawStatus.LOTTERY_DRAW_STATUS_DRAWN:
      return "LOTTERY_DRAW_STATUS_DRAWN";
    case LotteryDrawStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Request to buy lottery ticket */
export interface BuyLotteryTicketRequest {
  /** 6 numbers from 1-49 */
  numbers: number[];
  /** Which draw session to participate */
  drawId: number;
}

/** Response after buying ticket */
export interface BuyLotteryTicketResponse {
  ticket:
    | LotteryTicket
    | undefined;
  /** Updated user profile with new balance */
  profile: Profile | undefined;
}

/** Request to buy multiple tickets */
export interface BuyMultipleLotteryTicketsRequest {
  tickets: LotteryTicketInput[];
}

export interface LotteryTicketInput {
  /** 6 numbers from 1-49 */
  numbers: number[];
  drawId: number;
}

/** Response for multiple tickets */
export interface BuyMultipleLotteryTicketsResponse {
  tickets: LotteryTicket[];
  profile: Profile | undefined;
}

/** Lottery ticket data */
export interface LotteryTicket {
  id: number;
  userId: string;
  userName: string;
  /** 6 numbers chosen */
  numbers: number[];
  drawId: number;
  purchasePrice: number;
  status: LotteryTicketStatus;
  /** Amount won */
  reward: number;
  /** How many numbers matched */
  matchedCount: number;
  purchaseTimeUnix: number;
  drawTimeUnix: number;
}

/** Lottery draw session */
export interface LotteryDraw {
  id: number;
  /** When the draw will happen */
  drawTimeUnix: number;
  /** When ticket sales close (30 min before draw) */
  closeTimeUnix: number;
  status: LotteryDrawStatus;
  /** The 6 winning numbers */
  winningNumbers: number[];
  /** Total prize pool for this draw */
  prizePool: number;
  totalTicketsSold: number;
  /** Total money from ticket sales */
  totalTicketSales: number;
  /** When draw actually happened */
  actualDrawTimeUnix: number;
  /** Statistics about winners */
  winnerStats: WinnerStats | undefined;
}

/** Statistics about winners in a draw */
export interface WinnerStats {
  winners6Match: number;
  winners5Match: number;
  winners4Match: number;
  winners3Match: number;
  winners2Match: number;
  /** Total prize for 6 match winners */
  prize6Match: number;
  prize5Match: number;
  prize4Match: number;
  prize3Match: number;
  /** Refund amount per ticket */
  prize2Match: number;
}

/** Request to get user's lottery history */
export interface GetLotteryHistoryRequest {
  userId: string;
  limit: number;
  offset: number;
  /** Filter by status (optional) */
  status: LotteryTicketStatus;
}

/** Response with user's lottery tickets */
export interface GetLotteryHistoryResponse {
  tickets: LotteryTicket[];
  total: number;
}

/** Request to get available draws */
export interface GetAvailableDrawsRequest {
  /** How many upcoming draws to fetch */
  limit: number;
}

/** Response with available draws */
export interface GetAvailableDrawsResponse {
  draws: LotteryDraw[];
}

/** Request to get draw results */
export interface GetDrawResultRequest {
  drawId: number;
}

/** Response with draw results */
export interface GetDrawResultResponse {
  draw: LotteryDraw | undefined;
}

/** Request to get latest draw result */
export interface GetLatestDrawResultRequest {
}

/** Response with latest draw result */
export interface GetLatestDrawResultResponse {
  draw:
    | LotteryDraw
    | undefined;
  /** User's tickets for this draw (if any) */
  userTickets: LotteryTicket[];
}

/** Request to get quick pick numbers */
export interface QuickPickRequest {
  /** How many sets of numbers to generate (default 1) */
  count: number;
}

/** Response with quick pick numbers */
export interface QuickPickResponse {
  numberSets: QuickPickNumbers[];
}

export interface QuickPickNumbers {
  /** 6 random numbers */
  numbers: number[];
}

/** Admin request to manually trigger draw */
export interface TriggerDrawRequest {
  drawId: number;
}

/** Admin response */
export interface TriggerDrawResponse {
  draw: LotteryDraw | undefined;
  message: string;
}

/** Import Profile from auth.proto for user balance updates */
export interface Profile {
  userId: string;
  userName: string;
  displayName: string;
  avatarUrl: string;
  status: string;
  accountChip: number;
  bankChip: number;
  refCode: string;
  langTag: string;
  linkGroup: string;
  linkFanpageFb: string;
  appConfig: string;
  avatarId: string;
  registrable: boolean;
  vipLevel: number;
  lastOnlineTimeUnix: number;
  createTimeUnix: number;
  remainTimeInputRefCode: number;
  userSid: number;
}

function createBaseBuyLotteryTicketRequest(): BuyLotteryTicketRequest {
  return { numbers: [], drawId: 0 };
}

export const BuyLotteryTicketRequest: MessageFns<BuyLotteryTicketRequest> = {
  encode(message: BuyLotteryTicketRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.numbers) {
      writer.int32(v);
    }
    writer.join();
    if (message.drawId !== 0) {
      writer.uint32(16).int64(message.drawId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuyLotteryTicketRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuyLotteryTicketRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.numbers.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.numbers.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.drawId = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuyLotteryTicketRequest {
    return {
      numbers: globalThis.Array.isArray(object?.numbers) ? object.numbers.map((e: any) => globalThis.Number(e)) : [],
      drawId: isSet(object.drawId) ? globalThis.Number(object.drawId) : 0,
    };
  },

  toJSON(message: BuyLotteryTicketRequest): unknown {
    const obj: any = {};
    if (message.numbers?.length) {
      obj.numbers = message.numbers.map((e) => Math.round(e));
    }
    if (message.drawId !== 0) {
      obj.drawId = Math.round(message.drawId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuyLotteryTicketRequest>, I>>(base?: I): BuyLotteryTicketRequest {
    return BuyLotteryTicketRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuyLotteryTicketRequest>, I>>(object: I): BuyLotteryTicketRequest {
    const message = createBaseBuyLotteryTicketRequest();
    message.numbers = object.numbers?.map((e) => e) || [];
    message.drawId = object.drawId ?? 0;
    return message;
  },
};

function createBaseBuyLotteryTicketResponse(): BuyLotteryTicketResponse {
  return { ticket: undefined, profile: undefined };
}

export const BuyLotteryTicketResponse: MessageFns<BuyLotteryTicketResponse> = {
  encode(message: BuyLotteryTicketResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ticket !== undefined) {
      LotteryTicket.encode(message.ticket, writer.uint32(10).fork()).join();
    }
    if (message.profile !== undefined) {
      Profile.encode(message.profile, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuyLotteryTicketResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuyLotteryTicketResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ticket = LotteryTicket.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.profile = Profile.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuyLotteryTicketResponse {
    return {
      ticket: isSet(object.ticket) ? LotteryTicket.fromJSON(object.ticket) : undefined,
      profile: isSet(object.profile) ? Profile.fromJSON(object.profile) : undefined,
    };
  },

  toJSON(message: BuyLotteryTicketResponse): unknown {
    const obj: any = {};
    if (message.ticket !== undefined) {
      obj.ticket = LotteryTicket.toJSON(message.ticket);
    }
    if (message.profile !== undefined) {
      obj.profile = Profile.toJSON(message.profile);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuyLotteryTicketResponse>, I>>(base?: I): BuyLotteryTicketResponse {
    return BuyLotteryTicketResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuyLotteryTicketResponse>, I>>(object: I): BuyLotteryTicketResponse {
    const message = createBaseBuyLotteryTicketResponse();
    message.ticket = (object.ticket !== undefined && object.ticket !== null)
      ? LotteryTicket.fromPartial(object.ticket)
      : undefined;
    message.profile = (object.profile !== undefined && object.profile !== null)
      ? Profile.fromPartial(object.profile)
      : undefined;
    return message;
  },
};

function createBaseBuyMultipleLotteryTicketsRequest(): BuyMultipleLotteryTicketsRequest {
  return { tickets: [] };
}

export const BuyMultipleLotteryTicketsRequest: MessageFns<BuyMultipleLotteryTicketsRequest> = {
  encode(message: BuyMultipleLotteryTicketsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tickets) {
      LotteryTicketInput.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuyMultipleLotteryTicketsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuyMultipleLotteryTicketsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tickets.push(LotteryTicketInput.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuyMultipleLotteryTicketsRequest {
    return {
      tickets: globalThis.Array.isArray(object?.tickets)
        ? object.tickets.map((e: any) => LotteryTicketInput.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BuyMultipleLotteryTicketsRequest): unknown {
    const obj: any = {};
    if (message.tickets?.length) {
      obj.tickets = message.tickets.map((e) => LotteryTicketInput.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuyMultipleLotteryTicketsRequest>, I>>(
    base?: I,
  ): BuyMultipleLotteryTicketsRequest {
    return BuyMultipleLotteryTicketsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuyMultipleLotteryTicketsRequest>, I>>(
    object: I,
  ): BuyMultipleLotteryTicketsRequest {
    const message = createBaseBuyMultipleLotteryTicketsRequest();
    message.tickets = object.tickets?.map((e) => LotteryTicketInput.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLotteryTicketInput(): LotteryTicketInput {
  return { numbers: [], drawId: 0 };
}

export const LotteryTicketInput: MessageFns<LotteryTicketInput> = {
  encode(message: LotteryTicketInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.numbers) {
      writer.int32(v);
    }
    writer.join();
    if (message.drawId !== 0) {
      writer.uint32(16).int64(message.drawId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LotteryTicketInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLotteryTicketInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.numbers.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.numbers.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.drawId = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LotteryTicketInput {
    return {
      numbers: globalThis.Array.isArray(object?.numbers) ? object.numbers.map((e: any) => globalThis.Number(e)) : [],
      drawId: isSet(object.drawId) ? globalThis.Number(object.drawId) : 0,
    };
  },

  toJSON(message: LotteryTicketInput): unknown {
    const obj: any = {};
    if (message.numbers?.length) {
      obj.numbers = message.numbers.map((e) => Math.round(e));
    }
    if (message.drawId !== 0) {
      obj.drawId = Math.round(message.drawId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LotteryTicketInput>, I>>(base?: I): LotteryTicketInput {
    return LotteryTicketInput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LotteryTicketInput>, I>>(object: I): LotteryTicketInput {
    const message = createBaseLotteryTicketInput();
    message.numbers = object.numbers?.map((e) => e) || [];
    message.drawId = object.drawId ?? 0;
    return message;
  },
};

function createBaseBuyMultipleLotteryTicketsResponse(): BuyMultipleLotteryTicketsResponse {
  return { tickets: [], profile: undefined };
}

export const BuyMultipleLotteryTicketsResponse: MessageFns<BuyMultipleLotteryTicketsResponse> = {
  encode(message: BuyMultipleLotteryTicketsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tickets) {
      LotteryTicket.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.profile !== undefined) {
      Profile.encode(message.profile, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuyMultipleLotteryTicketsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuyMultipleLotteryTicketsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tickets.push(LotteryTicket.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.profile = Profile.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuyMultipleLotteryTicketsResponse {
    return {
      tickets: globalThis.Array.isArray(object?.tickets)
        ? object.tickets.map((e: any) => LotteryTicket.fromJSON(e))
        : [],
      profile: isSet(object.profile) ? Profile.fromJSON(object.profile) : undefined,
    };
  },

  toJSON(message: BuyMultipleLotteryTicketsResponse): unknown {
    const obj: any = {};
    if (message.tickets?.length) {
      obj.tickets = message.tickets.map((e) => LotteryTicket.toJSON(e));
    }
    if (message.profile !== undefined) {
      obj.profile = Profile.toJSON(message.profile);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuyMultipleLotteryTicketsResponse>, I>>(
    base?: I,
  ): BuyMultipleLotteryTicketsResponse {
    return BuyMultipleLotteryTicketsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuyMultipleLotteryTicketsResponse>, I>>(
    object: I,
  ): BuyMultipleLotteryTicketsResponse {
    const message = createBaseBuyMultipleLotteryTicketsResponse();
    message.tickets = object.tickets?.map((e) => LotteryTicket.fromPartial(e)) || [];
    message.profile = (object.profile !== undefined && object.profile !== null)
      ? Profile.fromPartial(object.profile)
      : undefined;
    return message;
  },
};

function createBaseLotteryTicket(): LotteryTicket {
  return {
    id: 0,
    userId: "",
    userName: "",
    numbers: [],
    drawId: 0,
    purchasePrice: 0,
    status: 0,
    reward: 0,
    matchedCount: 0,
    purchaseTimeUnix: 0,
    drawTimeUnix: 0,
  };
}

export const LotteryTicket: MessageFns<LotteryTicket> = {
  encode(message: LotteryTicket, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int64(message.id);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.userName !== "") {
      writer.uint32(26).string(message.userName);
    }
    writer.uint32(34).fork();
    for (const v of message.numbers) {
      writer.int32(v);
    }
    writer.join();
    if (message.drawId !== 0) {
      writer.uint32(40).int64(message.drawId);
    }
    if (message.purchasePrice !== 0) {
      writer.uint32(48).int64(message.purchasePrice);
    }
    if (message.status !== 0) {
      writer.uint32(56).int32(message.status);
    }
    if (message.reward !== 0) {
      writer.uint32(64).int64(message.reward);
    }
    if (message.matchedCount !== 0) {
      writer.uint32(72).int32(message.matchedCount);
    }
    if (message.purchaseTimeUnix !== 0) {
      writer.uint32(80).int64(message.purchaseTimeUnix);
    }
    if (message.drawTimeUnix !== 0) {
      writer.uint32(88).int64(message.drawTimeUnix);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LotteryTicket {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLotteryTicket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userName = reader.string();
          continue;
        }
        case 4: {
          if (tag === 32) {
            message.numbers.push(reader.int32());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.numbers.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.drawId = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.purchasePrice = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.reward = longToNumber(reader.int64());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.matchedCount = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.purchaseTimeUnix = longToNumber(reader.int64());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.drawTimeUnix = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LotteryTicket {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      userName: isSet(object.userName) ? globalThis.String(object.userName) : "",
      numbers: globalThis.Array.isArray(object?.numbers) ? object.numbers.map((e: any) => globalThis.Number(e)) : [],
      drawId: isSet(object.drawId) ? globalThis.Number(object.drawId) : 0,
      purchasePrice: isSet(object.purchasePrice) ? globalThis.Number(object.purchasePrice) : 0,
      status: isSet(object.status) ? lotteryTicketStatusFromJSON(object.status) : 0,
      reward: isSet(object.reward) ? globalThis.Number(object.reward) : 0,
      matchedCount: isSet(object.matchedCount) ? globalThis.Number(object.matchedCount) : 0,
      purchaseTimeUnix: isSet(object.purchaseTimeUnix) ? globalThis.Number(object.purchaseTimeUnix) : 0,
      drawTimeUnix: isSet(object.drawTimeUnix) ? globalThis.Number(object.drawTimeUnix) : 0,
    };
  },

  toJSON(message: LotteryTicket): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.userName !== "") {
      obj.userName = message.userName;
    }
    if (message.numbers?.length) {
      obj.numbers = message.numbers.map((e) => Math.round(e));
    }
    if (message.drawId !== 0) {
      obj.drawId = Math.round(message.drawId);
    }
    if (message.purchasePrice !== 0) {
      obj.purchasePrice = Math.round(message.purchasePrice);
    }
    if (message.status !== 0) {
      obj.status = lotteryTicketStatusToJSON(message.status);
    }
    if (message.reward !== 0) {
      obj.reward = Math.round(message.reward);
    }
    if (message.matchedCount !== 0) {
      obj.matchedCount = Math.round(message.matchedCount);
    }
    if (message.purchaseTimeUnix !== 0) {
      obj.purchaseTimeUnix = Math.round(message.purchaseTimeUnix);
    }
    if (message.drawTimeUnix !== 0) {
      obj.drawTimeUnix = Math.round(message.drawTimeUnix);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LotteryTicket>, I>>(base?: I): LotteryTicket {
    return LotteryTicket.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LotteryTicket>, I>>(object: I): LotteryTicket {
    const message = createBaseLotteryTicket();
    message.id = object.id ?? 0;
    message.userId = object.userId ?? "";
    message.userName = object.userName ?? "";
    message.numbers = object.numbers?.map((e) => e) || [];
    message.drawId = object.drawId ?? 0;
    message.purchasePrice = object.purchasePrice ?? 0;
    message.status = object.status ?? 0;
    message.reward = object.reward ?? 0;
    message.matchedCount = object.matchedCount ?? 0;
    message.purchaseTimeUnix = object.purchaseTimeUnix ?? 0;
    message.drawTimeUnix = object.drawTimeUnix ?? 0;
    return message;
  },
};

function createBaseLotteryDraw(): LotteryDraw {
  return {
    id: 0,
    drawTimeUnix: 0,
    closeTimeUnix: 0,
    status: 0,
    winningNumbers: [],
    prizePool: 0,
    totalTicketsSold: 0,
    totalTicketSales: 0,
    actualDrawTimeUnix: 0,
    winnerStats: undefined,
  };
}

export const LotteryDraw: MessageFns<LotteryDraw> = {
  encode(message: LotteryDraw, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int64(message.id);
    }
    if (message.drawTimeUnix !== 0) {
      writer.uint32(16).int64(message.drawTimeUnix);
    }
    if (message.closeTimeUnix !== 0) {
      writer.uint32(24).int64(message.closeTimeUnix);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    writer.uint32(42).fork();
    for (const v of message.winningNumbers) {
      writer.int32(v);
    }
    writer.join();
    if (message.prizePool !== 0) {
      writer.uint32(48).int64(message.prizePool);
    }
    if (message.totalTicketsSold !== 0) {
      writer.uint32(56).int64(message.totalTicketsSold);
    }
    if (message.totalTicketSales !== 0) {
      writer.uint32(64).int64(message.totalTicketSales);
    }
    if (message.actualDrawTimeUnix !== 0) {
      writer.uint32(72).int64(message.actualDrawTimeUnix);
    }
    if (message.winnerStats !== undefined) {
      WinnerStats.encode(message.winnerStats, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LotteryDraw {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLotteryDraw();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.drawTimeUnix = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.closeTimeUnix = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag === 40) {
            message.winningNumbers.push(reader.int32());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.winningNumbers.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.prizePool = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.totalTicketsSold = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.totalTicketSales = longToNumber(reader.int64());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.actualDrawTimeUnix = longToNumber(reader.int64());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.winnerStats = WinnerStats.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LotteryDraw {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      drawTimeUnix: isSet(object.drawTimeUnix) ? globalThis.Number(object.drawTimeUnix) : 0,
      closeTimeUnix: isSet(object.closeTimeUnix) ? globalThis.Number(object.closeTimeUnix) : 0,
      status: isSet(object.status) ? lotteryDrawStatusFromJSON(object.status) : 0,
      winningNumbers: globalThis.Array.isArray(object?.winningNumbers)
        ? object.winningNumbers.map((e: any) => globalThis.Number(e))
        : [],
      prizePool: isSet(object.prizePool) ? globalThis.Number(object.prizePool) : 0,
      totalTicketsSold: isSet(object.totalTicketsSold) ? globalThis.Number(object.totalTicketsSold) : 0,
      totalTicketSales: isSet(object.totalTicketSales) ? globalThis.Number(object.totalTicketSales) : 0,
      actualDrawTimeUnix: isSet(object.actualDrawTimeUnix) ? globalThis.Number(object.actualDrawTimeUnix) : 0,
      winnerStats: isSet(object.winnerStats) ? WinnerStats.fromJSON(object.winnerStats) : undefined,
    };
  },

  toJSON(message: LotteryDraw): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.drawTimeUnix !== 0) {
      obj.drawTimeUnix = Math.round(message.drawTimeUnix);
    }
    if (message.closeTimeUnix !== 0) {
      obj.closeTimeUnix = Math.round(message.closeTimeUnix);
    }
    if (message.status !== 0) {
      obj.status = lotteryDrawStatusToJSON(message.status);
    }
    if (message.winningNumbers?.length) {
      obj.winningNumbers = message.winningNumbers.map((e) => Math.round(e));
    }
    if (message.prizePool !== 0) {
      obj.prizePool = Math.round(message.prizePool);
    }
    if (message.totalTicketsSold !== 0) {
      obj.totalTicketsSold = Math.round(message.totalTicketsSold);
    }
    if (message.totalTicketSales !== 0) {
      obj.totalTicketSales = Math.round(message.totalTicketSales);
    }
    if (message.actualDrawTimeUnix !== 0) {
      obj.actualDrawTimeUnix = Math.round(message.actualDrawTimeUnix);
    }
    if (message.winnerStats !== undefined) {
      obj.winnerStats = WinnerStats.toJSON(message.winnerStats);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LotteryDraw>, I>>(base?: I): LotteryDraw {
    return LotteryDraw.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LotteryDraw>, I>>(object: I): LotteryDraw {
    const message = createBaseLotteryDraw();
    message.id = object.id ?? 0;
    message.drawTimeUnix = object.drawTimeUnix ?? 0;
    message.closeTimeUnix = object.closeTimeUnix ?? 0;
    message.status = object.status ?? 0;
    message.winningNumbers = object.winningNumbers?.map((e) => e) || [];
    message.prizePool = object.prizePool ?? 0;
    message.totalTicketsSold = object.totalTicketsSold ?? 0;
    message.totalTicketSales = object.totalTicketSales ?? 0;
    message.actualDrawTimeUnix = object.actualDrawTimeUnix ?? 0;
    message.winnerStats = (object.winnerStats !== undefined && object.winnerStats !== null)
      ? WinnerStats.fromPartial(object.winnerStats)
      : undefined;
    return message;
  },
};

function createBaseWinnerStats(): WinnerStats {
  return {
    winners6Match: 0,
    winners5Match: 0,
    winners4Match: 0,
    winners3Match: 0,
    winners2Match: 0,
    prize6Match: 0,
    prize5Match: 0,
    prize4Match: 0,
    prize3Match: 0,
    prize2Match: 0,
  };
}

export const WinnerStats: MessageFns<WinnerStats> = {
  encode(message: WinnerStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.winners6Match !== 0) {
      writer.uint32(8).int32(message.winners6Match);
    }
    if (message.winners5Match !== 0) {
      writer.uint32(16).int32(message.winners5Match);
    }
    if (message.winners4Match !== 0) {
      writer.uint32(24).int32(message.winners4Match);
    }
    if (message.winners3Match !== 0) {
      writer.uint32(32).int32(message.winners3Match);
    }
    if (message.winners2Match !== 0) {
      writer.uint32(40).int32(message.winners2Match);
    }
    if (message.prize6Match !== 0) {
      writer.uint32(48).int64(message.prize6Match);
    }
    if (message.prize5Match !== 0) {
      writer.uint32(56).int64(message.prize5Match);
    }
    if (message.prize4Match !== 0) {
      writer.uint32(64).int64(message.prize4Match);
    }
    if (message.prize3Match !== 0) {
      writer.uint32(72).int64(message.prize3Match);
    }
    if (message.prize2Match !== 0) {
      writer.uint32(80).int64(message.prize2Match);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WinnerStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWinnerStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.winners6Match = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.winners5Match = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.winners4Match = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.winners3Match = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.winners2Match = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.prize6Match = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.prize5Match = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.prize4Match = longToNumber(reader.int64());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.prize3Match = longToNumber(reader.int64());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.prize2Match = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WinnerStats {
    return {
      winners6Match: isSet(object.winners6Match) ? globalThis.Number(object.winners6Match) : 0,
      winners5Match: isSet(object.winners5Match) ? globalThis.Number(object.winners5Match) : 0,
      winners4Match: isSet(object.winners4Match) ? globalThis.Number(object.winners4Match) : 0,
      winners3Match: isSet(object.winners3Match) ? globalThis.Number(object.winners3Match) : 0,
      winners2Match: isSet(object.winners2Match) ? globalThis.Number(object.winners2Match) : 0,
      prize6Match: isSet(object.prize6Match) ? globalThis.Number(object.prize6Match) : 0,
      prize5Match: isSet(object.prize5Match) ? globalThis.Number(object.prize5Match) : 0,
      prize4Match: isSet(object.prize4Match) ? globalThis.Number(object.prize4Match) : 0,
      prize3Match: isSet(object.prize3Match) ? globalThis.Number(object.prize3Match) : 0,
      prize2Match: isSet(object.prize2Match) ? globalThis.Number(object.prize2Match) : 0,
    };
  },

  toJSON(message: WinnerStats): unknown {
    const obj: any = {};
    if (message.winners6Match !== 0) {
      obj.winners6Match = Math.round(message.winners6Match);
    }
    if (message.winners5Match !== 0) {
      obj.winners5Match = Math.round(message.winners5Match);
    }
    if (message.winners4Match !== 0) {
      obj.winners4Match = Math.round(message.winners4Match);
    }
    if (message.winners3Match !== 0) {
      obj.winners3Match = Math.round(message.winners3Match);
    }
    if (message.winners2Match !== 0) {
      obj.winners2Match = Math.round(message.winners2Match);
    }
    if (message.prize6Match !== 0) {
      obj.prize6Match = Math.round(message.prize6Match);
    }
    if (message.prize5Match !== 0) {
      obj.prize5Match = Math.round(message.prize5Match);
    }
    if (message.prize4Match !== 0) {
      obj.prize4Match = Math.round(message.prize4Match);
    }
    if (message.prize3Match !== 0) {
      obj.prize3Match = Math.round(message.prize3Match);
    }
    if (message.prize2Match !== 0) {
      obj.prize2Match = Math.round(message.prize2Match);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WinnerStats>, I>>(base?: I): WinnerStats {
    return WinnerStats.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WinnerStats>, I>>(object: I): WinnerStats {
    const message = createBaseWinnerStats();
    message.winners6Match = object.winners6Match ?? 0;
    message.winners5Match = object.winners5Match ?? 0;
    message.winners4Match = object.winners4Match ?? 0;
    message.winners3Match = object.winners3Match ?? 0;
    message.winners2Match = object.winners2Match ?? 0;
    message.prize6Match = object.prize6Match ?? 0;
    message.prize5Match = object.prize5Match ?? 0;
    message.prize4Match = object.prize4Match ?? 0;
    message.prize3Match = object.prize3Match ?? 0;
    message.prize2Match = object.prize2Match ?? 0;
    return message;
  },
};

function createBaseGetLotteryHistoryRequest(): GetLotteryHistoryRequest {
  return { userId: "", limit: 0, offset: 0, status: 0 };
}

export const GetLotteryHistoryRequest: MessageFns<GetLotteryHistoryRequest> = {
  encode(message: GetLotteryHistoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.limit !== 0) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.offset !== 0) {
      writer.uint32(24).int32(message.offset);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLotteryHistoryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLotteryHistoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLotteryHistoryRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      status: isSet(object.status) ? lotteryTicketStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: GetLotteryHistoryRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.status !== 0) {
      obj.status = lotteryTicketStatusToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetLotteryHistoryRequest>, I>>(base?: I): GetLotteryHistoryRequest {
    return GetLotteryHistoryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetLotteryHistoryRequest>, I>>(object: I): GetLotteryHistoryRequest {
    const message = createBaseGetLotteryHistoryRequest();
    message.userId = object.userId ?? "";
    message.limit = object.limit ?? 0;
    message.offset = object.offset ?? 0;
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseGetLotteryHistoryResponse(): GetLotteryHistoryResponse {
  return { tickets: [], total: 0 };
}

export const GetLotteryHistoryResponse: MessageFns<GetLotteryHistoryResponse> = {
  encode(message: GetLotteryHistoryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tickets) {
      LotteryTicket.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int64(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLotteryHistoryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLotteryHistoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tickets.push(LotteryTicket.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLotteryHistoryResponse {
    return {
      tickets: globalThis.Array.isArray(object?.tickets)
        ? object.tickets.map((e: any) => LotteryTicket.fromJSON(e))
        : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
    };
  },

  toJSON(message: GetLotteryHistoryResponse): unknown {
    const obj: any = {};
    if (message.tickets?.length) {
      obj.tickets = message.tickets.map((e) => LotteryTicket.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetLotteryHistoryResponse>, I>>(base?: I): GetLotteryHistoryResponse {
    return GetLotteryHistoryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetLotteryHistoryResponse>, I>>(object: I): GetLotteryHistoryResponse {
    const message = createBaseGetLotteryHistoryResponse();
    message.tickets = object.tickets?.map((e) => LotteryTicket.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    return message;
  },
};

function createBaseGetAvailableDrawsRequest(): GetAvailableDrawsRequest {
  return { limit: 0 };
}

export const GetAvailableDrawsRequest: MessageFns<GetAvailableDrawsRequest> = {
  encode(message: GetAvailableDrawsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.limit !== 0) {
      writer.uint32(8).int32(message.limit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAvailableDrawsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAvailableDrawsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAvailableDrawsRequest {
    return { limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0 };
  },

  toJSON(message: GetAvailableDrawsRequest): unknown {
    const obj: any = {};
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAvailableDrawsRequest>, I>>(base?: I): GetAvailableDrawsRequest {
    return GetAvailableDrawsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAvailableDrawsRequest>, I>>(object: I): GetAvailableDrawsRequest {
    const message = createBaseGetAvailableDrawsRequest();
    message.limit = object.limit ?? 0;
    return message;
  },
};

function createBaseGetAvailableDrawsResponse(): GetAvailableDrawsResponse {
  return { draws: [] };
}

export const GetAvailableDrawsResponse: MessageFns<GetAvailableDrawsResponse> = {
  encode(message: GetAvailableDrawsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.draws) {
      LotteryDraw.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAvailableDrawsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAvailableDrawsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.draws.push(LotteryDraw.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAvailableDrawsResponse {
    return {
      draws: globalThis.Array.isArray(object?.draws) ? object.draws.map((e: any) => LotteryDraw.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetAvailableDrawsResponse): unknown {
    const obj: any = {};
    if (message.draws?.length) {
      obj.draws = message.draws.map((e) => LotteryDraw.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAvailableDrawsResponse>, I>>(base?: I): GetAvailableDrawsResponse {
    return GetAvailableDrawsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAvailableDrawsResponse>, I>>(object: I): GetAvailableDrawsResponse {
    const message = createBaseGetAvailableDrawsResponse();
    message.draws = object.draws?.map((e) => LotteryDraw.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetDrawResultRequest(): GetDrawResultRequest {
  return { drawId: 0 };
}

export const GetDrawResultRequest: MessageFns<GetDrawResultRequest> = {
  encode(message: GetDrawResultRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.drawId !== 0) {
      writer.uint32(8).int64(message.drawId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDrawResultRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDrawResultRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.drawId = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDrawResultRequest {
    return { drawId: isSet(object.drawId) ? globalThis.Number(object.drawId) : 0 };
  },

  toJSON(message: GetDrawResultRequest): unknown {
    const obj: any = {};
    if (message.drawId !== 0) {
      obj.drawId = Math.round(message.drawId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDrawResultRequest>, I>>(base?: I): GetDrawResultRequest {
    return GetDrawResultRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDrawResultRequest>, I>>(object: I): GetDrawResultRequest {
    const message = createBaseGetDrawResultRequest();
    message.drawId = object.drawId ?? 0;
    return message;
  },
};

function createBaseGetDrawResultResponse(): GetDrawResultResponse {
  return { draw: undefined };
}

export const GetDrawResultResponse: MessageFns<GetDrawResultResponse> = {
  encode(message: GetDrawResultResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.draw !== undefined) {
      LotteryDraw.encode(message.draw, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDrawResultResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDrawResultResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.draw = LotteryDraw.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDrawResultResponse {
    return { draw: isSet(object.draw) ? LotteryDraw.fromJSON(object.draw) : undefined };
  },

  toJSON(message: GetDrawResultResponse): unknown {
    const obj: any = {};
    if (message.draw !== undefined) {
      obj.draw = LotteryDraw.toJSON(message.draw);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDrawResultResponse>, I>>(base?: I): GetDrawResultResponse {
    return GetDrawResultResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDrawResultResponse>, I>>(object: I): GetDrawResultResponse {
    const message = createBaseGetDrawResultResponse();
    message.draw = (object.draw !== undefined && object.draw !== null)
      ? LotteryDraw.fromPartial(object.draw)
      : undefined;
    return message;
  },
};

function createBaseGetLatestDrawResultRequest(): GetLatestDrawResultRequest {
  return {};
}

export const GetLatestDrawResultRequest: MessageFns<GetLatestDrawResultRequest> = {
  encode(_: GetLatestDrawResultRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLatestDrawResultRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLatestDrawResultRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetLatestDrawResultRequest {
    return {};
  },

  toJSON(_: GetLatestDrawResultRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetLatestDrawResultRequest>, I>>(base?: I): GetLatestDrawResultRequest {
    return GetLatestDrawResultRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetLatestDrawResultRequest>, I>>(_: I): GetLatestDrawResultRequest {
    const message = createBaseGetLatestDrawResultRequest();
    return message;
  },
};

function createBaseGetLatestDrawResultResponse(): GetLatestDrawResultResponse {
  return { draw: undefined, userTickets: [] };
}

export const GetLatestDrawResultResponse: MessageFns<GetLatestDrawResultResponse> = {
  encode(message: GetLatestDrawResultResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.draw !== undefined) {
      LotteryDraw.encode(message.draw, writer.uint32(10).fork()).join();
    }
    for (const v of message.userTickets) {
      LotteryTicket.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLatestDrawResultResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLatestDrawResultResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.draw = LotteryDraw.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userTickets.push(LotteryTicket.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLatestDrawResultResponse {
    return {
      draw: isSet(object.draw) ? LotteryDraw.fromJSON(object.draw) : undefined,
      userTickets: globalThis.Array.isArray(object?.userTickets)
        ? object.userTickets.map((e: any) => LotteryTicket.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetLatestDrawResultResponse): unknown {
    const obj: any = {};
    if (message.draw !== undefined) {
      obj.draw = LotteryDraw.toJSON(message.draw);
    }
    if (message.userTickets?.length) {
      obj.userTickets = message.userTickets.map((e) => LotteryTicket.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetLatestDrawResultResponse>, I>>(base?: I): GetLatestDrawResultResponse {
    return GetLatestDrawResultResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetLatestDrawResultResponse>, I>>(object: I): GetLatestDrawResultResponse {
    const message = createBaseGetLatestDrawResultResponse();
    message.draw = (object.draw !== undefined && object.draw !== null)
      ? LotteryDraw.fromPartial(object.draw)
      : undefined;
    message.userTickets = object.userTickets?.map((e) => LotteryTicket.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQuickPickRequest(): QuickPickRequest {
  return { count: 0 };
}

export const QuickPickRequest: MessageFns<QuickPickRequest> = {
  encode(message: QuickPickRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.count !== 0) {
      writer.uint32(8).int32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuickPickRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuickPickRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.count = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuickPickRequest {
    return { count: isSet(object.count) ? globalThis.Number(object.count) : 0 };
  },

  toJSON(message: QuickPickRequest): unknown {
    const obj: any = {};
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuickPickRequest>, I>>(base?: I): QuickPickRequest {
    return QuickPickRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuickPickRequest>, I>>(object: I): QuickPickRequest {
    const message = createBaseQuickPickRequest();
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseQuickPickResponse(): QuickPickResponse {
  return { numberSets: [] };
}

export const QuickPickResponse: MessageFns<QuickPickResponse> = {
  encode(message: QuickPickResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.numberSets) {
      QuickPickNumbers.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuickPickResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuickPickResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.numberSets.push(QuickPickNumbers.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuickPickResponse {
    return {
      numberSets: globalThis.Array.isArray(object?.numberSets)
        ? object.numberSets.map((e: any) => QuickPickNumbers.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QuickPickResponse): unknown {
    const obj: any = {};
    if (message.numberSets?.length) {
      obj.numberSets = message.numberSets.map((e) => QuickPickNumbers.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuickPickResponse>, I>>(base?: I): QuickPickResponse {
    return QuickPickResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuickPickResponse>, I>>(object: I): QuickPickResponse {
    const message = createBaseQuickPickResponse();
    message.numberSets = object.numberSets?.map((e) => QuickPickNumbers.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQuickPickNumbers(): QuickPickNumbers {
  return { numbers: [] };
}

export const QuickPickNumbers: MessageFns<QuickPickNumbers> = {
  encode(message: QuickPickNumbers, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.numbers) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuickPickNumbers {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuickPickNumbers();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.numbers.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.numbers.push(reader.int32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuickPickNumbers {
    return {
      numbers: globalThis.Array.isArray(object?.numbers) ? object.numbers.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: QuickPickNumbers): unknown {
    const obj: any = {};
    if (message.numbers?.length) {
      obj.numbers = message.numbers.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuickPickNumbers>, I>>(base?: I): QuickPickNumbers {
    return QuickPickNumbers.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuickPickNumbers>, I>>(object: I): QuickPickNumbers {
    const message = createBaseQuickPickNumbers();
    message.numbers = object.numbers?.map((e) => e) || [];
    return message;
  },
};

function createBaseTriggerDrawRequest(): TriggerDrawRequest {
  return { drawId: 0 };
}

export const TriggerDrawRequest: MessageFns<TriggerDrawRequest> = {
  encode(message: TriggerDrawRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.drawId !== 0) {
      writer.uint32(8).int64(message.drawId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TriggerDrawRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTriggerDrawRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.drawId = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TriggerDrawRequest {
    return { drawId: isSet(object.drawId) ? globalThis.Number(object.drawId) : 0 };
  },

  toJSON(message: TriggerDrawRequest): unknown {
    const obj: any = {};
    if (message.drawId !== 0) {
      obj.drawId = Math.round(message.drawId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TriggerDrawRequest>, I>>(base?: I): TriggerDrawRequest {
    return TriggerDrawRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TriggerDrawRequest>, I>>(object: I): TriggerDrawRequest {
    const message = createBaseTriggerDrawRequest();
    message.drawId = object.drawId ?? 0;
    return message;
  },
};

function createBaseTriggerDrawResponse(): TriggerDrawResponse {
  return { draw: undefined, message: "" };
}

export const TriggerDrawResponse: MessageFns<TriggerDrawResponse> = {
  encode(message: TriggerDrawResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.draw !== undefined) {
      LotteryDraw.encode(message.draw, writer.uint32(10).fork()).join();
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TriggerDrawResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTriggerDrawResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.draw = LotteryDraw.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TriggerDrawResponse {
    return {
      draw: isSet(object.draw) ? LotteryDraw.fromJSON(object.draw) : undefined,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: TriggerDrawResponse): unknown {
    const obj: any = {};
    if (message.draw !== undefined) {
      obj.draw = LotteryDraw.toJSON(message.draw);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TriggerDrawResponse>, I>>(base?: I): TriggerDrawResponse {
    return TriggerDrawResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TriggerDrawResponse>, I>>(object: I): TriggerDrawResponse {
    const message = createBaseTriggerDrawResponse();
    message.draw = (object.draw !== undefined && object.draw !== null)
      ? LotteryDraw.fromPartial(object.draw)
      : undefined;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseProfile(): Profile {
  return {
    userId: "",
    userName: "",
    displayName: "",
    avatarUrl: "",
    status: "",
    accountChip: 0,
    bankChip: 0,
    refCode: "",
    langTag: "",
    linkGroup: "",
    linkFanpageFb: "",
    appConfig: "",
    avatarId: "",
    registrable: false,
    vipLevel: 0,
    lastOnlineTimeUnix: 0,
    createTimeUnix: 0,
    remainTimeInputRefCode: 0,
    userSid: 0,
  };
}

export const Profile: MessageFns<Profile> = {
  encode(message: Profile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.userName !== "") {
      writer.uint32(18).string(message.userName);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.avatarUrl !== "") {
      writer.uint32(34).string(message.avatarUrl);
    }
    if (message.status !== "") {
      writer.uint32(42).string(message.status);
    }
    if (message.accountChip !== 0) {
      writer.uint32(48).int64(message.accountChip);
    }
    if (message.bankChip !== 0) {
      writer.uint32(56).int64(message.bankChip);
    }
    if (message.refCode !== "") {
      writer.uint32(66).string(message.refCode);
    }
    if (message.langTag !== "") {
      writer.uint32(74).string(message.langTag);
    }
    if (message.linkGroup !== "") {
      writer.uint32(82).string(message.linkGroup);
    }
    if (message.linkFanpageFb !== "") {
      writer.uint32(90).string(message.linkFanpageFb);
    }
    if (message.appConfig !== "") {
      writer.uint32(98).string(message.appConfig);
    }
    if (message.avatarId !== "") {
      writer.uint32(106).string(message.avatarId);
    }
    if (message.registrable !== false) {
      writer.uint32(112).bool(message.registrable);
    }
    if (message.vipLevel !== 0) {
      writer.uint32(120).int64(message.vipLevel);
    }
    if (message.lastOnlineTimeUnix !== 0) {
      writer.uint32(128).int64(message.lastOnlineTimeUnix);
    }
    if (message.createTimeUnix !== 0) {
      writer.uint32(136).int64(message.createTimeUnix);
    }
    if (message.remainTimeInputRefCode !== 0) {
      writer.uint32(144).int64(message.remainTimeInputRefCode);
    }
    if (message.userSid !== 0) {
      writer.uint32(232).int64(message.userSid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Profile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProfile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.avatarUrl = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.accountChip = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.bankChip = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.refCode = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.langTag = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.linkGroup = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.linkFanpageFb = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.appConfig = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.avatarId = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.registrable = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.vipLevel = longToNumber(reader.int64());
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.lastOnlineTimeUnix = longToNumber(reader.int64());
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.createTimeUnix = longToNumber(reader.int64());
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.remainTimeInputRefCode = longToNumber(reader.int64());
          continue;
        }
        case 29: {
          if (tag !== 232) {
            break;
          }

          message.userSid = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Profile {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      userName: isSet(object.userName) ? globalThis.String(object.userName) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      avatarUrl: isSet(object.avatarUrl) ? globalThis.String(object.avatarUrl) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      accountChip: isSet(object.accountChip) ? globalThis.Number(object.accountChip) : 0,
      bankChip: isSet(object.bankChip) ? globalThis.Number(object.bankChip) : 0,
      refCode: isSet(object.refCode) ? globalThis.String(object.refCode) : "",
      langTag: isSet(object.langTag) ? globalThis.String(object.langTag) : "",
      linkGroup: isSet(object.linkGroup) ? globalThis.String(object.linkGroup) : "",
      linkFanpageFb: isSet(object.linkFanpageFb) ? globalThis.String(object.linkFanpageFb) : "",
      appConfig: isSet(object.appConfig) ? globalThis.String(object.appConfig) : "",
      avatarId: isSet(object.avatarId) ? globalThis.String(object.avatarId) : "",
      registrable: isSet(object.registrable) ? globalThis.Boolean(object.registrable) : false,
      vipLevel: isSet(object.vipLevel) ? globalThis.Number(object.vipLevel) : 0,
      lastOnlineTimeUnix: isSet(object.lastOnlineTimeUnix) ? globalThis.Number(object.lastOnlineTimeUnix) : 0,
      createTimeUnix: isSet(object.createTimeUnix) ? globalThis.Number(object.createTimeUnix) : 0,
      remainTimeInputRefCode: isSet(object.remainTimeInputRefCode)
        ? globalThis.Number(object.remainTimeInputRefCode)
        : 0,
      userSid: isSet(object.userSid) ? globalThis.Number(object.userSid) : 0,
    };
  },

  toJSON(message: Profile): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.userName !== "") {
      obj.userName = message.userName;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.avatarUrl !== "") {
      obj.avatarUrl = message.avatarUrl;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.accountChip !== 0) {
      obj.accountChip = Math.round(message.accountChip);
    }
    if (message.bankChip !== 0) {
      obj.bankChip = Math.round(message.bankChip);
    }
    if (message.refCode !== "") {
      obj.refCode = message.refCode;
    }
    if (message.langTag !== "") {
      obj.langTag = message.langTag;
    }
    if (message.linkGroup !== "") {
      obj.linkGroup = message.linkGroup;
    }
    if (message.linkFanpageFb !== "") {
      obj.linkFanpageFb = message.linkFanpageFb;
    }
    if (message.appConfig !== "") {
      obj.appConfig = message.appConfig;
    }
    if (message.avatarId !== "") {
      obj.avatarId = message.avatarId;
    }
    if (message.registrable !== false) {
      obj.registrable = message.registrable;
    }
    if (message.vipLevel !== 0) {
      obj.vipLevel = Math.round(message.vipLevel);
    }
    if (message.lastOnlineTimeUnix !== 0) {
      obj.lastOnlineTimeUnix = Math.round(message.lastOnlineTimeUnix);
    }
    if (message.createTimeUnix !== 0) {
      obj.createTimeUnix = Math.round(message.createTimeUnix);
    }
    if (message.remainTimeInputRefCode !== 0) {
      obj.remainTimeInputRefCode = Math.round(message.remainTimeInputRefCode);
    }
    if (message.userSid !== 0) {
      obj.userSid = Math.round(message.userSid);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Profile>, I>>(base?: I): Profile {
    return Profile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Profile>, I>>(object: I): Profile {
    const message = createBaseProfile();
    message.userId = object.userId ?? "";
    message.userName = object.userName ?? "";
    message.displayName = object.displayName ?? "";
    message.avatarUrl = object.avatarUrl ?? "";
    message.status = object.status ?? "";
    message.accountChip = object.accountChip ?? 0;
    message.bankChip = object.bankChip ?? 0;
    message.refCode = object.refCode ?? "";
    message.langTag = object.langTag ?? "";
    message.linkGroup = object.linkGroup ?? "";
    message.linkFanpageFb = object.linkFanpageFb ?? "";
    message.appConfig = object.appConfig ?? "";
    message.avatarId = object.avatarId ?? "";
    message.registrable = object.registrable ?? false;
    message.vipLevel = object.vipLevel ?? 0;
    message.lastOnlineTimeUnix = object.lastOnlineTimeUnix ?? 0;
    message.createTimeUnix = object.createTimeUnix ?? 0;
    message.remainTimeInputRefCode = object.remainTimeInputRefCode ?? 0;
    message.userSid = object.userSid ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
