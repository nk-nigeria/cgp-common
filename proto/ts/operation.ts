// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v3.20.3
// source: operation.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Profile } from "./auth";

export const protobufPackage = "proto";

export enum CurrencyUnitId {
  CURRENCY_UNIT_ID_UNSPECIFIED = 0,
  CURRENCY_UNIT_ID_VN = 1,
  UNRECOGNIZED = -1,
}

export function currencyUnitIdFromJSON(object: any): CurrencyUnitId {
  switch (object) {
    case 0:
    case "CURRENCY_UNIT_ID_UNSPECIFIED":
      return CurrencyUnitId.CURRENCY_UNIT_ID_UNSPECIFIED;
    case 1:
    case "CURRENCY_UNIT_ID_VN":
      return CurrencyUnitId.CURRENCY_UNIT_ID_VN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CurrencyUnitId.UNRECOGNIZED;
  }
}

export function currencyUnitIdToJSON(object: CurrencyUnitId): string {
  switch (object) {
    case CurrencyUnitId.CURRENCY_UNIT_ID_UNSPECIFIED:
      return "CURRENCY_UNIT_ID_UNSPECIFIED";
    case CurrencyUnitId.CURRENCY_UNIT_ID_VN:
      return "CURRENCY_UNIT_ID_VN";
    case CurrencyUnitId.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface OpPlayer {
  userId: string;
  userName: string;
  gameId: string;
  gameName: string;
  noBet: string;
  noWin: string;
  noLost: string;
  chipWin: string;
  chipWinPrefee: string;
  chipLost: string;
  chipBalance: string;
  action: string;
  status: string;
  dateUnix: string;
  mcb: string;
  userSid: string;
}

export interface OpPlayerRequest {
  userId: string;
  gameId: string;
  fromUnix: string;
  toUnix: string;
  action: string;
  offset: string;
  limit: string;
  userSid: string;
}

export interface OpPlayerResponse {
  opPlayers: OpPlayer[];
  total: string;
  offset: string;
  limit: string;
  totalChipWin: string;
  totalChipLost: string;
}

export interface MatchDetail {
  gameId: string;
  gameName: string;
  mcb: string;
  numMatchPlayed: string;
  chipFee: string;
  detail: string;
  tableId: string;
  dateUnix: string;
  createdAtUnix: string;
  chipWin: string;
  chipLose: string;
}

export interface MatchDetailRequest {
  gameId: string;
  fromUnix: string;
  toUnix: string;
  userSid: string;
  userPairSid: string;
  limit: string;
  offset: string;
}

export interface MatchDetailResponse {
  matchDetails: MatchDetail[];
  total: string;
  limit: string;
  offset: string;
}

export interface PlayerData {
  userId: string;
  chip: string;
  chipAdd: string;
  userSid: string;
  chipFee: string;
  chipAddPrefee: string;
}

export interface MatchData {
  gameId: string;
  gameCode: string;
  mcb: string;
  chipFee: string;
  matchId: string;
  tableId: string;
}

export interface OpReport {
  playerData: PlayerData[];
  matchData: MatchData | undefined;
}

export interface GoldStatistic {
  timeUpdateUnix: string;
  pay: string;
  promotion: string;
  matchData: MatchData[];
  agCashout: string;
  agBank: string;
  chips: string;
}

export interface GoldStatisticRequest {
  fromUnix: string;
  toUnix: string;
  limit: string;
  offset: string;
}

export interface GoldStatisticResponse {
  goldStatistics: GoldStatistic[];
  limit: string;
  offset: string;
  total: string;
}

export interface UserStatistic {
  totalChipDeposit: string;
  totalChipWithDraw: string;
  totalChipWin: string;
  totalChipWinPrefee: string;
  totalChipLose: string;
  totalChipPromotion: string;
  totalChipSend: string;
  totalChipRecv: string;
  coRatio: string;
  totalChipDeposit3d: string;
  totalChipWithDraw3d: string;
  luck: string;
  userCreateTimeUnix: string;
  userStatGameHistories: UserStatGameHistory[];
  recvChipStats: UserTransferGoldStat[];
  sendChipStats: UserTransferGoldStat[];
  userId: string;
}

export interface UserStatisticRequest {
  userId: string;
  fromUnix: string;
  toUnix: string;
  userSid: string;
  deviceId: string;
}

export interface UserStatGameHistory {
  gameId: string;
  gameName: string;
  totalChipWin: string;
  totalChipWinPrefee: string;
  totalChipLost: string;
  noGameWin: string;
  noGameLost: string;
  userId: string;
}

export interface UserTransferGoldStat {
  userSendId: string;
  userSendName: string;
  userRecvId: string;
  userRecvName: string;
  chip: string;
}

export interface UserInfo {
  profile: Profile | undefined;
  totalIn: string;
  totalOut: string;
}

export interface UserInfoResponse {
  userInfos: UserInfo[];
  total: string;
  deviceId: string;
  totalIn: string;
  totalOut: string;
  totalLock: string;
}

export interface CashOut {
  userId: string;
  userName: string;
  ci: string;
  cio: string;
  co: string;
  coo: string;
  luckyPercent: string;
  userSid: string;
}

export interface TopCashOut {
  cashouts: CashOut[];
  fromUnix: string;
  toUnix: string;
  limit: string;
  offset: string;
  total: string;
}

export interface Vip {
  userId: string;
  userName: string;
  cio: string;
  totalChip: string;
  lastLoginTimeUnix: string;
  createdTimeUnix: string;
  refGame: string;
  ci: string;
  co: string;
  ci2d: string;
  co2d: string;
  luckyPercent: string;
  isBanned: boolean;
  isOnline: boolean;
  totalIn: string;
  totalOut: string;
  userSid: string;
}

export interface TopVip {
  vips: Vip[];
  fromUnix: string;
  toUnix: string;
  limit: string;
  offset: string;
  refGame: string;
  total: string;
}

export interface Win {
  userId: string;
  userName: string;
  vip: string;
  gold: string;
  ag: string;
  agWin: string;
  co: string;
  ci: string;
  coRate: string;
  luckyPercent: string;
  userSid: string;
}

export interface TopWin {
  wins: Win[];
  fromUnix: string;
  toUnix: string;
  limit: string;
  offset: string;
  refGame: string;
  total: string;
  gameId: string;
}

export interface Lost {
  userId: string;
  userName: string;
  vip: string;
  gold: string;
  ag: string;
  agLost: string;
  co: string;
  ci: string;
  coRate: string;
  luckyPercent: string;
  userSid: string;
}

export interface TopLost {
  losts: Lost[];
  fromUnix: string;
  toUnix: string;
  limit: string;
  offset: string;
  refGame: string;
  total: string;
  gameId: string;
}

export interface TransactionRequest {
  userSid: string;
  fromUnix: string;
  toUnix: string;
  limit: string;
  offset: string;
}

export interface TransactionDetail {
  id: string;
  userId: string;
  userSid: string;
  userName: string;
  vip: string;
  /** Số tiền nạp */
  rp: string;
  typeTopup: string;
  /** Số chip user được nhận của giao dịch */
  chipsTopup: string;
  createdUnix: string;
}

export interface TransactionResponse {
  transDetails: TransactionDetail[];
  totalRp: string;
  limit: string;
  offset: string;
  total: string;
}

export interface IAPSummary {
  id: string;
  userId: string;
  createAtUnix: string;
  totalTopup: string;
  vipPoint: string;
  totalCashout: string;
  vip: string;
  currencyTopup: string;
  currencyCashout: string;
}

export interface CashInfo {
  id: string;
  userId: string;
  createAtUnix: string;
  chips: string;
  vipPoint: string;
  publisher: string;
  currency: string;
  /** vi_vn, en_us follow Locale name standard */
  currencyUnitId: string;
  transId: string;
  dateUnix: string;
  numTransaction: string;
  /** 10, 20, 30 ... */
  currencyValue: string;
  currencyUnitName: string;
  numTransByCurrencyValue: { [key: string]: string };
  numAccountUnique: string;
  netRev: string;
}

export interface CashInfo_NumTransByCurrencyValueEntry {
  key: string;
  value: string;
}

export interface CashInfoRequest {
  fromUnix: string;
  toUnix: string;
  limit: string;
  offset: string;
  publisher: string;
  currencyId: CurrencyUnitId;
}

export interface CashInfoResponse {
  cashoutInfos: CashInfo[];
  totalCash: string;
  totalAccount: string;
  avgCash: string;
  totalRev: string;
  avgRev: string;
}

export interface UserGameCount {
  dateUnix: string;
  countGame: string;
}

export interface UserGameStats {
  userId: string;
  gameNo: string;
  userGameCounts: UserGameCount[];
}

export interface PaymentByVip {
  vip: string;
  ci: string;
  chips: string;
  numTrans: string;
  numAccount: string;
}

export interface PaymentsByVip {
  payments: PaymentByVip[];
  fromUnix: string;
  toUnix: string;
}

export interface CashoutByVip {
  vip: string;
  co: string;
  chips: string;
  numTrans: string;
  numAccount: string;
}

export interface CashoutsByVip {
  cashouts: CashoutByVip[];
  fromUnix: string;
  toUnix: string;
}

export interface VipStats {
  timeUpdateUnix: string;
  userSid: string;
  userId: string;
  userName: string;
  noWin: string;
  noLose: string;
  chipsWin: string;
  chipsLose: string;
  cashIn: string;
  cashIn5: string;
  cashIn10: string;
  cashOut: string;
  cashOut5: string;
  cashOut10: string;
  vip: string;
}

export interface VipStatsReponse {
  vipsStats: VipStats[];
  total: string;
  fromUnix: string;
  limit: string;
  offset: string;
}

function createBaseOpPlayer(): OpPlayer {
  return {
    userId: "",
    userName: "",
    gameId: "0",
    gameName: "",
    noBet: "0",
    noWin: "0",
    noLost: "0",
    chipWin: "0",
    chipWinPrefee: "0",
    chipLost: "0",
    chipBalance: "0",
    action: "0",
    status: "",
    dateUnix: "0",
    mcb: "0",
    userSid: "0",
  };
}

export const OpPlayer: MessageFns<OpPlayer> = {
  encode(message: OpPlayer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.userName !== "") {
      writer.uint32(18).string(message.userName);
    }
    if (message.gameId !== "0") {
      writer.uint32(24).int64(message.gameId);
    }
    if (message.gameName !== "") {
      writer.uint32(34).string(message.gameName);
    }
    if (message.noBet !== "0") {
      writer.uint32(40).int64(message.noBet);
    }
    if (message.noWin !== "0") {
      writer.uint32(48).int64(message.noWin);
    }
    if (message.noLost !== "0") {
      writer.uint32(56).int64(message.noLost);
    }
    if (message.chipWin !== "0") {
      writer.uint32(64).uint64(message.chipWin);
    }
    if (message.chipWinPrefee !== "0") {
      writer.uint32(72).uint64(message.chipWinPrefee);
    }
    if (message.chipLost !== "0") {
      writer.uint32(80).uint64(message.chipLost);
    }
    if (message.chipBalance !== "0") {
      writer.uint32(88).int64(message.chipBalance);
    }
    if (message.action !== "0") {
      writer.uint32(96).int64(message.action);
    }
    if (message.status !== "") {
      writer.uint32(106).string(message.status);
    }
    if (message.dateUnix !== "0") {
      writer.uint32(112).int64(message.dateUnix);
    }
    if (message.mcb !== "0") {
      writer.uint32(120).int64(message.mcb);
    }
    if (message.userSid !== "0") {
      writer.uint32(128).int64(message.userSid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpPlayer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpPlayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.gameId = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.gameName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.noBet = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.noWin = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.noLost = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.chipWin = reader.uint64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.chipWinPrefee = reader.uint64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.chipLost = reader.uint64().toString();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.chipBalance = reader.int64().toString();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.action = reader.int64().toString();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.dateUnix = reader.int64().toString();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.mcb = reader.int64().toString();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.userSid = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpPlayer {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      userName: isSet(object.userName) ? globalThis.String(object.userName) : "",
      gameId: isSet(object.gameId) ? globalThis.String(object.gameId) : "0",
      gameName: isSet(object.gameName) ? globalThis.String(object.gameName) : "",
      noBet: isSet(object.noBet) ? globalThis.String(object.noBet) : "0",
      noWin: isSet(object.noWin) ? globalThis.String(object.noWin) : "0",
      noLost: isSet(object.noLost) ? globalThis.String(object.noLost) : "0",
      chipWin: isSet(object.chipWin) ? globalThis.String(object.chipWin) : "0",
      chipWinPrefee: isSet(object.chipWinPrefee) ? globalThis.String(object.chipWinPrefee) : "0",
      chipLost: isSet(object.chipLost) ? globalThis.String(object.chipLost) : "0",
      chipBalance: isSet(object.chipBalance) ? globalThis.String(object.chipBalance) : "0",
      action: isSet(object.action) ? globalThis.String(object.action) : "0",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      dateUnix: isSet(object.dateUnix) ? globalThis.String(object.dateUnix) : "0",
      mcb: isSet(object.mcb) ? globalThis.String(object.mcb) : "0",
      userSid: isSet(object.userSid) ? globalThis.String(object.userSid) : "0",
    };
  },

  toJSON(message: OpPlayer): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.userName !== "") {
      obj.userName = message.userName;
    }
    if (message.gameId !== "0") {
      obj.gameId = message.gameId;
    }
    if (message.gameName !== "") {
      obj.gameName = message.gameName;
    }
    if (message.noBet !== "0") {
      obj.noBet = message.noBet;
    }
    if (message.noWin !== "0") {
      obj.noWin = message.noWin;
    }
    if (message.noLost !== "0") {
      obj.noLost = message.noLost;
    }
    if (message.chipWin !== "0") {
      obj.chipWin = message.chipWin;
    }
    if (message.chipWinPrefee !== "0") {
      obj.chipWinPrefee = message.chipWinPrefee;
    }
    if (message.chipLost !== "0") {
      obj.chipLost = message.chipLost;
    }
    if (message.chipBalance !== "0") {
      obj.chipBalance = message.chipBalance;
    }
    if (message.action !== "0") {
      obj.action = message.action;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.dateUnix !== "0") {
      obj.dateUnix = message.dateUnix;
    }
    if (message.mcb !== "0") {
      obj.mcb = message.mcb;
    }
    if (message.userSid !== "0") {
      obj.userSid = message.userSid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpPlayer>, I>>(base?: I): OpPlayer {
    return OpPlayer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpPlayer>, I>>(object: I): OpPlayer {
    const message = createBaseOpPlayer();
    message.userId = object.userId ?? "";
    message.userName = object.userName ?? "";
    message.gameId = object.gameId ?? "0";
    message.gameName = object.gameName ?? "";
    message.noBet = object.noBet ?? "0";
    message.noWin = object.noWin ?? "0";
    message.noLost = object.noLost ?? "0";
    message.chipWin = object.chipWin ?? "0";
    message.chipWinPrefee = object.chipWinPrefee ?? "0";
    message.chipLost = object.chipLost ?? "0";
    message.chipBalance = object.chipBalance ?? "0";
    message.action = object.action ?? "0";
    message.status = object.status ?? "";
    message.dateUnix = object.dateUnix ?? "0";
    message.mcb = object.mcb ?? "0";
    message.userSid = object.userSid ?? "0";
    return message;
  },
};

function createBaseOpPlayerRequest(): OpPlayerRequest {
  return { userId: "", gameId: "0", fromUnix: "0", toUnix: "0", action: "0", offset: "0", limit: "0", userSid: "0" };
}

export const OpPlayerRequest: MessageFns<OpPlayerRequest> = {
  encode(message: OpPlayerRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.gameId !== "0") {
      writer.uint32(16).int64(message.gameId);
    }
    if (message.fromUnix !== "0") {
      writer.uint32(24).int64(message.fromUnix);
    }
    if (message.toUnix !== "0") {
      writer.uint32(32).int64(message.toUnix);
    }
    if (message.action !== "0") {
      writer.uint32(40).int64(message.action);
    }
    if (message.offset !== "0") {
      writer.uint32(48).int64(message.offset);
    }
    if (message.limit !== "0") {
      writer.uint32(56).int64(message.limit);
    }
    if (message.userSid !== "0") {
      writer.uint32(64).int64(message.userSid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpPlayerRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpPlayerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.gameId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.fromUnix = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.toUnix = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.action = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.offset = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.limit = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.userSid = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpPlayerRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      gameId: isSet(object.gameId) ? globalThis.String(object.gameId) : "0",
      fromUnix: isSet(object.fromUnix) ? globalThis.String(object.fromUnix) : "0",
      toUnix: isSet(object.toUnix) ? globalThis.String(object.toUnix) : "0",
      action: isSet(object.action) ? globalThis.String(object.action) : "0",
      offset: isSet(object.offset) ? globalThis.String(object.offset) : "0",
      limit: isSet(object.limit) ? globalThis.String(object.limit) : "0",
      userSid: isSet(object.userSid) ? globalThis.String(object.userSid) : "0",
    };
  },

  toJSON(message: OpPlayerRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.gameId !== "0") {
      obj.gameId = message.gameId;
    }
    if (message.fromUnix !== "0") {
      obj.fromUnix = message.fromUnix;
    }
    if (message.toUnix !== "0") {
      obj.toUnix = message.toUnix;
    }
    if (message.action !== "0") {
      obj.action = message.action;
    }
    if (message.offset !== "0") {
      obj.offset = message.offset;
    }
    if (message.limit !== "0") {
      obj.limit = message.limit;
    }
    if (message.userSid !== "0") {
      obj.userSid = message.userSid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpPlayerRequest>, I>>(base?: I): OpPlayerRequest {
    return OpPlayerRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpPlayerRequest>, I>>(object: I): OpPlayerRequest {
    const message = createBaseOpPlayerRequest();
    message.userId = object.userId ?? "";
    message.gameId = object.gameId ?? "0";
    message.fromUnix = object.fromUnix ?? "0";
    message.toUnix = object.toUnix ?? "0";
    message.action = object.action ?? "0";
    message.offset = object.offset ?? "0";
    message.limit = object.limit ?? "0";
    message.userSid = object.userSid ?? "0";
    return message;
  },
};

function createBaseOpPlayerResponse(): OpPlayerResponse {
  return { opPlayers: [], total: "0", offset: "0", limit: "0", totalChipWin: "0", totalChipLost: "0" };
}

export const OpPlayerResponse: MessageFns<OpPlayerResponse> = {
  encode(message: OpPlayerResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.opPlayers) {
      OpPlayer.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== "0") {
      writer.uint32(16).int64(message.total);
    }
    if (message.offset !== "0") {
      writer.uint32(24).int64(message.offset);
    }
    if (message.limit !== "0") {
      writer.uint32(32).int64(message.limit);
    }
    if (message.totalChipWin !== "0") {
      writer.uint32(40).uint64(message.totalChipWin);
    }
    if (message.totalChipLost !== "0") {
      writer.uint32(48).uint64(message.totalChipLost);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpPlayerResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpPlayerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.opPlayers.push(OpPlayer.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.offset = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.limit = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.totalChipWin = reader.uint64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.totalChipLost = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpPlayerResponse {
    return {
      opPlayers: globalThis.Array.isArray(object?.opPlayers)
        ? object.opPlayers.map((e: any) => OpPlayer.fromJSON(e))
        : [],
      total: isSet(object.total) ? globalThis.String(object.total) : "0",
      offset: isSet(object.offset) ? globalThis.String(object.offset) : "0",
      limit: isSet(object.limit) ? globalThis.String(object.limit) : "0",
      totalChipWin: isSet(object.totalChipWin) ? globalThis.String(object.totalChipWin) : "0",
      totalChipLost: isSet(object.totalChipLost) ? globalThis.String(object.totalChipLost) : "0",
    };
  },

  toJSON(message: OpPlayerResponse): unknown {
    const obj: any = {};
    if (message.opPlayers?.length) {
      obj.opPlayers = message.opPlayers.map((e) => OpPlayer.toJSON(e));
    }
    if (message.total !== "0") {
      obj.total = message.total;
    }
    if (message.offset !== "0") {
      obj.offset = message.offset;
    }
    if (message.limit !== "0") {
      obj.limit = message.limit;
    }
    if (message.totalChipWin !== "0") {
      obj.totalChipWin = message.totalChipWin;
    }
    if (message.totalChipLost !== "0") {
      obj.totalChipLost = message.totalChipLost;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpPlayerResponse>, I>>(base?: I): OpPlayerResponse {
    return OpPlayerResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpPlayerResponse>, I>>(object: I): OpPlayerResponse {
    const message = createBaseOpPlayerResponse();
    message.opPlayers = object.opPlayers?.map((e) => OpPlayer.fromPartial(e)) || [];
    message.total = object.total ?? "0";
    message.offset = object.offset ?? "0";
    message.limit = object.limit ?? "0";
    message.totalChipWin = object.totalChipWin ?? "0";
    message.totalChipLost = object.totalChipLost ?? "0";
    return message;
  },
};

function createBaseMatchDetail(): MatchDetail {
  return {
    gameId: "0",
    gameName: "",
    mcb: "0",
    numMatchPlayed: "0",
    chipFee: "0",
    detail: "",
    tableId: "0",
    dateUnix: "0",
    createdAtUnix: "0",
    chipWin: "0",
    chipLose: "0",
  };
}

export const MatchDetail: MessageFns<MatchDetail> = {
  encode(message: MatchDetail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gameId !== "0") {
      writer.uint32(8).int64(message.gameId);
    }
    if (message.gameName !== "") {
      writer.uint32(18).string(message.gameName);
    }
    if (message.mcb !== "0") {
      writer.uint32(24).int64(message.mcb);
    }
    if (message.numMatchPlayed !== "0") {
      writer.uint32(32).int64(message.numMatchPlayed);
    }
    if (message.chipFee !== "0") {
      writer.uint32(40).uint64(message.chipFee);
    }
    if (message.detail !== "") {
      writer.uint32(50).string(message.detail);
    }
    if (message.tableId !== "0") {
      writer.uint32(56).int64(message.tableId);
    }
    if (message.dateUnix !== "0") {
      writer.uint32(64).int64(message.dateUnix);
    }
    if (message.createdAtUnix !== "0") {
      writer.uint32(72).int64(message.createdAtUnix);
    }
    if (message.chipWin !== "0") {
      writer.uint32(80).int64(message.chipWin);
    }
    if (message.chipLose !== "0") {
      writer.uint32(88).int64(message.chipLose);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MatchDetail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatchDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.gameId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.gameName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.mcb = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.numMatchPlayed = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.chipFee = reader.uint64().toString();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.detail = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.tableId = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.dateUnix = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.createdAtUnix = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.chipWin = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.chipLose = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MatchDetail {
    return {
      gameId: isSet(object.gameId) ? globalThis.String(object.gameId) : "0",
      gameName: isSet(object.gameName) ? globalThis.String(object.gameName) : "",
      mcb: isSet(object.mcb) ? globalThis.String(object.mcb) : "0",
      numMatchPlayed: isSet(object.numMatchPlayed) ? globalThis.String(object.numMatchPlayed) : "0",
      chipFee: isSet(object.chipFee) ? globalThis.String(object.chipFee) : "0",
      detail: isSet(object.detail) ? globalThis.String(object.detail) : "",
      tableId: isSet(object.tableId) ? globalThis.String(object.tableId) : "0",
      dateUnix: isSet(object.dateUnix) ? globalThis.String(object.dateUnix) : "0",
      createdAtUnix: isSet(object.createdAtUnix) ? globalThis.String(object.createdAtUnix) : "0",
      chipWin: isSet(object.chipWin) ? globalThis.String(object.chipWin) : "0",
      chipLose: isSet(object.chipLose) ? globalThis.String(object.chipLose) : "0",
    };
  },

  toJSON(message: MatchDetail): unknown {
    const obj: any = {};
    if (message.gameId !== "0") {
      obj.gameId = message.gameId;
    }
    if (message.gameName !== "") {
      obj.gameName = message.gameName;
    }
    if (message.mcb !== "0") {
      obj.mcb = message.mcb;
    }
    if (message.numMatchPlayed !== "0") {
      obj.numMatchPlayed = message.numMatchPlayed;
    }
    if (message.chipFee !== "0") {
      obj.chipFee = message.chipFee;
    }
    if (message.detail !== "") {
      obj.detail = message.detail;
    }
    if (message.tableId !== "0") {
      obj.tableId = message.tableId;
    }
    if (message.dateUnix !== "0") {
      obj.dateUnix = message.dateUnix;
    }
    if (message.createdAtUnix !== "0") {
      obj.createdAtUnix = message.createdAtUnix;
    }
    if (message.chipWin !== "0") {
      obj.chipWin = message.chipWin;
    }
    if (message.chipLose !== "0") {
      obj.chipLose = message.chipLose;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MatchDetail>, I>>(base?: I): MatchDetail {
    return MatchDetail.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MatchDetail>, I>>(object: I): MatchDetail {
    const message = createBaseMatchDetail();
    message.gameId = object.gameId ?? "0";
    message.gameName = object.gameName ?? "";
    message.mcb = object.mcb ?? "0";
    message.numMatchPlayed = object.numMatchPlayed ?? "0";
    message.chipFee = object.chipFee ?? "0";
    message.detail = object.detail ?? "";
    message.tableId = object.tableId ?? "0";
    message.dateUnix = object.dateUnix ?? "0";
    message.createdAtUnix = object.createdAtUnix ?? "0";
    message.chipWin = object.chipWin ?? "0";
    message.chipLose = object.chipLose ?? "0";
    return message;
  },
};

function createBaseMatchDetailRequest(): MatchDetailRequest {
  return { gameId: "0", fromUnix: "0", toUnix: "0", userSid: "0", userPairSid: "0", limit: "0", offset: "0" };
}

export const MatchDetailRequest: MessageFns<MatchDetailRequest> = {
  encode(message: MatchDetailRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gameId !== "0") {
      writer.uint32(8).int64(message.gameId);
    }
    if (message.fromUnix !== "0") {
      writer.uint32(16).int64(message.fromUnix);
    }
    if (message.toUnix !== "0") {
      writer.uint32(24).int64(message.toUnix);
    }
    if (message.userSid !== "0") {
      writer.uint32(32).int64(message.userSid);
    }
    if (message.userPairSid !== "0") {
      writer.uint32(40).int64(message.userPairSid);
    }
    if (message.limit !== "0") {
      writer.uint32(48).int64(message.limit);
    }
    if (message.offset !== "0") {
      writer.uint32(56).int64(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MatchDetailRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatchDetailRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.gameId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.fromUnix = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.toUnix = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.userSid = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.userPairSid = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.limit = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.offset = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MatchDetailRequest {
    return {
      gameId: isSet(object.gameId) ? globalThis.String(object.gameId) : "0",
      fromUnix: isSet(object.fromUnix) ? globalThis.String(object.fromUnix) : "0",
      toUnix: isSet(object.toUnix) ? globalThis.String(object.toUnix) : "0",
      userSid: isSet(object.userSid) ? globalThis.String(object.userSid) : "0",
      userPairSid: isSet(object.userPairSid) ? globalThis.String(object.userPairSid) : "0",
      limit: isSet(object.limit) ? globalThis.String(object.limit) : "0",
      offset: isSet(object.offset) ? globalThis.String(object.offset) : "0",
    };
  },

  toJSON(message: MatchDetailRequest): unknown {
    const obj: any = {};
    if (message.gameId !== "0") {
      obj.gameId = message.gameId;
    }
    if (message.fromUnix !== "0") {
      obj.fromUnix = message.fromUnix;
    }
    if (message.toUnix !== "0") {
      obj.toUnix = message.toUnix;
    }
    if (message.userSid !== "0") {
      obj.userSid = message.userSid;
    }
    if (message.userPairSid !== "0") {
      obj.userPairSid = message.userPairSid;
    }
    if (message.limit !== "0") {
      obj.limit = message.limit;
    }
    if (message.offset !== "0") {
      obj.offset = message.offset;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MatchDetailRequest>, I>>(base?: I): MatchDetailRequest {
    return MatchDetailRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MatchDetailRequest>, I>>(object: I): MatchDetailRequest {
    const message = createBaseMatchDetailRequest();
    message.gameId = object.gameId ?? "0";
    message.fromUnix = object.fromUnix ?? "0";
    message.toUnix = object.toUnix ?? "0";
    message.userSid = object.userSid ?? "0";
    message.userPairSid = object.userPairSid ?? "0";
    message.limit = object.limit ?? "0";
    message.offset = object.offset ?? "0";
    return message;
  },
};

function createBaseMatchDetailResponse(): MatchDetailResponse {
  return { matchDetails: [], total: "0", limit: "0", offset: "0" };
}

export const MatchDetailResponse: MessageFns<MatchDetailResponse> = {
  encode(message: MatchDetailResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.matchDetails) {
      MatchDetail.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== "0") {
      writer.uint32(16).int64(message.total);
    }
    if (message.limit !== "0") {
      writer.uint32(48).int64(message.limit);
    }
    if (message.offset !== "0") {
      writer.uint32(56).int64(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MatchDetailResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatchDetailResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.matchDetails.push(MatchDetail.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.limit = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.offset = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MatchDetailResponse {
    return {
      matchDetails: globalThis.Array.isArray(object?.matchDetails)
        ? object.matchDetails.map((e: any) => MatchDetail.fromJSON(e))
        : [],
      total: isSet(object.total) ? globalThis.String(object.total) : "0",
      limit: isSet(object.limit) ? globalThis.String(object.limit) : "0",
      offset: isSet(object.offset) ? globalThis.String(object.offset) : "0",
    };
  },

  toJSON(message: MatchDetailResponse): unknown {
    const obj: any = {};
    if (message.matchDetails?.length) {
      obj.matchDetails = message.matchDetails.map((e) => MatchDetail.toJSON(e));
    }
    if (message.total !== "0") {
      obj.total = message.total;
    }
    if (message.limit !== "0") {
      obj.limit = message.limit;
    }
    if (message.offset !== "0") {
      obj.offset = message.offset;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MatchDetailResponse>, I>>(base?: I): MatchDetailResponse {
    return MatchDetailResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MatchDetailResponse>, I>>(object: I): MatchDetailResponse {
    const message = createBaseMatchDetailResponse();
    message.matchDetails = object.matchDetails?.map((e) => MatchDetail.fromPartial(e)) || [];
    message.total = object.total ?? "0";
    message.limit = object.limit ?? "0";
    message.offset = object.offset ?? "0";
    return message;
  },
};

function createBasePlayerData(): PlayerData {
  return { userId: "", chip: "0", chipAdd: "0", userSid: "0", chipFee: "0", chipAddPrefee: "0" };
}

export const PlayerData: MessageFns<PlayerData> = {
  encode(message: PlayerData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.chip !== "0") {
      writer.uint32(16).int64(message.chip);
    }
    if (message.chipAdd !== "0") {
      writer.uint32(24).int64(message.chipAdd);
    }
    if (message.userSid !== "0") {
      writer.uint32(64).int64(message.userSid);
    }
    if (message.chipFee !== "0") {
      writer.uint32(72).int64(message.chipFee);
    }
    if (message.chipAddPrefee !== "0") {
      writer.uint32(80).int64(message.chipAddPrefee);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayerData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayerData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.chip = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.chipAdd = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.userSid = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.chipFee = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.chipAddPrefee = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayerData {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      chip: isSet(object.chip) ? globalThis.String(object.chip) : "0",
      chipAdd: isSet(object.chipAdd) ? globalThis.String(object.chipAdd) : "0",
      userSid: isSet(object.userSid) ? globalThis.String(object.userSid) : "0",
      chipFee: isSet(object.chipFee) ? globalThis.String(object.chipFee) : "0",
      chipAddPrefee: isSet(object.chipAddPrefee) ? globalThis.String(object.chipAddPrefee) : "0",
    };
  },

  toJSON(message: PlayerData): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.chip !== "0") {
      obj.chip = message.chip;
    }
    if (message.chipAdd !== "0") {
      obj.chipAdd = message.chipAdd;
    }
    if (message.userSid !== "0") {
      obj.userSid = message.userSid;
    }
    if (message.chipFee !== "0") {
      obj.chipFee = message.chipFee;
    }
    if (message.chipAddPrefee !== "0") {
      obj.chipAddPrefee = message.chipAddPrefee;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlayerData>, I>>(base?: I): PlayerData {
    return PlayerData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlayerData>, I>>(object: I): PlayerData {
    const message = createBasePlayerData();
    message.userId = object.userId ?? "";
    message.chip = object.chip ?? "0";
    message.chipAdd = object.chipAdd ?? "0";
    message.userSid = object.userSid ?? "0";
    message.chipFee = object.chipFee ?? "0";
    message.chipAddPrefee = object.chipAddPrefee ?? "0";
    return message;
  },
};

function createBaseMatchData(): MatchData {
  return { gameId: "0", gameCode: "", mcb: "0", chipFee: "0", matchId: "", tableId: "" };
}

export const MatchData: MessageFns<MatchData> = {
  encode(message: MatchData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gameId !== "0") {
      writer.uint32(8).int64(message.gameId);
    }
    if (message.gameCode !== "") {
      writer.uint32(26).string(message.gameCode);
    }
    if (message.mcb !== "0") {
      writer.uint32(32).int64(message.mcb);
    }
    if (message.chipFee !== "0") {
      writer.uint32(40).int64(message.chipFee);
    }
    if (message.matchId !== "") {
      writer.uint32(50).string(message.matchId);
    }
    if (message.tableId !== "") {
      writer.uint32(58).string(message.tableId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MatchData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatchData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.gameId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.gameCode = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.mcb = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.chipFee = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.matchId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.tableId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MatchData {
    return {
      gameId: isSet(object.gameId) ? globalThis.String(object.gameId) : "0",
      gameCode: isSet(object.gameCode) ? globalThis.String(object.gameCode) : "",
      mcb: isSet(object.mcb) ? globalThis.String(object.mcb) : "0",
      chipFee: isSet(object.chipFee) ? globalThis.String(object.chipFee) : "0",
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "",
      tableId: isSet(object.tableId) ? globalThis.String(object.tableId) : "",
    };
  },

  toJSON(message: MatchData): unknown {
    const obj: any = {};
    if (message.gameId !== "0") {
      obj.gameId = message.gameId;
    }
    if (message.gameCode !== "") {
      obj.gameCode = message.gameCode;
    }
    if (message.mcb !== "0") {
      obj.mcb = message.mcb;
    }
    if (message.chipFee !== "0") {
      obj.chipFee = message.chipFee;
    }
    if (message.matchId !== "") {
      obj.matchId = message.matchId;
    }
    if (message.tableId !== "") {
      obj.tableId = message.tableId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MatchData>, I>>(base?: I): MatchData {
    return MatchData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MatchData>, I>>(object: I): MatchData {
    const message = createBaseMatchData();
    message.gameId = object.gameId ?? "0";
    message.gameCode = object.gameCode ?? "";
    message.mcb = object.mcb ?? "0";
    message.chipFee = object.chipFee ?? "0";
    message.matchId = object.matchId ?? "";
    message.tableId = object.tableId ?? "";
    return message;
  },
};

function createBaseOpReport(): OpReport {
  return { playerData: [], matchData: undefined };
}

export const OpReport: MessageFns<OpReport> = {
  encode(message: OpReport, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.playerData) {
      PlayerData.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.matchData !== undefined) {
      MatchData.encode(message.matchData, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpReport {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpReport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playerData.push(PlayerData.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.matchData = MatchData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpReport {
    return {
      playerData: globalThis.Array.isArray(object?.playerData)
        ? object.playerData.map((e: any) => PlayerData.fromJSON(e))
        : [],
      matchData: isSet(object.matchData) ? MatchData.fromJSON(object.matchData) : undefined,
    };
  },

  toJSON(message: OpReport): unknown {
    const obj: any = {};
    if (message.playerData?.length) {
      obj.playerData = message.playerData.map((e) => PlayerData.toJSON(e));
    }
    if (message.matchData !== undefined) {
      obj.matchData = MatchData.toJSON(message.matchData);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpReport>, I>>(base?: I): OpReport {
    return OpReport.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpReport>, I>>(object: I): OpReport {
    const message = createBaseOpReport();
    message.playerData = object.playerData?.map((e) => PlayerData.fromPartial(e)) || [];
    message.matchData = (object.matchData !== undefined && object.matchData !== null)
      ? MatchData.fromPartial(object.matchData)
      : undefined;
    return message;
  },
};

function createBaseGoldStatistic(): GoldStatistic {
  return { timeUpdateUnix: "0", pay: "0", promotion: "0", matchData: [], agCashout: "0", agBank: "0", chips: "0" };
}

export const GoldStatistic: MessageFns<GoldStatistic> = {
  encode(message: GoldStatistic, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timeUpdateUnix !== "0") {
      writer.uint32(8).int64(message.timeUpdateUnix);
    }
    if (message.pay !== "0") {
      writer.uint32(16).int64(message.pay);
    }
    if (message.promotion !== "0") {
      writer.uint32(24).int64(message.promotion);
    }
    for (const v of message.matchData) {
      MatchData.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.agCashout !== "0") {
      writer.uint32(40).int64(message.agCashout);
    }
    if (message.agBank !== "0") {
      writer.uint32(48).int64(message.agBank);
    }
    if (message.chips !== "0") {
      writer.uint32(56).int64(message.chips);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GoldStatistic {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGoldStatistic();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.timeUpdateUnix = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pay = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.promotion = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.matchData.push(MatchData.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.agCashout = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.agBank = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.chips = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GoldStatistic {
    return {
      timeUpdateUnix: isSet(object.timeUpdateUnix) ? globalThis.String(object.timeUpdateUnix) : "0",
      pay: isSet(object.pay) ? globalThis.String(object.pay) : "0",
      promotion: isSet(object.promotion) ? globalThis.String(object.promotion) : "0",
      matchData: globalThis.Array.isArray(object?.matchData)
        ? object.matchData.map((e: any) => MatchData.fromJSON(e))
        : [],
      agCashout: isSet(object.agCashout) ? globalThis.String(object.agCashout) : "0",
      agBank: isSet(object.agBank) ? globalThis.String(object.agBank) : "0",
      chips: isSet(object.chips) ? globalThis.String(object.chips) : "0",
    };
  },

  toJSON(message: GoldStatistic): unknown {
    const obj: any = {};
    if (message.timeUpdateUnix !== "0") {
      obj.timeUpdateUnix = message.timeUpdateUnix;
    }
    if (message.pay !== "0") {
      obj.pay = message.pay;
    }
    if (message.promotion !== "0") {
      obj.promotion = message.promotion;
    }
    if (message.matchData?.length) {
      obj.matchData = message.matchData.map((e) => MatchData.toJSON(e));
    }
    if (message.agCashout !== "0") {
      obj.agCashout = message.agCashout;
    }
    if (message.agBank !== "0") {
      obj.agBank = message.agBank;
    }
    if (message.chips !== "0") {
      obj.chips = message.chips;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GoldStatistic>, I>>(base?: I): GoldStatistic {
    return GoldStatistic.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GoldStatistic>, I>>(object: I): GoldStatistic {
    const message = createBaseGoldStatistic();
    message.timeUpdateUnix = object.timeUpdateUnix ?? "0";
    message.pay = object.pay ?? "0";
    message.promotion = object.promotion ?? "0";
    message.matchData = object.matchData?.map((e) => MatchData.fromPartial(e)) || [];
    message.agCashout = object.agCashout ?? "0";
    message.agBank = object.agBank ?? "0";
    message.chips = object.chips ?? "0";
    return message;
  },
};

function createBaseGoldStatisticRequest(): GoldStatisticRequest {
  return { fromUnix: "0", toUnix: "0", limit: "0", offset: "0" };
}

export const GoldStatisticRequest: MessageFns<GoldStatisticRequest> = {
  encode(message: GoldStatisticRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromUnix !== "0") {
      writer.uint32(8).int64(message.fromUnix);
    }
    if (message.toUnix !== "0") {
      writer.uint32(16).int64(message.toUnix);
    }
    if (message.limit !== "0") {
      writer.uint32(24).int64(message.limit);
    }
    if (message.offset !== "0") {
      writer.uint32(32).int64(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GoldStatisticRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGoldStatisticRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fromUnix = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.toUnix = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.offset = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GoldStatisticRequest {
    return {
      fromUnix: isSet(object.fromUnix) ? globalThis.String(object.fromUnix) : "0",
      toUnix: isSet(object.toUnix) ? globalThis.String(object.toUnix) : "0",
      limit: isSet(object.limit) ? globalThis.String(object.limit) : "0",
      offset: isSet(object.offset) ? globalThis.String(object.offset) : "0",
    };
  },

  toJSON(message: GoldStatisticRequest): unknown {
    const obj: any = {};
    if (message.fromUnix !== "0") {
      obj.fromUnix = message.fromUnix;
    }
    if (message.toUnix !== "0") {
      obj.toUnix = message.toUnix;
    }
    if (message.limit !== "0") {
      obj.limit = message.limit;
    }
    if (message.offset !== "0") {
      obj.offset = message.offset;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GoldStatisticRequest>, I>>(base?: I): GoldStatisticRequest {
    return GoldStatisticRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GoldStatisticRequest>, I>>(object: I): GoldStatisticRequest {
    const message = createBaseGoldStatisticRequest();
    message.fromUnix = object.fromUnix ?? "0";
    message.toUnix = object.toUnix ?? "0";
    message.limit = object.limit ?? "0";
    message.offset = object.offset ?? "0";
    return message;
  },
};

function createBaseGoldStatisticResponse(): GoldStatisticResponse {
  return { goldStatistics: [], limit: "0", offset: "0", total: "0" };
}

export const GoldStatisticResponse: MessageFns<GoldStatisticResponse> = {
  encode(message: GoldStatisticResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.goldStatistics) {
      GoldStatistic.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.limit !== "0") {
      writer.uint32(16).int64(message.limit);
    }
    if (message.offset !== "0") {
      writer.uint32(24).int64(message.offset);
    }
    if (message.total !== "0") {
      writer.uint32(32).int64(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GoldStatisticResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGoldStatisticResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.goldStatistics.push(GoldStatistic.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.offset = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.total = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GoldStatisticResponse {
    return {
      goldStatistics: globalThis.Array.isArray(object?.goldStatistics)
        ? object.goldStatistics.map((e: any) => GoldStatistic.fromJSON(e))
        : [],
      limit: isSet(object.limit) ? globalThis.String(object.limit) : "0",
      offset: isSet(object.offset) ? globalThis.String(object.offset) : "0",
      total: isSet(object.total) ? globalThis.String(object.total) : "0",
    };
  },

  toJSON(message: GoldStatisticResponse): unknown {
    const obj: any = {};
    if (message.goldStatistics?.length) {
      obj.goldStatistics = message.goldStatistics.map((e) => GoldStatistic.toJSON(e));
    }
    if (message.limit !== "0") {
      obj.limit = message.limit;
    }
    if (message.offset !== "0") {
      obj.offset = message.offset;
    }
    if (message.total !== "0") {
      obj.total = message.total;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GoldStatisticResponse>, I>>(base?: I): GoldStatisticResponse {
    return GoldStatisticResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GoldStatisticResponse>, I>>(object: I): GoldStatisticResponse {
    const message = createBaseGoldStatisticResponse();
    message.goldStatistics = object.goldStatistics?.map((e) => GoldStatistic.fromPartial(e)) || [];
    message.limit = object.limit ?? "0";
    message.offset = object.offset ?? "0";
    message.total = object.total ?? "0";
    return message;
  },
};

function createBaseUserStatistic(): UserStatistic {
  return {
    totalChipDeposit: "0",
    totalChipWithDraw: "0",
    totalChipWin: "0",
    totalChipWinPrefee: "0",
    totalChipLose: "0",
    totalChipPromotion: "0",
    totalChipSend: "0",
    totalChipRecv: "0",
    coRatio: "0",
    totalChipDeposit3d: "0",
    totalChipWithDraw3d: "0",
    luck: "0",
    userCreateTimeUnix: "0",
    userStatGameHistories: [],
    recvChipStats: [],
    sendChipStats: [],
    userId: "",
  };
}

export const UserStatistic: MessageFns<UserStatistic> = {
  encode(message: UserStatistic, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalChipDeposit !== "0") {
      writer.uint32(8).int64(message.totalChipDeposit);
    }
    if (message.totalChipWithDraw !== "0") {
      writer.uint32(16).int64(message.totalChipWithDraw);
    }
    if (message.totalChipWin !== "0") {
      writer.uint32(24).int64(message.totalChipWin);
    }
    if (message.totalChipWinPrefee !== "0") {
      writer.uint32(32).int64(message.totalChipWinPrefee);
    }
    if (message.totalChipLose !== "0") {
      writer.uint32(40).int64(message.totalChipLose);
    }
    if (message.totalChipPromotion !== "0") {
      writer.uint32(48).int64(message.totalChipPromotion);
    }
    if (message.totalChipSend !== "0") {
      writer.uint32(56).int64(message.totalChipSend);
    }
    if (message.totalChipRecv !== "0") {
      writer.uint32(64).int64(message.totalChipRecv);
    }
    if (message.coRatio !== "0") {
      writer.uint32(72).int64(message.coRatio);
    }
    if (message.totalChipDeposit3d !== "0") {
      writer.uint32(80).int64(message.totalChipDeposit3d);
    }
    if (message.totalChipWithDraw3d !== "0") {
      writer.uint32(88).int64(message.totalChipWithDraw3d);
    }
    if (message.luck !== "0") {
      writer.uint32(96).int64(message.luck);
    }
    if (message.userCreateTimeUnix !== "0") {
      writer.uint32(104).int64(message.userCreateTimeUnix);
    }
    for (const v of message.userStatGameHistories) {
      UserStatGameHistory.encode(v!, writer.uint32(114).fork()).join();
    }
    for (const v of message.recvChipStats) {
      UserTransferGoldStat.encode(v!, writer.uint32(122).fork()).join();
    }
    for (const v of message.sendChipStats) {
      UserTransferGoldStat.encode(v!, writer.uint32(130).fork()).join();
    }
    if (message.userId !== "") {
      writer.uint32(138).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserStatistic {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserStatistic();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalChipDeposit = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalChipWithDraw = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalChipWin = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalChipWinPrefee = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.totalChipLose = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.totalChipPromotion = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.totalChipSend = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.totalChipRecv = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.coRatio = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.totalChipDeposit3d = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.totalChipWithDraw3d = reader.int64().toString();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.luck = reader.int64().toString();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.userCreateTimeUnix = reader.int64().toString();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.userStatGameHistories.push(UserStatGameHistory.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.recvChipStats.push(UserTransferGoldStat.decode(reader, reader.uint32()));
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.sendChipStats.push(UserTransferGoldStat.decode(reader, reader.uint32()));
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserStatistic {
    return {
      totalChipDeposit: isSet(object.totalChipDeposit) ? globalThis.String(object.totalChipDeposit) : "0",
      totalChipWithDraw: isSet(object.totalChipWithDraw) ? globalThis.String(object.totalChipWithDraw) : "0",
      totalChipWin: isSet(object.totalChipWin) ? globalThis.String(object.totalChipWin) : "0",
      totalChipWinPrefee: isSet(object.totalChipWinPrefee) ? globalThis.String(object.totalChipWinPrefee) : "0",
      totalChipLose: isSet(object.totalChipLose) ? globalThis.String(object.totalChipLose) : "0",
      totalChipPromotion: isSet(object.totalChipPromotion) ? globalThis.String(object.totalChipPromotion) : "0",
      totalChipSend: isSet(object.totalChipSend) ? globalThis.String(object.totalChipSend) : "0",
      totalChipRecv: isSet(object.totalChipRecv) ? globalThis.String(object.totalChipRecv) : "0",
      coRatio: isSet(object.coRatio) ? globalThis.String(object.coRatio) : "0",
      totalChipDeposit3d: isSet(object.totalChipDeposit3d) ? globalThis.String(object.totalChipDeposit3d) : "0",
      totalChipWithDraw3d: isSet(object.totalChipWithDraw3d) ? globalThis.String(object.totalChipWithDraw3d) : "0",
      luck: isSet(object.luck) ? globalThis.String(object.luck) : "0",
      userCreateTimeUnix: isSet(object.userCreateTimeUnix) ? globalThis.String(object.userCreateTimeUnix) : "0",
      userStatGameHistories: globalThis.Array.isArray(object?.userStatGameHistories)
        ? object.userStatGameHistories.map((e: any) => UserStatGameHistory.fromJSON(e))
        : [],
      recvChipStats: globalThis.Array.isArray(object?.recvChipStats)
        ? object.recvChipStats.map((e: any) => UserTransferGoldStat.fromJSON(e))
        : [],
      sendChipStats: globalThis.Array.isArray(object?.sendChipStats)
        ? object.sendChipStats.map((e: any) => UserTransferGoldStat.fromJSON(e))
        : [],
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
    };
  },

  toJSON(message: UserStatistic): unknown {
    const obj: any = {};
    if (message.totalChipDeposit !== "0") {
      obj.totalChipDeposit = message.totalChipDeposit;
    }
    if (message.totalChipWithDraw !== "0") {
      obj.totalChipWithDraw = message.totalChipWithDraw;
    }
    if (message.totalChipWin !== "0") {
      obj.totalChipWin = message.totalChipWin;
    }
    if (message.totalChipWinPrefee !== "0") {
      obj.totalChipWinPrefee = message.totalChipWinPrefee;
    }
    if (message.totalChipLose !== "0") {
      obj.totalChipLose = message.totalChipLose;
    }
    if (message.totalChipPromotion !== "0") {
      obj.totalChipPromotion = message.totalChipPromotion;
    }
    if (message.totalChipSend !== "0") {
      obj.totalChipSend = message.totalChipSend;
    }
    if (message.totalChipRecv !== "0") {
      obj.totalChipRecv = message.totalChipRecv;
    }
    if (message.coRatio !== "0") {
      obj.coRatio = message.coRatio;
    }
    if (message.totalChipDeposit3d !== "0") {
      obj.totalChipDeposit3d = message.totalChipDeposit3d;
    }
    if (message.totalChipWithDraw3d !== "0") {
      obj.totalChipWithDraw3d = message.totalChipWithDraw3d;
    }
    if (message.luck !== "0") {
      obj.luck = message.luck;
    }
    if (message.userCreateTimeUnix !== "0") {
      obj.userCreateTimeUnix = message.userCreateTimeUnix;
    }
    if (message.userStatGameHistories?.length) {
      obj.userStatGameHistories = message.userStatGameHistories.map((e) => UserStatGameHistory.toJSON(e));
    }
    if (message.recvChipStats?.length) {
      obj.recvChipStats = message.recvChipStats.map((e) => UserTransferGoldStat.toJSON(e));
    }
    if (message.sendChipStats?.length) {
      obj.sendChipStats = message.sendChipStats.map((e) => UserTransferGoldStat.toJSON(e));
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserStatistic>, I>>(base?: I): UserStatistic {
    return UserStatistic.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserStatistic>, I>>(object: I): UserStatistic {
    const message = createBaseUserStatistic();
    message.totalChipDeposit = object.totalChipDeposit ?? "0";
    message.totalChipWithDraw = object.totalChipWithDraw ?? "0";
    message.totalChipWin = object.totalChipWin ?? "0";
    message.totalChipWinPrefee = object.totalChipWinPrefee ?? "0";
    message.totalChipLose = object.totalChipLose ?? "0";
    message.totalChipPromotion = object.totalChipPromotion ?? "0";
    message.totalChipSend = object.totalChipSend ?? "0";
    message.totalChipRecv = object.totalChipRecv ?? "0";
    message.coRatio = object.coRatio ?? "0";
    message.totalChipDeposit3d = object.totalChipDeposit3d ?? "0";
    message.totalChipWithDraw3d = object.totalChipWithDraw3d ?? "0";
    message.luck = object.luck ?? "0";
    message.userCreateTimeUnix = object.userCreateTimeUnix ?? "0";
    message.userStatGameHistories = object.userStatGameHistories?.map((e) => UserStatGameHistory.fromPartial(e)) || [];
    message.recvChipStats = object.recvChipStats?.map((e) => UserTransferGoldStat.fromPartial(e)) || [];
    message.sendChipStats = object.sendChipStats?.map((e) => UserTransferGoldStat.fromPartial(e)) || [];
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseUserStatisticRequest(): UserStatisticRequest {
  return { userId: "", fromUnix: "0", toUnix: "0", userSid: "0", deviceId: "" };
}

export const UserStatisticRequest: MessageFns<UserStatisticRequest> = {
  encode(message: UserStatisticRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.fromUnix !== "0") {
      writer.uint32(16).int64(message.fromUnix);
    }
    if (message.toUnix !== "0") {
      writer.uint32(24).int64(message.toUnix);
    }
    if (message.userSid !== "0") {
      writer.uint32(32).int64(message.userSid);
    }
    if (message.deviceId !== "") {
      writer.uint32(42).string(message.deviceId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserStatisticRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserStatisticRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.fromUnix = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.toUnix = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.userSid = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.deviceId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserStatisticRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      fromUnix: isSet(object.fromUnix) ? globalThis.String(object.fromUnix) : "0",
      toUnix: isSet(object.toUnix) ? globalThis.String(object.toUnix) : "0",
      userSid: isSet(object.userSid) ? globalThis.String(object.userSid) : "0",
      deviceId: isSet(object.deviceId) ? globalThis.String(object.deviceId) : "",
    };
  },

  toJSON(message: UserStatisticRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.fromUnix !== "0") {
      obj.fromUnix = message.fromUnix;
    }
    if (message.toUnix !== "0") {
      obj.toUnix = message.toUnix;
    }
    if (message.userSid !== "0") {
      obj.userSid = message.userSid;
    }
    if (message.deviceId !== "") {
      obj.deviceId = message.deviceId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserStatisticRequest>, I>>(base?: I): UserStatisticRequest {
    return UserStatisticRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserStatisticRequest>, I>>(object: I): UserStatisticRequest {
    const message = createBaseUserStatisticRequest();
    message.userId = object.userId ?? "";
    message.fromUnix = object.fromUnix ?? "0";
    message.toUnix = object.toUnix ?? "0";
    message.userSid = object.userSid ?? "0";
    message.deviceId = object.deviceId ?? "";
    return message;
  },
};

function createBaseUserStatGameHistory(): UserStatGameHistory {
  return {
    gameId: "0",
    gameName: "",
    totalChipWin: "0",
    totalChipWinPrefee: "0",
    totalChipLost: "0",
    noGameWin: "0",
    noGameLost: "0",
    userId: "",
  };
}

export const UserStatGameHistory: MessageFns<UserStatGameHistory> = {
  encode(message: UserStatGameHistory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gameId !== "0") {
      writer.uint32(8).int64(message.gameId);
    }
    if (message.gameName !== "") {
      writer.uint32(18).string(message.gameName);
    }
    if (message.totalChipWin !== "0") {
      writer.uint32(24).int64(message.totalChipWin);
    }
    if (message.totalChipWinPrefee !== "0") {
      writer.uint32(32).int64(message.totalChipWinPrefee);
    }
    if (message.totalChipLost !== "0") {
      writer.uint32(40).int64(message.totalChipLost);
    }
    if (message.noGameWin !== "0") {
      writer.uint32(48).int64(message.noGameWin);
    }
    if (message.noGameLost !== "0") {
      writer.uint32(56).int64(message.noGameLost);
    }
    if (message.userId !== "") {
      writer.uint32(66).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserStatGameHistory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserStatGameHistory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.gameId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.gameName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalChipWin = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalChipWinPrefee = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.totalChipLost = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.noGameWin = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.noGameLost = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserStatGameHistory {
    return {
      gameId: isSet(object.gameId) ? globalThis.String(object.gameId) : "0",
      gameName: isSet(object.gameName) ? globalThis.String(object.gameName) : "",
      totalChipWin: isSet(object.totalChipWin) ? globalThis.String(object.totalChipWin) : "0",
      totalChipWinPrefee: isSet(object.totalChipWinPrefee) ? globalThis.String(object.totalChipWinPrefee) : "0",
      totalChipLost: isSet(object.totalChipLost) ? globalThis.String(object.totalChipLost) : "0",
      noGameWin: isSet(object.noGameWin) ? globalThis.String(object.noGameWin) : "0",
      noGameLost: isSet(object.noGameLost) ? globalThis.String(object.noGameLost) : "0",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
    };
  },

  toJSON(message: UserStatGameHistory): unknown {
    const obj: any = {};
    if (message.gameId !== "0") {
      obj.gameId = message.gameId;
    }
    if (message.gameName !== "") {
      obj.gameName = message.gameName;
    }
    if (message.totalChipWin !== "0") {
      obj.totalChipWin = message.totalChipWin;
    }
    if (message.totalChipWinPrefee !== "0") {
      obj.totalChipWinPrefee = message.totalChipWinPrefee;
    }
    if (message.totalChipLost !== "0") {
      obj.totalChipLost = message.totalChipLost;
    }
    if (message.noGameWin !== "0") {
      obj.noGameWin = message.noGameWin;
    }
    if (message.noGameLost !== "0") {
      obj.noGameLost = message.noGameLost;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserStatGameHistory>, I>>(base?: I): UserStatGameHistory {
    return UserStatGameHistory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserStatGameHistory>, I>>(object: I): UserStatGameHistory {
    const message = createBaseUserStatGameHistory();
    message.gameId = object.gameId ?? "0";
    message.gameName = object.gameName ?? "";
    message.totalChipWin = object.totalChipWin ?? "0";
    message.totalChipWinPrefee = object.totalChipWinPrefee ?? "0";
    message.totalChipLost = object.totalChipLost ?? "0";
    message.noGameWin = object.noGameWin ?? "0";
    message.noGameLost = object.noGameLost ?? "0";
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseUserTransferGoldStat(): UserTransferGoldStat {
  return { userSendId: "", userSendName: "", userRecvId: "", userRecvName: "", chip: "0" };
}

export const UserTransferGoldStat: MessageFns<UserTransferGoldStat> = {
  encode(message: UserTransferGoldStat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userSendId !== "") {
      writer.uint32(10).string(message.userSendId);
    }
    if (message.userSendName !== "") {
      writer.uint32(18).string(message.userSendName);
    }
    if (message.userRecvId !== "") {
      writer.uint32(26).string(message.userRecvId);
    }
    if (message.userRecvName !== "") {
      writer.uint32(34).string(message.userRecvName);
    }
    if (message.chip !== "0") {
      writer.uint32(40).int64(message.chip);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserTransferGoldStat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserTransferGoldStat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userSendId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userSendName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userRecvId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userRecvName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.chip = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserTransferGoldStat {
    return {
      userSendId: isSet(object.userSendId) ? globalThis.String(object.userSendId) : "",
      userSendName: isSet(object.userSendName) ? globalThis.String(object.userSendName) : "",
      userRecvId: isSet(object.userRecvId) ? globalThis.String(object.userRecvId) : "",
      userRecvName: isSet(object.userRecvName) ? globalThis.String(object.userRecvName) : "",
      chip: isSet(object.chip) ? globalThis.String(object.chip) : "0",
    };
  },

  toJSON(message: UserTransferGoldStat): unknown {
    const obj: any = {};
    if (message.userSendId !== "") {
      obj.userSendId = message.userSendId;
    }
    if (message.userSendName !== "") {
      obj.userSendName = message.userSendName;
    }
    if (message.userRecvId !== "") {
      obj.userRecvId = message.userRecvId;
    }
    if (message.userRecvName !== "") {
      obj.userRecvName = message.userRecvName;
    }
    if (message.chip !== "0") {
      obj.chip = message.chip;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserTransferGoldStat>, I>>(base?: I): UserTransferGoldStat {
    return UserTransferGoldStat.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserTransferGoldStat>, I>>(object: I): UserTransferGoldStat {
    const message = createBaseUserTransferGoldStat();
    message.userSendId = object.userSendId ?? "";
    message.userSendName = object.userSendName ?? "";
    message.userRecvId = object.userRecvId ?? "";
    message.userRecvName = object.userRecvName ?? "";
    message.chip = object.chip ?? "0";
    return message;
  },
};

function createBaseUserInfo(): UserInfo {
  return { profile: undefined, totalIn: "0", totalOut: "0" };
}

export const UserInfo: MessageFns<UserInfo> = {
  encode(message: UserInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.profile !== undefined) {
      Profile.encode(message.profile, writer.uint32(10).fork()).join();
    }
    if (message.totalIn !== "0") {
      writer.uint32(16).int64(message.totalIn);
    }
    if (message.totalOut !== "0") {
      writer.uint32(24).int64(message.totalOut);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.profile = Profile.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalIn = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalOut = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserInfo {
    return {
      profile: isSet(object.profile) ? Profile.fromJSON(object.profile) : undefined,
      totalIn: isSet(object.totalIn) ? globalThis.String(object.totalIn) : "0",
      totalOut: isSet(object.totalOut) ? globalThis.String(object.totalOut) : "0",
    };
  },

  toJSON(message: UserInfo): unknown {
    const obj: any = {};
    if (message.profile !== undefined) {
      obj.profile = Profile.toJSON(message.profile);
    }
    if (message.totalIn !== "0") {
      obj.totalIn = message.totalIn;
    }
    if (message.totalOut !== "0") {
      obj.totalOut = message.totalOut;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserInfo>, I>>(base?: I): UserInfo {
    return UserInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserInfo>, I>>(object: I): UserInfo {
    const message = createBaseUserInfo();
    message.profile = (object.profile !== undefined && object.profile !== null)
      ? Profile.fromPartial(object.profile)
      : undefined;
    message.totalIn = object.totalIn ?? "0";
    message.totalOut = object.totalOut ?? "0";
    return message;
  },
};

function createBaseUserInfoResponse(): UserInfoResponse {
  return { userInfos: [], total: "0", deviceId: "", totalIn: "0", totalOut: "0", totalLock: "0" };
}

export const UserInfoResponse: MessageFns<UserInfoResponse> = {
  encode(message: UserInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.userInfos) {
      UserInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== "0") {
      writer.uint32(16).int64(message.total);
    }
    if (message.deviceId !== "") {
      writer.uint32(26).string(message.deviceId);
    }
    if (message.totalIn !== "0") {
      writer.uint32(32).int64(message.totalIn);
    }
    if (message.totalOut !== "0") {
      writer.uint32(40).int64(message.totalOut);
    }
    if (message.totalLock !== "0") {
      writer.uint32(48).int64(message.totalLock);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userInfos.push(UserInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deviceId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalIn = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.totalOut = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.totalLock = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserInfoResponse {
    return {
      userInfos: globalThis.Array.isArray(object?.userInfos)
        ? object.userInfos.map((e: any) => UserInfo.fromJSON(e))
        : [],
      total: isSet(object.total) ? globalThis.String(object.total) : "0",
      deviceId: isSet(object.deviceId) ? globalThis.String(object.deviceId) : "",
      totalIn: isSet(object.totalIn) ? globalThis.String(object.totalIn) : "0",
      totalOut: isSet(object.totalOut) ? globalThis.String(object.totalOut) : "0",
      totalLock: isSet(object.totalLock) ? globalThis.String(object.totalLock) : "0",
    };
  },

  toJSON(message: UserInfoResponse): unknown {
    const obj: any = {};
    if (message.userInfos?.length) {
      obj.userInfos = message.userInfos.map((e) => UserInfo.toJSON(e));
    }
    if (message.total !== "0") {
      obj.total = message.total;
    }
    if (message.deviceId !== "") {
      obj.deviceId = message.deviceId;
    }
    if (message.totalIn !== "0") {
      obj.totalIn = message.totalIn;
    }
    if (message.totalOut !== "0") {
      obj.totalOut = message.totalOut;
    }
    if (message.totalLock !== "0") {
      obj.totalLock = message.totalLock;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserInfoResponse>, I>>(base?: I): UserInfoResponse {
    return UserInfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserInfoResponse>, I>>(object: I): UserInfoResponse {
    const message = createBaseUserInfoResponse();
    message.userInfos = object.userInfos?.map((e) => UserInfo.fromPartial(e)) || [];
    message.total = object.total ?? "0";
    message.deviceId = object.deviceId ?? "";
    message.totalIn = object.totalIn ?? "0";
    message.totalOut = object.totalOut ?? "0";
    message.totalLock = object.totalLock ?? "0";
    return message;
  },
};

function createBaseCashOut(): CashOut {
  return { userId: "", userName: "", ci: "0", cio: "0", co: "0", coo: "0", luckyPercent: "0", userSid: "0" };
}

export const CashOut: MessageFns<CashOut> = {
  encode(message: CashOut, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.userName !== "") {
      writer.uint32(18).string(message.userName);
    }
    if (message.ci !== "0") {
      writer.uint32(24).int64(message.ci);
    }
    if (message.cio !== "0") {
      writer.uint32(32).int64(message.cio);
    }
    if (message.co !== "0") {
      writer.uint32(40).int64(message.co);
    }
    if (message.coo !== "0") {
      writer.uint32(48).int64(message.coo);
    }
    if (message.luckyPercent !== "0") {
      writer.uint32(56).int64(message.luckyPercent);
    }
    if (message.userSid !== "0") {
      writer.uint32(64).int64(message.userSid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CashOut {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCashOut();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.ci = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.cio = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.co = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.coo = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.luckyPercent = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.userSid = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CashOut {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      userName: isSet(object.userName) ? globalThis.String(object.userName) : "",
      ci: isSet(object.ci) ? globalThis.String(object.ci) : "0",
      cio: isSet(object.cio) ? globalThis.String(object.cio) : "0",
      co: isSet(object.co) ? globalThis.String(object.co) : "0",
      coo: isSet(object.coo) ? globalThis.String(object.coo) : "0",
      luckyPercent: isSet(object.luckyPercent) ? globalThis.String(object.luckyPercent) : "0",
      userSid: isSet(object.userSid) ? globalThis.String(object.userSid) : "0",
    };
  },

  toJSON(message: CashOut): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.userName !== "") {
      obj.userName = message.userName;
    }
    if (message.ci !== "0") {
      obj.ci = message.ci;
    }
    if (message.cio !== "0") {
      obj.cio = message.cio;
    }
    if (message.co !== "0") {
      obj.co = message.co;
    }
    if (message.coo !== "0") {
      obj.coo = message.coo;
    }
    if (message.luckyPercent !== "0") {
      obj.luckyPercent = message.luckyPercent;
    }
    if (message.userSid !== "0") {
      obj.userSid = message.userSid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CashOut>, I>>(base?: I): CashOut {
    return CashOut.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CashOut>, I>>(object: I): CashOut {
    const message = createBaseCashOut();
    message.userId = object.userId ?? "";
    message.userName = object.userName ?? "";
    message.ci = object.ci ?? "0";
    message.cio = object.cio ?? "0";
    message.co = object.co ?? "0";
    message.coo = object.coo ?? "0";
    message.luckyPercent = object.luckyPercent ?? "0";
    message.userSid = object.userSid ?? "0";
    return message;
  },
};

function createBaseTopCashOut(): TopCashOut {
  return { cashouts: [], fromUnix: "0", toUnix: "0", limit: "0", offset: "0", total: "0" };
}

export const TopCashOut: MessageFns<TopCashOut> = {
  encode(message: TopCashOut, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.cashouts) {
      CashOut.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.fromUnix !== "0") {
      writer.uint32(16).int64(message.fromUnix);
    }
    if (message.toUnix !== "0") {
      writer.uint32(24).int64(message.toUnix);
    }
    if (message.limit !== "0") {
      writer.uint32(32).int64(message.limit);
    }
    if (message.offset !== "0") {
      writer.uint32(40).int64(message.offset);
    }
    if (message.total !== "0") {
      writer.uint32(48).int64(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TopCashOut {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopCashOut();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cashouts.push(CashOut.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.fromUnix = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.toUnix = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.limit = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.offset = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.total = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopCashOut {
    return {
      cashouts: globalThis.Array.isArray(object?.cashouts) ? object.cashouts.map((e: any) => CashOut.fromJSON(e)) : [],
      fromUnix: isSet(object.fromUnix) ? globalThis.String(object.fromUnix) : "0",
      toUnix: isSet(object.toUnix) ? globalThis.String(object.toUnix) : "0",
      limit: isSet(object.limit) ? globalThis.String(object.limit) : "0",
      offset: isSet(object.offset) ? globalThis.String(object.offset) : "0",
      total: isSet(object.total) ? globalThis.String(object.total) : "0",
    };
  },

  toJSON(message: TopCashOut): unknown {
    const obj: any = {};
    if (message.cashouts?.length) {
      obj.cashouts = message.cashouts.map((e) => CashOut.toJSON(e));
    }
    if (message.fromUnix !== "0") {
      obj.fromUnix = message.fromUnix;
    }
    if (message.toUnix !== "0") {
      obj.toUnix = message.toUnix;
    }
    if (message.limit !== "0") {
      obj.limit = message.limit;
    }
    if (message.offset !== "0") {
      obj.offset = message.offset;
    }
    if (message.total !== "0") {
      obj.total = message.total;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TopCashOut>, I>>(base?: I): TopCashOut {
    return TopCashOut.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TopCashOut>, I>>(object: I): TopCashOut {
    const message = createBaseTopCashOut();
    message.cashouts = object.cashouts?.map((e) => CashOut.fromPartial(e)) || [];
    message.fromUnix = object.fromUnix ?? "0";
    message.toUnix = object.toUnix ?? "0";
    message.limit = object.limit ?? "0";
    message.offset = object.offset ?? "0";
    message.total = object.total ?? "0";
    return message;
  },
};

function createBaseVip(): Vip {
  return {
    userId: "",
    userName: "",
    cio: "0",
    totalChip: "0",
    lastLoginTimeUnix: "0",
    createdTimeUnix: "0",
    refGame: "",
    ci: "0",
    co: "0",
    ci2d: "0",
    co2d: "0",
    luckyPercent: "0",
    isBanned: false,
    isOnline: false,
    totalIn: "0",
    totalOut: "0",
    userSid: "0",
  };
}

export const Vip: MessageFns<Vip> = {
  encode(message: Vip, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.userName !== "") {
      writer.uint32(18).string(message.userName);
    }
    if (message.cio !== "0") {
      writer.uint32(24).int64(message.cio);
    }
    if (message.totalChip !== "0") {
      writer.uint32(32).int64(message.totalChip);
    }
    if (message.lastLoginTimeUnix !== "0") {
      writer.uint32(40).int64(message.lastLoginTimeUnix);
    }
    if (message.createdTimeUnix !== "0") {
      writer.uint32(48).int64(message.createdTimeUnix);
    }
    if (message.refGame !== "") {
      writer.uint32(58).string(message.refGame);
    }
    if (message.ci !== "0") {
      writer.uint32(64).int64(message.ci);
    }
    if (message.co !== "0") {
      writer.uint32(72).int64(message.co);
    }
    if (message.ci2d !== "0") {
      writer.uint32(80).int64(message.ci2d);
    }
    if (message.co2d !== "0") {
      writer.uint32(88).int64(message.co2d);
    }
    if (message.luckyPercent !== "0") {
      writer.uint32(96).int64(message.luckyPercent);
    }
    if (message.isBanned !== false) {
      writer.uint32(104).bool(message.isBanned);
    }
    if (message.isOnline !== false) {
      writer.uint32(112).bool(message.isOnline);
    }
    if (message.totalIn !== "0") {
      writer.uint32(120).int64(message.totalIn);
    }
    if (message.totalOut !== "0") {
      writer.uint32(128).int64(message.totalOut);
    }
    if (message.userSid !== "0") {
      writer.uint32(136).int64(message.userSid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Vip {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVip();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.cio = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalChip = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.lastLoginTimeUnix = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.createdTimeUnix = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.refGame = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.ci = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.co = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.ci2d = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.co2d = reader.int64().toString();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.luckyPercent = reader.int64().toString();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.isBanned = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.isOnline = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.totalIn = reader.int64().toString();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.totalOut = reader.int64().toString();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.userSid = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Vip {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      userName: isSet(object.userName) ? globalThis.String(object.userName) : "",
      cio: isSet(object.cio) ? globalThis.String(object.cio) : "0",
      totalChip: isSet(object.totalChip) ? globalThis.String(object.totalChip) : "0",
      lastLoginTimeUnix: isSet(object.lastLoginTimeUnix) ? globalThis.String(object.lastLoginTimeUnix) : "0",
      createdTimeUnix: isSet(object.createdTimeUnix) ? globalThis.String(object.createdTimeUnix) : "0",
      refGame: isSet(object.refGame) ? globalThis.String(object.refGame) : "",
      ci: isSet(object.ci) ? globalThis.String(object.ci) : "0",
      co: isSet(object.co) ? globalThis.String(object.co) : "0",
      ci2d: isSet(object.ci2d) ? globalThis.String(object.ci2d) : "0",
      co2d: isSet(object.co2d) ? globalThis.String(object.co2d) : "0",
      luckyPercent: isSet(object.luckyPercent) ? globalThis.String(object.luckyPercent) : "0",
      isBanned: isSet(object.isBanned) ? globalThis.Boolean(object.isBanned) : false,
      isOnline: isSet(object.isOnline) ? globalThis.Boolean(object.isOnline) : false,
      totalIn: isSet(object.totalIn) ? globalThis.String(object.totalIn) : "0",
      totalOut: isSet(object.totalOut) ? globalThis.String(object.totalOut) : "0",
      userSid: isSet(object.userSid) ? globalThis.String(object.userSid) : "0",
    };
  },

  toJSON(message: Vip): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.userName !== "") {
      obj.userName = message.userName;
    }
    if (message.cio !== "0") {
      obj.cio = message.cio;
    }
    if (message.totalChip !== "0") {
      obj.totalChip = message.totalChip;
    }
    if (message.lastLoginTimeUnix !== "0") {
      obj.lastLoginTimeUnix = message.lastLoginTimeUnix;
    }
    if (message.createdTimeUnix !== "0") {
      obj.createdTimeUnix = message.createdTimeUnix;
    }
    if (message.refGame !== "") {
      obj.refGame = message.refGame;
    }
    if (message.ci !== "0") {
      obj.ci = message.ci;
    }
    if (message.co !== "0") {
      obj.co = message.co;
    }
    if (message.ci2d !== "0") {
      obj.ci2d = message.ci2d;
    }
    if (message.co2d !== "0") {
      obj.co2d = message.co2d;
    }
    if (message.luckyPercent !== "0") {
      obj.luckyPercent = message.luckyPercent;
    }
    if (message.isBanned !== false) {
      obj.isBanned = message.isBanned;
    }
    if (message.isOnline !== false) {
      obj.isOnline = message.isOnline;
    }
    if (message.totalIn !== "0") {
      obj.totalIn = message.totalIn;
    }
    if (message.totalOut !== "0") {
      obj.totalOut = message.totalOut;
    }
    if (message.userSid !== "0") {
      obj.userSid = message.userSid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Vip>, I>>(base?: I): Vip {
    return Vip.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Vip>, I>>(object: I): Vip {
    const message = createBaseVip();
    message.userId = object.userId ?? "";
    message.userName = object.userName ?? "";
    message.cio = object.cio ?? "0";
    message.totalChip = object.totalChip ?? "0";
    message.lastLoginTimeUnix = object.lastLoginTimeUnix ?? "0";
    message.createdTimeUnix = object.createdTimeUnix ?? "0";
    message.refGame = object.refGame ?? "";
    message.ci = object.ci ?? "0";
    message.co = object.co ?? "0";
    message.ci2d = object.ci2d ?? "0";
    message.co2d = object.co2d ?? "0";
    message.luckyPercent = object.luckyPercent ?? "0";
    message.isBanned = object.isBanned ?? false;
    message.isOnline = object.isOnline ?? false;
    message.totalIn = object.totalIn ?? "0";
    message.totalOut = object.totalOut ?? "0";
    message.userSid = object.userSid ?? "0";
    return message;
  },
};

function createBaseTopVip(): TopVip {
  return { vips: [], fromUnix: "0", toUnix: "0", limit: "0", offset: "0", refGame: "", total: "0" };
}

export const TopVip: MessageFns<TopVip> = {
  encode(message: TopVip, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.vips) {
      Vip.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.fromUnix !== "0") {
      writer.uint32(16).int64(message.fromUnix);
    }
    if (message.toUnix !== "0") {
      writer.uint32(24).int64(message.toUnix);
    }
    if (message.limit !== "0") {
      writer.uint32(32).int64(message.limit);
    }
    if (message.offset !== "0") {
      writer.uint32(40).int64(message.offset);
    }
    if (message.refGame !== "") {
      writer.uint32(50).string(message.refGame);
    }
    if (message.total !== "0") {
      writer.uint32(56).int64(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TopVip {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopVip();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.vips.push(Vip.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.fromUnix = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.toUnix = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.limit = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.offset = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.refGame = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.total = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopVip {
    return {
      vips: globalThis.Array.isArray(object?.vips) ? object.vips.map((e: any) => Vip.fromJSON(e)) : [],
      fromUnix: isSet(object.fromUnix) ? globalThis.String(object.fromUnix) : "0",
      toUnix: isSet(object.toUnix) ? globalThis.String(object.toUnix) : "0",
      limit: isSet(object.limit) ? globalThis.String(object.limit) : "0",
      offset: isSet(object.offset) ? globalThis.String(object.offset) : "0",
      refGame: isSet(object.refGame) ? globalThis.String(object.refGame) : "",
      total: isSet(object.total) ? globalThis.String(object.total) : "0",
    };
  },

  toJSON(message: TopVip): unknown {
    const obj: any = {};
    if (message.vips?.length) {
      obj.vips = message.vips.map((e) => Vip.toJSON(e));
    }
    if (message.fromUnix !== "0") {
      obj.fromUnix = message.fromUnix;
    }
    if (message.toUnix !== "0") {
      obj.toUnix = message.toUnix;
    }
    if (message.limit !== "0") {
      obj.limit = message.limit;
    }
    if (message.offset !== "0") {
      obj.offset = message.offset;
    }
    if (message.refGame !== "") {
      obj.refGame = message.refGame;
    }
    if (message.total !== "0") {
      obj.total = message.total;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TopVip>, I>>(base?: I): TopVip {
    return TopVip.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TopVip>, I>>(object: I): TopVip {
    const message = createBaseTopVip();
    message.vips = object.vips?.map((e) => Vip.fromPartial(e)) || [];
    message.fromUnix = object.fromUnix ?? "0";
    message.toUnix = object.toUnix ?? "0";
    message.limit = object.limit ?? "0";
    message.offset = object.offset ?? "0";
    message.refGame = object.refGame ?? "";
    message.total = object.total ?? "0";
    return message;
  },
};

function createBaseWin(): Win {
  return {
    userId: "",
    userName: "",
    vip: "0",
    gold: "0",
    ag: "0",
    agWin: "0",
    co: "0",
    ci: "0",
    coRate: "0",
    luckyPercent: "0",
    userSid: "0",
  };
}

export const Win: MessageFns<Win> = {
  encode(message: Win, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.userName !== "") {
      writer.uint32(18).string(message.userName);
    }
    if (message.vip !== "0") {
      writer.uint32(24).int64(message.vip);
    }
    if (message.gold !== "0") {
      writer.uint32(32).int64(message.gold);
    }
    if (message.ag !== "0") {
      writer.uint32(40).int64(message.ag);
    }
    if (message.agWin !== "0") {
      writer.uint32(48).int64(message.agWin);
    }
    if (message.co !== "0") {
      writer.uint32(56).int64(message.co);
    }
    if (message.ci !== "0") {
      writer.uint32(64).int64(message.ci);
    }
    if (message.coRate !== "0") {
      writer.uint32(72).int64(message.coRate);
    }
    if (message.luckyPercent !== "0") {
      writer.uint32(80).int64(message.luckyPercent);
    }
    if (message.userSid !== "0") {
      writer.uint32(88).int64(message.userSid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Win {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.vip = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.gold = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.ag = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.agWin = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.co = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.ci = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.coRate = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.luckyPercent = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.userSid = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Win {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      userName: isSet(object.userName) ? globalThis.String(object.userName) : "",
      vip: isSet(object.vip) ? globalThis.String(object.vip) : "0",
      gold: isSet(object.gold) ? globalThis.String(object.gold) : "0",
      ag: isSet(object.ag) ? globalThis.String(object.ag) : "0",
      agWin: isSet(object.agWin) ? globalThis.String(object.agWin) : "0",
      co: isSet(object.co) ? globalThis.String(object.co) : "0",
      ci: isSet(object.ci) ? globalThis.String(object.ci) : "0",
      coRate: isSet(object.coRate) ? globalThis.String(object.coRate) : "0",
      luckyPercent: isSet(object.luckyPercent) ? globalThis.String(object.luckyPercent) : "0",
      userSid: isSet(object.userSid) ? globalThis.String(object.userSid) : "0",
    };
  },

  toJSON(message: Win): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.userName !== "") {
      obj.userName = message.userName;
    }
    if (message.vip !== "0") {
      obj.vip = message.vip;
    }
    if (message.gold !== "0") {
      obj.gold = message.gold;
    }
    if (message.ag !== "0") {
      obj.ag = message.ag;
    }
    if (message.agWin !== "0") {
      obj.agWin = message.agWin;
    }
    if (message.co !== "0") {
      obj.co = message.co;
    }
    if (message.ci !== "0") {
      obj.ci = message.ci;
    }
    if (message.coRate !== "0") {
      obj.coRate = message.coRate;
    }
    if (message.luckyPercent !== "0") {
      obj.luckyPercent = message.luckyPercent;
    }
    if (message.userSid !== "0") {
      obj.userSid = message.userSid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Win>, I>>(base?: I): Win {
    return Win.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Win>, I>>(object: I): Win {
    const message = createBaseWin();
    message.userId = object.userId ?? "";
    message.userName = object.userName ?? "";
    message.vip = object.vip ?? "0";
    message.gold = object.gold ?? "0";
    message.ag = object.ag ?? "0";
    message.agWin = object.agWin ?? "0";
    message.co = object.co ?? "0";
    message.ci = object.ci ?? "0";
    message.coRate = object.coRate ?? "0";
    message.luckyPercent = object.luckyPercent ?? "0";
    message.userSid = object.userSid ?? "0";
    return message;
  },
};

function createBaseTopWin(): TopWin {
  return { wins: [], fromUnix: "0", toUnix: "0", limit: "0", offset: "0", refGame: "", total: "0", gameId: "0" };
}

export const TopWin: MessageFns<TopWin> = {
  encode(message: TopWin, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.wins) {
      Win.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.fromUnix !== "0") {
      writer.uint32(16).int64(message.fromUnix);
    }
    if (message.toUnix !== "0") {
      writer.uint32(24).int64(message.toUnix);
    }
    if (message.limit !== "0") {
      writer.uint32(32).int64(message.limit);
    }
    if (message.offset !== "0") {
      writer.uint32(40).int64(message.offset);
    }
    if (message.refGame !== "") {
      writer.uint32(50).string(message.refGame);
    }
    if (message.total !== "0") {
      writer.uint32(56).int64(message.total);
    }
    if (message.gameId !== "0") {
      writer.uint32(64).int64(message.gameId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TopWin {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopWin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.wins.push(Win.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.fromUnix = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.toUnix = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.limit = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.offset = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.refGame = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.total = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.gameId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopWin {
    return {
      wins: globalThis.Array.isArray(object?.wins) ? object.wins.map((e: any) => Win.fromJSON(e)) : [],
      fromUnix: isSet(object.fromUnix) ? globalThis.String(object.fromUnix) : "0",
      toUnix: isSet(object.toUnix) ? globalThis.String(object.toUnix) : "0",
      limit: isSet(object.limit) ? globalThis.String(object.limit) : "0",
      offset: isSet(object.offset) ? globalThis.String(object.offset) : "0",
      refGame: isSet(object.refGame) ? globalThis.String(object.refGame) : "",
      total: isSet(object.total) ? globalThis.String(object.total) : "0",
      gameId: isSet(object.gameId) ? globalThis.String(object.gameId) : "0",
    };
  },

  toJSON(message: TopWin): unknown {
    const obj: any = {};
    if (message.wins?.length) {
      obj.wins = message.wins.map((e) => Win.toJSON(e));
    }
    if (message.fromUnix !== "0") {
      obj.fromUnix = message.fromUnix;
    }
    if (message.toUnix !== "0") {
      obj.toUnix = message.toUnix;
    }
    if (message.limit !== "0") {
      obj.limit = message.limit;
    }
    if (message.offset !== "0") {
      obj.offset = message.offset;
    }
    if (message.refGame !== "") {
      obj.refGame = message.refGame;
    }
    if (message.total !== "0") {
      obj.total = message.total;
    }
    if (message.gameId !== "0") {
      obj.gameId = message.gameId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TopWin>, I>>(base?: I): TopWin {
    return TopWin.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TopWin>, I>>(object: I): TopWin {
    const message = createBaseTopWin();
    message.wins = object.wins?.map((e) => Win.fromPartial(e)) || [];
    message.fromUnix = object.fromUnix ?? "0";
    message.toUnix = object.toUnix ?? "0";
    message.limit = object.limit ?? "0";
    message.offset = object.offset ?? "0";
    message.refGame = object.refGame ?? "";
    message.total = object.total ?? "0";
    message.gameId = object.gameId ?? "0";
    return message;
  },
};

function createBaseLost(): Lost {
  return {
    userId: "",
    userName: "",
    vip: "0",
    gold: "0",
    ag: "0",
    agLost: "0",
    co: "0",
    ci: "0",
    coRate: "0",
    luckyPercent: "0",
    userSid: "0",
  };
}

export const Lost: MessageFns<Lost> = {
  encode(message: Lost, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.userName !== "") {
      writer.uint32(18).string(message.userName);
    }
    if (message.vip !== "0") {
      writer.uint32(24).int64(message.vip);
    }
    if (message.gold !== "0") {
      writer.uint32(32).int64(message.gold);
    }
    if (message.ag !== "0") {
      writer.uint32(40).int64(message.ag);
    }
    if (message.agLost !== "0") {
      writer.uint32(48).int64(message.agLost);
    }
    if (message.co !== "0") {
      writer.uint32(56).int64(message.co);
    }
    if (message.ci !== "0") {
      writer.uint32(64).int64(message.ci);
    }
    if (message.coRate !== "0") {
      writer.uint32(72).int64(message.coRate);
    }
    if (message.luckyPercent !== "0") {
      writer.uint32(80).int64(message.luckyPercent);
    }
    if (message.userSid !== "0") {
      writer.uint32(88).int64(message.userSid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Lost {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLost();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.vip = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.gold = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.ag = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.agLost = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.co = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.ci = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.coRate = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.luckyPercent = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.userSid = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Lost {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      userName: isSet(object.userName) ? globalThis.String(object.userName) : "",
      vip: isSet(object.vip) ? globalThis.String(object.vip) : "0",
      gold: isSet(object.gold) ? globalThis.String(object.gold) : "0",
      ag: isSet(object.ag) ? globalThis.String(object.ag) : "0",
      agLost: isSet(object.agLost) ? globalThis.String(object.agLost) : "0",
      co: isSet(object.co) ? globalThis.String(object.co) : "0",
      ci: isSet(object.ci) ? globalThis.String(object.ci) : "0",
      coRate: isSet(object.coRate) ? globalThis.String(object.coRate) : "0",
      luckyPercent: isSet(object.luckyPercent) ? globalThis.String(object.luckyPercent) : "0",
      userSid: isSet(object.userSid) ? globalThis.String(object.userSid) : "0",
    };
  },

  toJSON(message: Lost): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.userName !== "") {
      obj.userName = message.userName;
    }
    if (message.vip !== "0") {
      obj.vip = message.vip;
    }
    if (message.gold !== "0") {
      obj.gold = message.gold;
    }
    if (message.ag !== "0") {
      obj.ag = message.ag;
    }
    if (message.agLost !== "0") {
      obj.agLost = message.agLost;
    }
    if (message.co !== "0") {
      obj.co = message.co;
    }
    if (message.ci !== "0") {
      obj.ci = message.ci;
    }
    if (message.coRate !== "0") {
      obj.coRate = message.coRate;
    }
    if (message.luckyPercent !== "0") {
      obj.luckyPercent = message.luckyPercent;
    }
    if (message.userSid !== "0") {
      obj.userSid = message.userSid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Lost>, I>>(base?: I): Lost {
    return Lost.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Lost>, I>>(object: I): Lost {
    const message = createBaseLost();
    message.userId = object.userId ?? "";
    message.userName = object.userName ?? "";
    message.vip = object.vip ?? "0";
    message.gold = object.gold ?? "0";
    message.ag = object.ag ?? "0";
    message.agLost = object.agLost ?? "0";
    message.co = object.co ?? "0";
    message.ci = object.ci ?? "0";
    message.coRate = object.coRate ?? "0";
    message.luckyPercent = object.luckyPercent ?? "0";
    message.userSid = object.userSid ?? "0";
    return message;
  },
};

function createBaseTopLost(): TopLost {
  return { losts: [], fromUnix: "0", toUnix: "0", limit: "0", offset: "0", refGame: "", total: "0", gameId: "0" };
}

export const TopLost: MessageFns<TopLost> = {
  encode(message: TopLost, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.losts) {
      Lost.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.fromUnix !== "0") {
      writer.uint32(16).int64(message.fromUnix);
    }
    if (message.toUnix !== "0") {
      writer.uint32(24).int64(message.toUnix);
    }
    if (message.limit !== "0") {
      writer.uint32(32).int64(message.limit);
    }
    if (message.offset !== "0") {
      writer.uint32(40).int64(message.offset);
    }
    if (message.refGame !== "") {
      writer.uint32(50).string(message.refGame);
    }
    if (message.total !== "0") {
      writer.uint32(56).int64(message.total);
    }
    if (message.gameId !== "0") {
      writer.uint32(64).int64(message.gameId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TopLost {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopLost();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.losts.push(Lost.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.fromUnix = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.toUnix = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.limit = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.offset = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.refGame = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.total = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.gameId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopLost {
    return {
      losts: globalThis.Array.isArray(object?.losts) ? object.losts.map((e: any) => Lost.fromJSON(e)) : [],
      fromUnix: isSet(object.fromUnix) ? globalThis.String(object.fromUnix) : "0",
      toUnix: isSet(object.toUnix) ? globalThis.String(object.toUnix) : "0",
      limit: isSet(object.limit) ? globalThis.String(object.limit) : "0",
      offset: isSet(object.offset) ? globalThis.String(object.offset) : "0",
      refGame: isSet(object.refGame) ? globalThis.String(object.refGame) : "",
      total: isSet(object.total) ? globalThis.String(object.total) : "0",
      gameId: isSet(object.gameId) ? globalThis.String(object.gameId) : "0",
    };
  },

  toJSON(message: TopLost): unknown {
    const obj: any = {};
    if (message.losts?.length) {
      obj.losts = message.losts.map((e) => Lost.toJSON(e));
    }
    if (message.fromUnix !== "0") {
      obj.fromUnix = message.fromUnix;
    }
    if (message.toUnix !== "0") {
      obj.toUnix = message.toUnix;
    }
    if (message.limit !== "0") {
      obj.limit = message.limit;
    }
    if (message.offset !== "0") {
      obj.offset = message.offset;
    }
    if (message.refGame !== "") {
      obj.refGame = message.refGame;
    }
    if (message.total !== "0") {
      obj.total = message.total;
    }
    if (message.gameId !== "0") {
      obj.gameId = message.gameId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TopLost>, I>>(base?: I): TopLost {
    return TopLost.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TopLost>, I>>(object: I): TopLost {
    const message = createBaseTopLost();
    message.losts = object.losts?.map((e) => Lost.fromPartial(e)) || [];
    message.fromUnix = object.fromUnix ?? "0";
    message.toUnix = object.toUnix ?? "0";
    message.limit = object.limit ?? "0";
    message.offset = object.offset ?? "0";
    message.refGame = object.refGame ?? "";
    message.total = object.total ?? "0";
    message.gameId = object.gameId ?? "0";
    return message;
  },
};

function createBaseTransactionRequest(): TransactionRequest {
  return { userSid: "0", fromUnix: "0", toUnix: "0", limit: "0", offset: "0" };
}

export const TransactionRequest: MessageFns<TransactionRequest> = {
  encode(message: TransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userSid !== "0") {
      writer.uint32(8).int64(message.userSid);
    }
    if (message.fromUnix !== "0") {
      writer.uint32(16).int64(message.fromUnix);
    }
    if (message.toUnix !== "0") {
      writer.uint32(24).int64(message.toUnix);
    }
    if (message.limit !== "0") {
      writer.uint32(32).int64(message.limit);
    }
    if (message.offset !== "0") {
      writer.uint32(40).int64(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userSid = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.fromUnix = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.toUnix = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.limit = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.offset = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionRequest {
    return {
      userSid: isSet(object.userSid) ? globalThis.String(object.userSid) : "0",
      fromUnix: isSet(object.fromUnix) ? globalThis.String(object.fromUnix) : "0",
      toUnix: isSet(object.toUnix) ? globalThis.String(object.toUnix) : "0",
      limit: isSet(object.limit) ? globalThis.String(object.limit) : "0",
      offset: isSet(object.offset) ? globalThis.String(object.offset) : "0",
    };
  },

  toJSON(message: TransactionRequest): unknown {
    const obj: any = {};
    if (message.userSid !== "0") {
      obj.userSid = message.userSid;
    }
    if (message.fromUnix !== "0") {
      obj.fromUnix = message.fromUnix;
    }
    if (message.toUnix !== "0") {
      obj.toUnix = message.toUnix;
    }
    if (message.limit !== "0") {
      obj.limit = message.limit;
    }
    if (message.offset !== "0") {
      obj.offset = message.offset;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionRequest>, I>>(base?: I): TransactionRequest {
    return TransactionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionRequest>, I>>(object: I): TransactionRequest {
    const message = createBaseTransactionRequest();
    message.userSid = object.userSid ?? "0";
    message.fromUnix = object.fromUnix ?? "0";
    message.toUnix = object.toUnix ?? "0";
    message.limit = object.limit ?? "0";
    message.offset = object.offset ?? "0";
    return message;
  },
};

function createBaseTransactionDetail(): TransactionDetail {
  return {
    id: "",
    userId: "",
    userSid: "0",
    userName: "",
    vip: "0",
    rp: "0",
    typeTopup: "",
    chipsTopup: "0",
    createdUnix: "0",
  };
}

export const TransactionDetail: MessageFns<TransactionDetail> = {
  encode(message: TransactionDetail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.userSid !== "0") {
      writer.uint32(24).int64(message.userSid);
    }
    if (message.userName !== "") {
      writer.uint32(34).string(message.userName);
    }
    if (message.vip !== "0") {
      writer.uint32(40).int64(message.vip);
    }
    if (message.rp !== "0") {
      writer.uint32(48).int64(message.rp);
    }
    if (message.typeTopup !== "") {
      writer.uint32(58).string(message.typeTopup);
    }
    if (message.chipsTopup !== "0") {
      writer.uint32(64).int64(message.chipsTopup);
    }
    if (message.createdUnix !== "0") {
      writer.uint32(72).int64(message.createdUnix);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionDetail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.userSid = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.vip = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.rp = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.typeTopup = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.chipsTopup = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.createdUnix = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionDetail {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      userSid: isSet(object.userSid) ? globalThis.String(object.userSid) : "0",
      userName: isSet(object.userName) ? globalThis.String(object.userName) : "",
      vip: isSet(object.vip) ? globalThis.String(object.vip) : "0",
      rp: isSet(object.rp) ? globalThis.String(object.rp) : "0",
      typeTopup: isSet(object.typeTopup) ? globalThis.String(object.typeTopup) : "",
      chipsTopup: isSet(object.chipsTopup) ? globalThis.String(object.chipsTopup) : "0",
      createdUnix: isSet(object.createdUnix) ? globalThis.String(object.createdUnix) : "0",
    };
  },

  toJSON(message: TransactionDetail): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.userSid !== "0") {
      obj.userSid = message.userSid;
    }
    if (message.userName !== "") {
      obj.userName = message.userName;
    }
    if (message.vip !== "0") {
      obj.vip = message.vip;
    }
    if (message.rp !== "0") {
      obj.rp = message.rp;
    }
    if (message.typeTopup !== "") {
      obj.typeTopup = message.typeTopup;
    }
    if (message.chipsTopup !== "0") {
      obj.chipsTopup = message.chipsTopup;
    }
    if (message.createdUnix !== "0") {
      obj.createdUnix = message.createdUnix;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionDetail>, I>>(base?: I): TransactionDetail {
    return TransactionDetail.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionDetail>, I>>(object: I): TransactionDetail {
    const message = createBaseTransactionDetail();
    message.id = object.id ?? "";
    message.userId = object.userId ?? "";
    message.userSid = object.userSid ?? "0";
    message.userName = object.userName ?? "";
    message.vip = object.vip ?? "0";
    message.rp = object.rp ?? "0";
    message.typeTopup = object.typeTopup ?? "";
    message.chipsTopup = object.chipsTopup ?? "0";
    message.createdUnix = object.createdUnix ?? "0";
    return message;
  },
};

function createBaseTransactionResponse(): TransactionResponse {
  return { transDetails: [], totalRp: "0", limit: "0", offset: "0", total: "0" };
}

export const TransactionResponse: MessageFns<TransactionResponse> = {
  encode(message: TransactionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.transDetails) {
      TransactionDetail.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalRp !== "0") {
      writer.uint32(16).int64(message.totalRp);
    }
    if (message.limit !== "0") {
      writer.uint32(24).int64(message.limit);
    }
    if (message.offset !== "0") {
      writer.uint32(32).int64(message.offset);
    }
    if (message.total !== "0") {
      writer.uint32(40).int64(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transDetails.push(TransactionDetail.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalRp = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.offset = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.total = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionResponse {
    return {
      transDetails: globalThis.Array.isArray(object?.transDetails)
        ? object.transDetails.map((e: any) => TransactionDetail.fromJSON(e))
        : [],
      totalRp: isSet(object.totalRp) ? globalThis.String(object.totalRp) : "0",
      limit: isSet(object.limit) ? globalThis.String(object.limit) : "0",
      offset: isSet(object.offset) ? globalThis.String(object.offset) : "0",
      total: isSet(object.total) ? globalThis.String(object.total) : "0",
    };
  },

  toJSON(message: TransactionResponse): unknown {
    const obj: any = {};
    if (message.transDetails?.length) {
      obj.transDetails = message.transDetails.map((e) => TransactionDetail.toJSON(e));
    }
    if (message.totalRp !== "0") {
      obj.totalRp = message.totalRp;
    }
    if (message.limit !== "0") {
      obj.limit = message.limit;
    }
    if (message.offset !== "0") {
      obj.offset = message.offset;
    }
    if (message.total !== "0") {
      obj.total = message.total;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionResponse>, I>>(base?: I): TransactionResponse {
    return TransactionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionResponse>, I>>(object: I): TransactionResponse {
    const message = createBaseTransactionResponse();
    message.transDetails = object.transDetails?.map((e) => TransactionDetail.fromPartial(e)) || [];
    message.totalRp = object.totalRp ?? "0";
    message.limit = object.limit ?? "0";
    message.offset = object.offset ?? "0";
    message.total = object.total ?? "0";
    return message;
  },
};

function createBaseIAPSummary(): IAPSummary {
  return {
    id: "0",
    userId: "",
    createAtUnix: "0",
    totalTopup: "0",
    vipPoint: "0",
    totalCashout: "0",
    vip: "0",
    currencyTopup: "0",
    currencyCashout: "0",
  };
}

export const IAPSummary: MessageFns<IAPSummary> = {
  encode(message: IAPSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "0") {
      writer.uint32(8).int64(message.id);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.createAtUnix !== "0") {
      writer.uint32(24).int64(message.createAtUnix);
    }
    if (message.totalTopup !== "0") {
      writer.uint32(32).int64(message.totalTopup);
    }
    if (message.vipPoint !== "0") {
      writer.uint32(40).int64(message.vipPoint);
    }
    if (message.totalCashout !== "0") {
      writer.uint32(48).int64(message.totalCashout);
    }
    if (message.vip !== "0") {
      writer.uint32(56).int64(message.vip);
    }
    if (message.currencyTopup !== "0") {
      writer.uint32(64).int64(message.currencyTopup);
    }
    if (message.currencyCashout !== "0") {
      writer.uint32(72).int64(message.currencyCashout);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IAPSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIAPSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.createAtUnix = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalTopup = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.vipPoint = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.totalCashout = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.vip = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.currencyTopup = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.currencyCashout = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IAPSummary {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "0",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      createAtUnix: isSet(object.createAtUnix) ? globalThis.String(object.createAtUnix) : "0",
      totalTopup: isSet(object.totalTopup) ? globalThis.String(object.totalTopup) : "0",
      vipPoint: isSet(object.vipPoint) ? globalThis.String(object.vipPoint) : "0",
      totalCashout: isSet(object.totalCashout) ? globalThis.String(object.totalCashout) : "0",
      vip: isSet(object.vip) ? globalThis.String(object.vip) : "0",
      currencyTopup: isSet(object.currencyTopup) ? globalThis.String(object.currencyTopup) : "0",
      currencyCashout: isSet(object.currencyCashout) ? globalThis.String(object.currencyCashout) : "0",
    };
  },

  toJSON(message: IAPSummary): unknown {
    const obj: any = {};
    if (message.id !== "0") {
      obj.id = message.id;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.createAtUnix !== "0") {
      obj.createAtUnix = message.createAtUnix;
    }
    if (message.totalTopup !== "0") {
      obj.totalTopup = message.totalTopup;
    }
    if (message.vipPoint !== "0") {
      obj.vipPoint = message.vipPoint;
    }
    if (message.totalCashout !== "0") {
      obj.totalCashout = message.totalCashout;
    }
    if (message.vip !== "0") {
      obj.vip = message.vip;
    }
    if (message.currencyTopup !== "0") {
      obj.currencyTopup = message.currencyTopup;
    }
    if (message.currencyCashout !== "0") {
      obj.currencyCashout = message.currencyCashout;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IAPSummary>, I>>(base?: I): IAPSummary {
    return IAPSummary.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IAPSummary>, I>>(object: I): IAPSummary {
    const message = createBaseIAPSummary();
    message.id = object.id ?? "0";
    message.userId = object.userId ?? "";
    message.createAtUnix = object.createAtUnix ?? "0";
    message.totalTopup = object.totalTopup ?? "0";
    message.vipPoint = object.vipPoint ?? "0";
    message.totalCashout = object.totalCashout ?? "0";
    message.vip = object.vip ?? "0";
    message.currencyTopup = object.currencyTopup ?? "0";
    message.currencyCashout = object.currencyCashout ?? "0";
    return message;
  },
};

function createBaseCashInfo(): CashInfo {
  return {
    id: "0",
    userId: "",
    createAtUnix: "0",
    chips: "0",
    vipPoint: "0",
    publisher: "0",
    currency: "0",
    currencyUnitId: "0",
    transId: "",
    dateUnix: "0",
    numTransaction: "0",
    currencyValue: "0",
    currencyUnitName: "",
    numTransByCurrencyValue: {},
    numAccountUnique: "0",
    netRev: "0",
  };
}

export const CashInfo: MessageFns<CashInfo> = {
  encode(message: CashInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "0") {
      writer.uint32(8).int64(message.id);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.createAtUnix !== "0") {
      writer.uint32(24).int64(message.createAtUnix);
    }
    if (message.chips !== "0") {
      writer.uint32(32).int64(message.chips);
    }
    if (message.vipPoint !== "0") {
      writer.uint32(40).int64(message.vipPoint);
    }
    if (message.publisher !== "0") {
      writer.uint32(48).int64(message.publisher);
    }
    if (message.currency !== "0") {
      writer.uint32(56).int64(message.currency);
    }
    if (message.currencyUnitId !== "0") {
      writer.uint32(64).int64(message.currencyUnitId);
    }
    if (message.transId !== "") {
      writer.uint32(74).string(message.transId);
    }
    if (message.dateUnix !== "0") {
      writer.uint32(80).int64(message.dateUnix);
    }
    if (message.numTransaction !== "0") {
      writer.uint32(88).int64(message.numTransaction);
    }
    if (message.currencyValue !== "0") {
      writer.uint32(96).int64(message.currencyValue);
    }
    if (message.currencyUnitName !== "") {
      writer.uint32(106).string(message.currencyUnitName);
    }
    Object.entries(message.numTransByCurrencyValue).forEach(([key, value]) => {
      CashInfo_NumTransByCurrencyValueEntry.encode({ key: key as any, value }, writer.uint32(114).fork()).join();
    });
    if (message.numAccountUnique !== "0") {
      writer.uint32(120).int64(message.numAccountUnique);
    }
    if (message.netRev !== "0") {
      writer.uint32(128).int64(message.netRev);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CashInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCashInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.createAtUnix = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.chips = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.vipPoint = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.publisher = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.currency = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.currencyUnitId = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.transId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.dateUnix = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.numTransaction = reader.int64().toString();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.currencyValue = reader.int64().toString();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.currencyUnitName = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          const entry14 = CashInfo_NumTransByCurrencyValueEntry.decode(reader, reader.uint32());
          if (entry14.value !== undefined) {
            message.numTransByCurrencyValue[entry14.key] = entry14.value;
          }
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.numAccountUnique = reader.int64().toString();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.netRev = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CashInfo {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "0",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      createAtUnix: isSet(object.createAtUnix) ? globalThis.String(object.createAtUnix) : "0",
      chips: isSet(object.chips) ? globalThis.String(object.chips) : "0",
      vipPoint: isSet(object.vipPoint) ? globalThis.String(object.vipPoint) : "0",
      publisher: isSet(object.publisher) ? globalThis.String(object.publisher) : "0",
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "0",
      currencyUnitId: isSet(object.currencyUnitId) ? globalThis.String(object.currencyUnitId) : "0",
      transId: isSet(object.transId) ? globalThis.String(object.transId) : "",
      dateUnix: isSet(object.dateUnix) ? globalThis.String(object.dateUnix) : "0",
      numTransaction: isSet(object.numTransaction) ? globalThis.String(object.numTransaction) : "0",
      currencyValue: isSet(object.currencyValue) ? globalThis.String(object.currencyValue) : "0",
      currencyUnitName: isSet(object.currencyUnitName) ? globalThis.String(object.currencyUnitName) : "",
      numTransByCurrencyValue: isObject(object.numTransByCurrencyValue)
        ? Object.entries(object.numTransByCurrencyValue).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      numAccountUnique: isSet(object.numAccountUnique) ? globalThis.String(object.numAccountUnique) : "0",
      netRev: isSet(object.netRev) ? globalThis.String(object.netRev) : "0",
    };
  },

  toJSON(message: CashInfo): unknown {
    const obj: any = {};
    if (message.id !== "0") {
      obj.id = message.id;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.createAtUnix !== "0") {
      obj.createAtUnix = message.createAtUnix;
    }
    if (message.chips !== "0") {
      obj.chips = message.chips;
    }
    if (message.vipPoint !== "0") {
      obj.vipPoint = message.vipPoint;
    }
    if (message.publisher !== "0") {
      obj.publisher = message.publisher;
    }
    if (message.currency !== "0") {
      obj.currency = message.currency;
    }
    if (message.currencyUnitId !== "0") {
      obj.currencyUnitId = message.currencyUnitId;
    }
    if (message.transId !== "") {
      obj.transId = message.transId;
    }
    if (message.dateUnix !== "0") {
      obj.dateUnix = message.dateUnix;
    }
    if (message.numTransaction !== "0") {
      obj.numTransaction = message.numTransaction;
    }
    if (message.currencyValue !== "0") {
      obj.currencyValue = message.currencyValue;
    }
    if (message.currencyUnitName !== "") {
      obj.currencyUnitName = message.currencyUnitName;
    }
    if (message.numTransByCurrencyValue) {
      const entries = Object.entries(message.numTransByCurrencyValue);
      if (entries.length > 0) {
        obj.numTransByCurrencyValue = {};
        entries.forEach(([k, v]) => {
          obj.numTransByCurrencyValue[k] = v;
        });
      }
    }
    if (message.numAccountUnique !== "0") {
      obj.numAccountUnique = message.numAccountUnique;
    }
    if (message.netRev !== "0") {
      obj.netRev = message.netRev;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CashInfo>, I>>(base?: I): CashInfo {
    return CashInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CashInfo>, I>>(object: I): CashInfo {
    const message = createBaseCashInfo();
    message.id = object.id ?? "0";
    message.userId = object.userId ?? "";
    message.createAtUnix = object.createAtUnix ?? "0";
    message.chips = object.chips ?? "0";
    message.vipPoint = object.vipPoint ?? "0";
    message.publisher = object.publisher ?? "0";
    message.currency = object.currency ?? "0";
    message.currencyUnitId = object.currencyUnitId ?? "0";
    message.transId = object.transId ?? "";
    message.dateUnix = object.dateUnix ?? "0";
    message.numTransaction = object.numTransaction ?? "0";
    message.currencyValue = object.currencyValue ?? "0";
    message.currencyUnitName = object.currencyUnitName ?? "";
    message.numTransByCurrencyValue = Object.entries(object.numTransByCurrencyValue ?? {}).reduce<
      { [key: string]: string }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.numAccountUnique = object.numAccountUnique ?? "0";
    message.netRev = object.netRev ?? "0";
    return message;
  },
};

function createBaseCashInfo_NumTransByCurrencyValueEntry(): CashInfo_NumTransByCurrencyValueEntry {
  return { key: "0", value: "0" };
}

export const CashInfo_NumTransByCurrencyValueEntry: MessageFns<CashInfo_NumTransByCurrencyValueEntry> = {
  encode(message: CashInfo_NumTransByCurrencyValueEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "0") {
      writer.uint32(8).int64(message.key);
    }
    if (message.value !== "0") {
      writer.uint32(16).int64(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CashInfo_NumTransByCurrencyValueEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCashInfo_NumTransByCurrencyValueEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CashInfo_NumTransByCurrencyValueEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "0",
      value: isSet(object.value) ? globalThis.String(object.value) : "0",
    };
  },

  toJSON(message: CashInfo_NumTransByCurrencyValueEntry): unknown {
    const obj: any = {};
    if (message.key !== "0") {
      obj.key = message.key;
    }
    if (message.value !== "0") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CashInfo_NumTransByCurrencyValueEntry>, I>>(
    base?: I,
  ): CashInfo_NumTransByCurrencyValueEntry {
    return CashInfo_NumTransByCurrencyValueEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CashInfo_NumTransByCurrencyValueEntry>, I>>(
    object: I,
  ): CashInfo_NumTransByCurrencyValueEntry {
    const message = createBaseCashInfo_NumTransByCurrencyValueEntry();
    message.key = object.key ?? "0";
    message.value = object.value ?? "0";
    return message;
  },
};

function createBaseCashInfoRequest(): CashInfoRequest {
  return { fromUnix: "0", toUnix: "0", limit: "0", offset: "0", publisher: "0", currencyId: 0 };
}

export const CashInfoRequest: MessageFns<CashInfoRequest> = {
  encode(message: CashInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromUnix !== "0") {
      writer.uint32(8).int64(message.fromUnix);
    }
    if (message.toUnix !== "0") {
      writer.uint32(16).int64(message.toUnix);
    }
    if (message.limit !== "0") {
      writer.uint32(24).int64(message.limit);
    }
    if (message.offset !== "0") {
      writer.uint32(32).int64(message.offset);
    }
    if (message.publisher !== "0") {
      writer.uint32(40).int64(message.publisher);
    }
    if (message.currencyId !== 0) {
      writer.uint32(48).int32(message.currencyId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CashInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCashInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fromUnix = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.toUnix = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.offset = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.publisher = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.currencyId = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CashInfoRequest {
    return {
      fromUnix: isSet(object.fromUnix) ? globalThis.String(object.fromUnix) : "0",
      toUnix: isSet(object.toUnix) ? globalThis.String(object.toUnix) : "0",
      limit: isSet(object.limit) ? globalThis.String(object.limit) : "0",
      offset: isSet(object.offset) ? globalThis.String(object.offset) : "0",
      publisher: isSet(object.publisher) ? globalThis.String(object.publisher) : "0",
      currencyId: isSet(object.currencyId) ? currencyUnitIdFromJSON(object.currencyId) : 0,
    };
  },

  toJSON(message: CashInfoRequest): unknown {
    const obj: any = {};
    if (message.fromUnix !== "0") {
      obj.fromUnix = message.fromUnix;
    }
    if (message.toUnix !== "0") {
      obj.toUnix = message.toUnix;
    }
    if (message.limit !== "0") {
      obj.limit = message.limit;
    }
    if (message.offset !== "0") {
      obj.offset = message.offset;
    }
    if (message.publisher !== "0") {
      obj.publisher = message.publisher;
    }
    if (message.currencyId !== 0) {
      obj.currencyId = currencyUnitIdToJSON(message.currencyId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CashInfoRequest>, I>>(base?: I): CashInfoRequest {
    return CashInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CashInfoRequest>, I>>(object: I): CashInfoRequest {
    const message = createBaseCashInfoRequest();
    message.fromUnix = object.fromUnix ?? "0";
    message.toUnix = object.toUnix ?? "0";
    message.limit = object.limit ?? "0";
    message.offset = object.offset ?? "0";
    message.publisher = object.publisher ?? "0";
    message.currencyId = object.currencyId ?? 0;
    return message;
  },
};

function createBaseCashInfoResponse(): CashInfoResponse {
  return { cashoutInfos: [], totalCash: "0", totalAccount: "0", avgCash: "0", totalRev: "0", avgRev: "0" };
}

export const CashInfoResponse: MessageFns<CashInfoResponse> = {
  encode(message: CashInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.cashoutInfos) {
      CashInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalCash !== "0") {
      writer.uint32(16).int64(message.totalCash);
    }
    if (message.totalAccount !== "0") {
      writer.uint32(24).int64(message.totalAccount);
    }
    if (message.avgCash !== "0") {
      writer.uint32(32).int64(message.avgCash);
    }
    if (message.totalRev !== "0") {
      writer.uint32(40).int64(message.totalRev);
    }
    if (message.avgRev !== "0") {
      writer.uint32(48).int64(message.avgRev);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CashInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCashInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cashoutInfos.push(CashInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalCash = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalAccount = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.avgCash = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.totalRev = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.avgRev = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CashInfoResponse {
    return {
      cashoutInfos: globalThis.Array.isArray(object?.cashoutInfos)
        ? object.cashoutInfos.map((e: any) => CashInfo.fromJSON(e))
        : [],
      totalCash: isSet(object.totalCash) ? globalThis.String(object.totalCash) : "0",
      totalAccount: isSet(object.totalAccount) ? globalThis.String(object.totalAccount) : "0",
      avgCash: isSet(object.avgCash) ? globalThis.String(object.avgCash) : "0",
      totalRev: isSet(object.totalRev) ? globalThis.String(object.totalRev) : "0",
      avgRev: isSet(object.avgRev) ? globalThis.String(object.avgRev) : "0",
    };
  },

  toJSON(message: CashInfoResponse): unknown {
    const obj: any = {};
    if (message.cashoutInfos?.length) {
      obj.cashoutInfos = message.cashoutInfos.map((e) => CashInfo.toJSON(e));
    }
    if (message.totalCash !== "0") {
      obj.totalCash = message.totalCash;
    }
    if (message.totalAccount !== "0") {
      obj.totalAccount = message.totalAccount;
    }
    if (message.avgCash !== "0") {
      obj.avgCash = message.avgCash;
    }
    if (message.totalRev !== "0") {
      obj.totalRev = message.totalRev;
    }
    if (message.avgRev !== "0") {
      obj.avgRev = message.avgRev;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CashInfoResponse>, I>>(base?: I): CashInfoResponse {
    return CashInfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CashInfoResponse>, I>>(object: I): CashInfoResponse {
    const message = createBaseCashInfoResponse();
    message.cashoutInfos = object.cashoutInfos?.map((e) => CashInfo.fromPartial(e)) || [];
    message.totalCash = object.totalCash ?? "0";
    message.totalAccount = object.totalAccount ?? "0";
    message.avgCash = object.avgCash ?? "0";
    message.totalRev = object.totalRev ?? "0";
    message.avgRev = object.avgRev ?? "0";
    return message;
  },
};

function createBaseUserGameCount(): UserGameCount {
  return { dateUnix: "0", countGame: "0" };
}

export const UserGameCount: MessageFns<UserGameCount> = {
  encode(message: UserGameCount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dateUnix !== "0") {
      writer.uint32(8).int64(message.dateUnix);
    }
    if (message.countGame !== "0") {
      writer.uint32(16).int64(message.countGame);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserGameCount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserGameCount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.dateUnix = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.countGame = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserGameCount {
    return {
      dateUnix: isSet(object.dateUnix) ? globalThis.String(object.dateUnix) : "0",
      countGame: isSet(object.countGame) ? globalThis.String(object.countGame) : "0",
    };
  },

  toJSON(message: UserGameCount): unknown {
    const obj: any = {};
    if (message.dateUnix !== "0") {
      obj.dateUnix = message.dateUnix;
    }
    if (message.countGame !== "0") {
      obj.countGame = message.countGame;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserGameCount>, I>>(base?: I): UserGameCount {
    return UserGameCount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserGameCount>, I>>(object: I): UserGameCount {
    const message = createBaseUserGameCount();
    message.dateUnix = object.dateUnix ?? "0";
    message.countGame = object.countGame ?? "0";
    return message;
  },
};

function createBaseUserGameStats(): UserGameStats {
  return { userId: "", gameNo: "0", userGameCounts: [] };
}

export const UserGameStats: MessageFns<UserGameStats> = {
  encode(message: UserGameStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.gameNo !== "0") {
      writer.uint32(16).int64(message.gameNo);
    }
    for (const v of message.userGameCounts) {
      UserGameCount.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserGameStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserGameStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.gameNo = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userGameCounts.push(UserGameCount.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserGameStats {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      gameNo: isSet(object.gameNo) ? globalThis.String(object.gameNo) : "0",
      userGameCounts: globalThis.Array.isArray(object?.userGameCounts)
        ? object.userGameCounts.map((e: any) => UserGameCount.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UserGameStats): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.gameNo !== "0") {
      obj.gameNo = message.gameNo;
    }
    if (message.userGameCounts?.length) {
      obj.userGameCounts = message.userGameCounts.map((e) => UserGameCount.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserGameStats>, I>>(base?: I): UserGameStats {
    return UserGameStats.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserGameStats>, I>>(object: I): UserGameStats {
    const message = createBaseUserGameStats();
    message.userId = object.userId ?? "";
    message.gameNo = object.gameNo ?? "0";
    message.userGameCounts = object.userGameCounts?.map((e) => UserGameCount.fromPartial(e)) || [];
    return message;
  },
};

function createBasePaymentByVip(): PaymentByVip {
  return { vip: "0", ci: "0", chips: "0", numTrans: "0", numAccount: "0" };
}

export const PaymentByVip: MessageFns<PaymentByVip> = {
  encode(message: PaymentByVip, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vip !== "0") {
      writer.uint32(8).int64(message.vip);
    }
    if (message.ci !== "0") {
      writer.uint32(16).int64(message.ci);
    }
    if (message.chips !== "0") {
      writer.uint32(24).int64(message.chips);
    }
    if (message.numTrans !== "0") {
      writer.uint32(32).int64(message.numTrans);
    }
    if (message.numAccount !== "0") {
      writer.uint32(40).int64(message.numAccount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentByVip {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentByVip();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.vip = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.ci = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.chips = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.numTrans = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.numAccount = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentByVip {
    return {
      vip: isSet(object.vip) ? globalThis.String(object.vip) : "0",
      ci: isSet(object.ci) ? globalThis.String(object.ci) : "0",
      chips: isSet(object.chips) ? globalThis.String(object.chips) : "0",
      numTrans: isSet(object.numTrans) ? globalThis.String(object.numTrans) : "0",
      numAccount: isSet(object.numAccount) ? globalThis.String(object.numAccount) : "0",
    };
  },

  toJSON(message: PaymentByVip): unknown {
    const obj: any = {};
    if (message.vip !== "0") {
      obj.vip = message.vip;
    }
    if (message.ci !== "0") {
      obj.ci = message.ci;
    }
    if (message.chips !== "0") {
      obj.chips = message.chips;
    }
    if (message.numTrans !== "0") {
      obj.numTrans = message.numTrans;
    }
    if (message.numAccount !== "0") {
      obj.numAccount = message.numAccount;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentByVip>, I>>(base?: I): PaymentByVip {
    return PaymentByVip.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentByVip>, I>>(object: I): PaymentByVip {
    const message = createBasePaymentByVip();
    message.vip = object.vip ?? "0";
    message.ci = object.ci ?? "0";
    message.chips = object.chips ?? "0";
    message.numTrans = object.numTrans ?? "0";
    message.numAccount = object.numAccount ?? "0";
    return message;
  },
};

function createBasePaymentsByVip(): PaymentsByVip {
  return { payments: [], fromUnix: "0", toUnix: "0" };
}

export const PaymentsByVip: MessageFns<PaymentsByVip> = {
  encode(message: PaymentsByVip, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.payments) {
      PaymentByVip.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.fromUnix !== "0") {
      writer.uint32(16).int64(message.fromUnix);
    }
    if (message.toUnix !== "0") {
      writer.uint32(24).int64(message.toUnix);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentsByVip {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentsByVip();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payments.push(PaymentByVip.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.fromUnix = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.toUnix = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentsByVip {
    return {
      payments: globalThis.Array.isArray(object?.payments)
        ? object.payments.map((e: any) => PaymentByVip.fromJSON(e))
        : [],
      fromUnix: isSet(object.fromUnix) ? globalThis.String(object.fromUnix) : "0",
      toUnix: isSet(object.toUnix) ? globalThis.String(object.toUnix) : "0",
    };
  },

  toJSON(message: PaymentsByVip): unknown {
    const obj: any = {};
    if (message.payments?.length) {
      obj.payments = message.payments.map((e) => PaymentByVip.toJSON(e));
    }
    if (message.fromUnix !== "0") {
      obj.fromUnix = message.fromUnix;
    }
    if (message.toUnix !== "0") {
      obj.toUnix = message.toUnix;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentsByVip>, I>>(base?: I): PaymentsByVip {
    return PaymentsByVip.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentsByVip>, I>>(object: I): PaymentsByVip {
    const message = createBasePaymentsByVip();
    message.payments = object.payments?.map((e) => PaymentByVip.fromPartial(e)) || [];
    message.fromUnix = object.fromUnix ?? "0";
    message.toUnix = object.toUnix ?? "0";
    return message;
  },
};

function createBaseCashoutByVip(): CashoutByVip {
  return { vip: "0", co: "0", chips: "0", numTrans: "0", numAccount: "0" };
}

export const CashoutByVip: MessageFns<CashoutByVip> = {
  encode(message: CashoutByVip, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vip !== "0") {
      writer.uint32(8).int64(message.vip);
    }
    if (message.co !== "0") {
      writer.uint32(16).int64(message.co);
    }
    if (message.chips !== "0") {
      writer.uint32(24).int64(message.chips);
    }
    if (message.numTrans !== "0") {
      writer.uint32(32).int64(message.numTrans);
    }
    if (message.numAccount !== "0") {
      writer.uint32(40).int64(message.numAccount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CashoutByVip {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCashoutByVip();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.vip = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.co = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.chips = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.numTrans = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.numAccount = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CashoutByVip {
    return {
      vip: isSet(object.vip) ? globalThis.String(object.vip) : "0",
      co: isSet(object.co) ? globalThis.String(object.co) : "0",
      chips: isSet(object.chips) ? globalThis.String(object.chips) : "0",
      numTrans: isSet(object.numTrans) ? globalThis.String(object.numTrans) : "0",
      numAccount: isSet(object.numAccount) ? globalThis.String(object.numAccount) : "0",
    };
  },

  toJSON(message: CashoutByVip): unknown {
    const obj: any = {};
    if (message.vip !== "0") {
      obj.vip = message.vip;
    }
    if (message.co !== "0") {
      obj.co = message.co;
    }
    if (message.chips !== "0") {
      obj.chips = message.chips;
    }
    if (message.numTrans !== "0") {
      obj.numTrans = message.numTrans;
    }
    if (message.numAccount !== "0") {
      obj.numAccount = message.numAccount;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CashoutByVip>, I>>(base?: I): CashoutByVip {
    return CashoutByVip.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CashoutByVip>, I>>(object: I): CashoutByVip {
    const message = createBaseCashoutByVip();
    message.vip = object.vip ?? "0";
    message.co = object.co ?? "0";
    message.chips = object.chips ?? "0";
    message.numTrans = object.numTrans ?? "0";
    message.numAccount = object.numAccount ?? "0";
    return message;
  },
};

function createBaseCashoutsByVip(): CashoutsByVip {
  return { cashouts: [], fromUnix: "0", toUnix: "0" };
}

export const CashoutsByVip: MessageFns<CashoutsByVip> = {
  encode(message: CashoutsByVip, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.cashouts) {
      CashoutByVip.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.fromUnix !== "0") {
      writer.uint32(16).int64(message.fromUnix);
    }
    if (message.toUnix !== "0") {
      writer.uint32(24).int64(message.toUnix);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CashoutsByVip {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCashoutsByVip();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cashouts.push(CashoutByVip.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.fromUnix = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.toUnix = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CashoutsByVip {
    return {
      cashouts: globalThis.Array.isArray(object?.cashouts)
        ? object.cashouts.map((e: any) => CashoutByVip.fromJSON(e))
        : [],
      fromUnix: isSet(object.fromUnix) ? globalThis.String(object.fromUnix) : "0",
      toUnix: isSet(object.toUnix) ? globalThis.String(object.toUnix) : "0",
    };
  },

  toJSON(message: CashoutsByVip): unknown {
    const obj: any = {};
    if (message.cashouts?.length) {
      obj.cashouts = message.cashouts.map((e) => CashoutByVip.toJSON(e));
    }
    if (message.fromUnix !== "0") {
      obj.fromUnix = message.fromUnix;
    }
    if (message.toUnix !== "0") {
      obj.toUnix = message.toUnix;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CashoutsByVip>, I>>(base?: I): CashoutsByVip {
    return CashoutsByVip.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CashoutsByVip>, I>>(object: I): CashoutsByVip {
    const message = createBaseCashoutsByVip();
    message.cashouts = object.cashouts?.map((e) => CashoutByVip.fromPartial(e)) || [];
    message.fromUnix = object.fromUnix ?? "0";
    message.toUnix = object.toUnix ?? "0";
    return message;
  },
};

function createBaseVipStats(): VipStats {
  return {
    timeUpdateUnix: "0",
    userSid: "0",
    userId: "",
    userName: "",
    noWin: "0",
    noLose: "0",
    chipsWin: "0",
    chipsLose: "0",
    cashIn: "0",
    cashIn5: "0",
    cashIn10: "0",
    cashOut: "0",
    cashOut5: "0",
    cashOut10: "0",
    vip: "0",
  };
}

export const VipStats: MessageFns<VipStats> = {
  encode(message: VipStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timeUpdateUnix !== "0") {
      writer.uint32(8).int64(message.timeUpdateUnix);
    }
    if (message.userSid !== "0") {
      writer.uint32(16).int64(message.userSid);
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    if (message.userName !== "") {
      writer.uint32(34).string(message.userName);
    }
    if (message.noWin !== "0") {
      writer.uint32(40).int64(message.noWin);
    }
    if (message.noLose !== "0") {
      writer.uint32(48).int64(message.noLose);
    }
    if (message.chipsWin !== "0") {
      writer.uint32(56).int64(message.chipsWin);
    }
    if (message.chipsLose !== "0") {
      writer.uint32(64).int64(message.chipsLose);
    }
    if (message.cashIn !== "0") {
      writer.uint32(72).int64(message.cashIn);
    }
    if (message.cashIn5 !== "0") {
      writer.uint32(80).int64(message.cashIn5);
    }
    if (message.cashIn10 !== "0") {
      writer.uint32(88).int64(message.cashIn10);
    }
    if (message.cashOut !== "0") {
      writer.uint32(96).int64(message.cashOut);
    }
    if (message.cashOut5 !== "0") {
      writer.uint32(104).int64(message.cashOut5);
    }
    if (message.cashOut10 !== "0") {
      writer.uint32(112).int64(message.cashOut10);
    }
    if (message.vip !== "0") {
      writer.uint32(120).int64(message.vip);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VipStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVipStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.timeUpdateUnix = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.userSid = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.noWin = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.noLose = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.chipsWin = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.chipsLose = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.cashIn = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.cashIn5 = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.cashIn10 = reader.int64().toString();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.cashOut = reader.int64().toString();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.cashOut5 = reader.int64().toString();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.cashOut10 = reader.int64().toString();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.vip = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VipStats {
    return {
      timeUpdateUnix: isSet(object.timeUpdateUnix) ? globalThis.String(object.timeUpdateUnix) : "0",
      userSid: isSet(object.userSid) ? globalThis.String(object.userSid) : "0",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      userName: isSet(object.userName) ? globalThis.String(object.userName) : "",
      noWin: isSet(object.noWin) ? globalThis.String(object.noWin) : "0",
      noLose: isSet(object.noLose) ? globalThis.String(object.noLose) : "0",
      chipsWin: isSet(object.chipsWin) ? globalThis.String(object.chipsWin) : "0",
      chipsLose: isSet(object.chipsLose) ? globalThis.String(object.chipsLose) : "0",
      cashIn: isSet(object.cashIn) ? globalThis.String(object.cashIn) : "0",
      cashIn5: isSet(object.cashIn5) ? globalThis.String(object.cashIn5) : "0",
      cashIn10: isSet(object.cashIn10) ? globalThis.String(object.cashIn10) : "0",
      cashOut: isSet(object.cashOut) ? globalThis.String(object.cashOut) : "0",
      cashOut5: isSet(object.cashOut5) ? globalThis.String(object.cashOut5) : "0",
      cashOut10: isSet(object.cashOut10) ? globalThis.String(object.cashOut10) : "0",
      vip: isSet(object.vip) ? globalThis.String(object.vip) : "0",
    };
  },

  toJSON(message: VipStats): unknown {
    const obj: any = {};
    if (message.timeUpdateUnix !== "0") {
      obj.timeUpdateUnix = message.timeUpdateUnix;
    }
    if (message.userSid !== "0") {
      obj.userSid = message.userSid;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.userName !== "") {
      obj.userName = message.userName;
    }
    if (message.noWin !== "0") {
      obj.noWin = message.noWin;
    }
    if (message.noLose !== "0") {
      obj.noLose = message.noLose;
    }
    if (message.chipsWin !== "0") {
      obj.chipsWin = message.chipsWin;
    }
    if (message.chipsLose !== "0") {
      obj.chipsLose = message.chipsLose;
    }
    if (message.cashIn !== "0") {
      obj.cashIn = message.cashIn;
    }
    if (message.cashIn5 !== "0") {
      obj.cashIn5 = message.cashIn5;
    }
    if (message.cashIn10 !== "0") {
      obj.cashIn10 = message.cashIn10;
    }
    if (message.cashOut !== "0") {
      obj.cashOut = message.cashOut;
    }
    if (message.cashOut5 !== "0") {
      obj.cashOut5 = message.cashOut5;
    }
    if (message.cashOut10 !== "0") {
      obj.cashOut10 = message.cashOut10;
    }
    if (message.vip !== "0") {
      obj.vip = message.vip;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VipStats>, I>>(base?: I): VipStats {
    return VipStats.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VipStats>, I>>(object: I): VipStats {
    const message = createBaseVipStats();
    message.timeUpdateUnix = object.timeUpdateUnix ?? "0";
    message.userSid = object.userSid ?? "0";
    message.userId = object.userId ?? "";
    message.userName = object.userName ?? "";
    message.noWin = object.noWin ?? "0";
    message.noLose = object.noLose ?? "0";
    message.chipsWin = object.chipsWin ?? "0";
    message.chipsLose = object.chipsLose ?? "0";
    message.cashIn = object.cashIn ?? "0";
    message.cashIn5 = object.cashIn5 ?? "0";
    message.cashIn10 = object.cashIn10 ?? "0";
    message.cashOut = object.cashOut ?? "0";
    message.cashOut5 = object.cashOut5 ?? "0";
    message.cashOut10 = object.cashOut10 ?? "0";
    message.vip = object.vip ?? "0";
    return message;
  },
};

function createBaseVipStatsReponse(): VipStatsReponse {
  return { vipsStats: [], total: "0", fromUnix: "0", limit: "0", offset: "0" };
}

export const VipStatsReponse: MessageFns<VipStatsReponse> = {
  encode(message: VipStatsReponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.vipsStats) {
      VipStats.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== "0") {
      writer.uint32(16).int64(message.total);
    }
    if (message.fromUnix !== "0") {
      writer.uint32(24).int64(message.fromUnix);
    }
    if (message.limit !== "0") {
      writer.uint32(32).int64(message.limit);
    }
    if (message.offset !== "0") {
      writer.uint32(40).int64(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VipStatsReponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVipStatsReponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.vipsStats.push(VipStats.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.fromUnix = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.limit = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.offset = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VipStatsReponse {
    return {
      vipsStats: globalThis.Array.isArray(object?.vipsStats)
        ? object.vipsStats.map((e: any) => VipStats.fromJSON(e))
        : [],
      total: isSet(object.total) ? globalThis.String(object.total) : "0",
      fromUnix: isSet(object.fromUnix) ? globalThis.String(object.fromUnix) : "0",
      limit: isSet(object.limit) ? globalThis.String(object.limit) : "0",
      offset: isSet(object.offset) ? globalThis.String(object.offset) : "0",
    };
  },

  toJSON(message: VipStatsReponse): unknown {
    const obj: any = {};
    if (message.vipsStats?.length) {
      obj.vipsStats = message.vipsStats.map((e) => VipStats.toJSON(e));
    }
    if (message.total !== "0") {
      obj.total = message.total;
    }
    if (message.fromUnix !== "0") {
      obj.fromUnix = message.fromUnix;
    }
    if (message.limit !== "0") {
      obj.limit = message.limit;
    }
    if (message.offset !== "0") {
      obj.offset = message.offset;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VipStatsReponse>, I>>(base?: I): VipStatsReponse {
    return VipStatsReponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VipStatsReponse>, I>>(object: I): VipStatsReponse {
    const message = createBaseVipStatsReponse();
    message.vipsStats = object.vipsStats?.map((e) => VipStats.fromPartial(e)) || [];
    message.total = object.total ?? "0";
    message.fromUnix = object.fromUnix ?? "0";
    message.limit = object.limit ?? "0";
    message.offset = object.offset ?? "0";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
