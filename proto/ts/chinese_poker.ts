// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: chinese_poker.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  CardStatus,
  cardStatusFromJSON,
  cardStatusToJSON,
  GameState,
  gameStateFromJSON,
  gameStateToJSON,
  Jackpot,
} from "./game_common";
import { WhotCard, WhotPlayerResult } from "./whot_game";

export const protobufPackage = "proto";

export enum CardSuit {
  SUIT_UNSPECIFIED = 0,
  SUIT_HEARTS = 1,
  SUIT_DIAMONDS = 2,
  SUIT_CLUBS = 3,
  SUIT_SPADES = 4,
  UNRECOGNIZED = -1,
}

export function cardSuitFromJSON(object: any): CardSuit {
  switch (object) {
    case 0:
    case "SUIT_UNSPECIFIED":
      return CardSuit.SUIT_UNSPECIFIED;
    case 1:
    case "SUIT_HEARTS":
      return CardSuit.SUIT_HEARTS;
    case 2:
    case "SUIT_DIAMONDS":
      return CardSuit.SUIT_DIAMONDS;
    case 3:
    case "SUIT_CLUBS":
      return CardSuit.SUIT_CLUBS;
    case 4:
    case "SUIT_SPADES":
      return CardSuit.SUIT_SPADES;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CardSuit.UNRECOGNIZED;
  }
}

export function cardSuitToJSON(object: CardSuit): string {
  switch (object) {
    case CardSuit.SUIT_UNSPECIFIED:
      return "SUIT_UNSPECIFIED";
    case CardSuit.SUIT_HEARTS:
      return "SUIT_HEARTS";
    case CardSuit.SUIT_DIAMONDS:
      return "SUIT_DIAMONDS";
    case CardSuit.SUIT_CLUBS:
      return "SUIT_CLUBS";
    case CardSuit.SUIT_SPADES:
      return "SUIT_SPADES";
    case CardSuit.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CardRank {
  RANK_UNSPECIFIED = 0,
  RANK_A = 1,
  RANK_2 = 2,
  RANK_3 = 3,
  RANK_4 = 4,
  RANK_5 = 5,
  RANK_6 = 6,
  RANK_7 = 7,
  RANK_8 = 8,
  RANK_9 = 9,
  RANK_10 = 10,
  RANK_J = 11,
  RANK_Q = 12,
  RANK_K = 13,
  UNRECOGNIZED = -1,
}

export function cardRankFromJSON(object: any): CardRank {
  switch (object) {
    case 0:
    case "RANK_UNSPECIFIED":
      return CardRank.RANK_UNSPECIFIED;
    case 1:
    case "RANK_A":
      return CardRank.RANK_A;
    case 2:
    case "RANK_2":
      return CardRank.RANK_2;
    case 3:
    case "RANK_3":
      return CardRank.RANK_3;
    case 4:
    case "RANK_4":
      return CardRank.RANK_4;
    case 5:
    case "RANK_5":
      return CardRank.RANK_5;
    case 6:
    case "RANK_6":
      return CardRank.RANK_6;
    case 7:
    case "RANK_7":
      return CardRank.RANK_7;
    case 8:
    case "RANK_8":
      return CardRank.RANK_8;
    case 9:
    case "RANK_9":
      return CardRank.RANK_9;
    case 10:
    case "RANK_10":
      return CardRank.RANK_10;
    case 11:
    case "RANK_J":
      return CardRank.RANK_J;
    case 12:
    case "RANK_Q":
      return CardRank.RANK_Q;
    case 13:
    case "RANK_K":
      return CardRank.RANK_K;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CardRank.UNRECOGNIZED;
  }
}

export function cardRankToJSON(object: CardRank): string {
  switch (object) {
    case CardRank.RANK_UNSPECIFIED:
      return "RANK_UNSPECIFIED";
    case CardRank.RANK_A:
      return "RANK_A";
    case CardRank.RANK_2:
      return "RANK_2";
    case CardRank.RANK_3:
      return "RANK_3";
    case CardRank.RANK_4:
      return "RANK_4";
    case CardRank.RANK_5:
      return "RANK_5";
    case CardRank.RANK_6:
      return "RANK_6";
    case CardRank.RANK_7:
      return "RANK_7";
    case CardRank.RANK_8:
      return "RANK_8";
    case CardRank.RANK_9:
      return "RANK_9";
    case CardRank.RANK_10:
      return "RANK_10";
    case CardRank.RANK_J:
      return "RANK_J";
    case CardRank.RANK_Q:
      return "RANK_Q";
    case CardRank.RANK_K:
      return "RANK_K";
    case CardRank.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ChoiceCode {
  /** CHOICE_UNSPECIFIED - No choice specified. Unused. */
  CHOICE_UNSPECIFIED = 0,
  CHOICE_STAND = 1,
  CHOICE_HIT = 2,
  UNRECOGNIZED = -1,
}

export function choiceCodeFromJSON(object: any): ChoiceCode {
  switch (object) {
    case 0:
    case "CHOICE_UNSPECIFIED":
      return ChoiceCode.CHOICE_UNSPECIFIED;
    case 1:
    case "CHOICE_STAND":
      return ChoiceCode.CHOICE_STAND;
    case 2:
    case "CHOICE_HIT":
      return ChoiceCode.CHOICE_HIT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ChoiceCode.UNRECOGNIZED;
  }
}

export function choiceCodeToJSON(object: ChoiceCode): string {
  switch (object) {
    case ChoiceCode.CHOICE_UNSPECIFIED:
      return "CHOICE_UNSPECIFIED";
    case ChoiceCode.CHOICE_STAND:
      return "CHOICE_STAND";
    case ChoiceCode.CHOICE_HIT:
      return "CHOICE_HIT";
    case ChoiceCode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CardEvent {
  COMBINE = 0,
  SHOW = 1,
  DECLARE = 2,
  MOVE = 4,
  UNRECOGNIZED = -1,
}

export function cardEventFromJSON(object: any): CardEvent {
  switch (object) {
    case 0:
    case "COMBINE":
      return CardEvent.COMBINE;
    case 1:
    case "SHOW":
      return CardEvent.SHOW;
    case 2:
    case "DECLARE":
      return CardEvent.DECLARE;
    case 4:
    case "MOVE":
      return CardEvent.MOVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CardEvent.UNRECOGNIZED;
  }
}

export function cardEventToJSON(object: CardEvent): string {
  switch (object) {
    case CardEvent.COMBINE:
      return "COMBINE";
    case CardEvent.SHOW:
      return "SHOW";
    case CardEvent.DECLARE:
      return "DECLARE";
    case CardEvent.MOVE:
      return "MOVE";
    case CardEvent.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum HandRanking {
  StraightFlush = 0,
  FourOfAKind = 1,
  FullHouse = 2,
  Flush = 3,
  Straight = 4,
  ThreeOfAKind = 5,
  TwoPairs = 6,
  Pair = 7,
  HighCard = 8,
  NaturalThreeStraights = 101,
  NaturalThreeOfFlushes = 102,
  NaturalSixPairs = 103,
  NaturalFullColors = 104,
  NaturalDragon = 105,
  NaturalCleanDragon = 106,
  UNRECOGNIZED = -1,
}

export function handRankingFromJSON(object: any): HandRanking {
  switch (object) {
    case 0:
    case "StraightFlush":
      return HandRanking.StraightFlush;
    case 1:
    case "FourOfAKind":
      return HandRanking.FourOfAKind;
    case 2:
    case "FullHouse":
      return HandRanking.FullHouse;
    case 3:
    case "Flush":
      return HandRanking.Flush;
    case 4:
    case "Straight":
      return HandRanking.Straight;
    case 5:
    case "ThreeOfAKind":
      return HandRanking.ThreeOfAKind;
    case 6:
    case "TwoPairs":
      return HandRanking.TwoPairs;
    case 7:
    case "Pair":
      return HandRanking.Pair;
    case 8:
    case "HighCard":
      return HandRanking.HighCard;
    case 101:
    case "NaturalThreeStraights":
      return HandRanking.NaturalThreeStraights;
    case 102:
    case "NaturalThreeOfFlushes":
      return HandRanking.NaturalThreeOfFlushes;
    case 103:
    case "NaturalSixPairs":
      return HandRanking.NaturalSixPairs;
    case 104:
    case "NaturalFullColors":
      return HandRanking.NaturalFullColors;
    case 105:
    case "NaturalDragon":
      return HandRanking.NaturalDragon;
    case 106:
    case "NaturalCleanDragon":
      return HandRanking.NaturalCleanDragon;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HandRanking.UNRECOGNIZED;
  }
}

export function handRankingToJSON(object: HandRanking): string {
  switch (object) {
    case HandRanking.StraightFlush:
      return "StraightFlush";
    case HandRanking.FourOfAKind:
      return "FourOfAKind";
    case HandRanking.FullHouse:
      return "FullHouse";
    case HandRanking.Flush:
      return "Flush";
    case HandRanking.Straight:
      return "Straight";
    case HandRanking.ThreeOfAKind:
      return "ThreeOfAKind";
    case HandRanking.TwoPairs:
      return "TwoPairs";
    case HandRanking.Pair:
      return "Pair";
    case HandRanking.HighCard:
      return "HighCard";
    case HandRanking.NaturalThreeStraights:
      return "NaturalThreeStraights";
    case HandRanking.NaturalThreeOfFlushes:
      return "NaturalThreeOfFlushes";
    case HandRanking.NaturalSixPairs:
      return "NaturalSixPairs";
    case HandRanking.NaturalFullColors:
      return "NaturalFullColors";
    case HandRanking.NaturalDragon:
      return "NaturalDragon";
    case HandRanking.NaturalCleanDragon:
      return "NaturalCleanDragon";
    case HandRanking.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum HandBonusType {
  None = 0,
  MisSet = 1,
  Scoop = 2,
  ScoopAll = 3,
  BonusFullHouseMidHand = 101,
  BonusThreeOfAKindFrontHand = 102,
  BonusFourOfAKindBackHand = 103,
  BonusStraightFlushBackHand = 104,
  BonusFourOfAKindMidHand = 105,
  BonusStraightFlushMidHand = 106,
  BonusNaturalThreeStraights = 201,
  BonusNaturalThreeOfFlushes = 202,
  BonusNaturalSixPairs = 203,
  BonusNaturalFullColors = 204,
  BonusNaturalDragon = 205,
  BonusNaturalCleanDragon = 206,
  UNRECOGNIZED = -1,
}

export function handBonusTypeFromJSON(object: any): HandBonusType {
  switch (object) {
    case 0:
    case "None":
      return HandBonusType.None;
    case 1:
    case "MisSet":
      return HandBonusType.MisSet;
    case 2:
    case "Scoop":
      return HandBonusType.Scoop;
    case 3:
    case "ScoopAll":
      return HandBonusType.ScoopAll;
    case 101:
    case "BonusFullHouseMidHand":
      return HandBonusType.BonusFullHouseMidHand;
    case 102:
    case "BonusThreeOfAKindFrontHand":
      return HandBonusType.BonusThreeOfAKindFrontHand;
    case 103:
    case "BonusFourOfAKindBackHand":
      return HandBonusType.BonusFourOfAKindBackHand;
    case 104:
    case "BonusStraightFlushBackHand":
      return HandBonusType.BonusStraightFlushBackHand;
    case 105:
    case "BonusFourOfAKindMidHand":
      return HandBonusType.BonusFourOfAKindMidHand;
    case 106:
    case "BonusStraightFlushMidHand":
      return HandBonusType.BonusStraightFlushMidHand;
    case 201:
    case "BonusNaturalThreeStraights":
      return HandBonusType.BonusNaturalThreeStraights;
    case 202:
    case "BonusNaturalThreeOfFlushes":
      return HandBonusType.BonusNaturalThreeOfFlushes;
    case 203:
    case "BonusNaturalSixPairs":
      return HandBonusType.BonusNaturalSixPairs;
    case 204:
    case "BonusNaturalFullColors":
      return HandBonusType.BonusNaturalFullColors;
    case 205:
    case "BonusNaturalDragon":
      return HandBonusType.BonusNaturalDragon;
    case 206:
    case "BonusNaturalCleanDragon":
      return HandBonusType.BonusNaturalCleanDragon;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HandBonusType.UNRECOGNIZED;
  }
}

export function handBonusTypeToJSON(object: HandBonusType): string {
  switch (object) {
    case HandBonusType.None:
      return "None";
    case HandBonusType.MisSet:
      return "MisSet";
    case HandBonusType.Scoop:
      return "Scoop";
    case HandBonusType.ScoopAll:
      return "ScoopAll";
    case HandBonusType.BonusFullHouseMidHand:
      return "BonusFullHouseMidHand";
    case HandBonusType.BonusThreeOfAKindFrontHand:
      return "BonusThreeOfAKindFrontHand";
    case HandBonusType.BonusFourOfAKindBackHand:
      return "BonusFourOfAKindBackHand";
    case HandBonusType.BonusStraightFlushBackHand:
      return "BonusStraightFlushBackHand";
    case HandBonusType.BonusFourOfAKindMidHand:
      return "BonusFourOfAKindMidHand";
    case HandBonusType.BonusStraightFlushMidHand:
      return "BonusStraightFlushMidHand";
    case HandBonusType.BonusNaturalThreeStraights:
      return "BonusNaturalThreeStraights";
    case HandBonusType.BonusNaturalThreeOfFlushes:
      return "BonusNaturalThreeOfFlushes";
    case HandBonusType.BonusNaturalSixPairs:
      return "BonusNaturalSixPairs";
    case HandBonusType.BonusNaturalFullColors:
      return "BonusNaturalFullColors";
    case HandBonusType.BonusNaturalDragon:
      return "BonusNaturalDragon";
    case HandBonusType.BonusNaturalCleanDragon:
      return "BonusNaturalCleanDragon";
    case HandBonusType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum PointType {
  Point_Normal = 0,
  Point_Mis_Set = -1,
  Point_Natural = 1,
}

export function pointTypeFromJSON(object: any): PointType {
  switch (object) {
    case 0:
    case "Point_Normal":
      return PointType.Point_Normal;
    case -1:
    case "Point_Mis_Set":
      return PointType.Point_Mis_Set;
    case 1:
    case "Point_Natural":
      return PointType.Point_Natural;
    default:
      return PointType.Point_Mis_Set;
  }
}

export function pointTypeToJSON(object: PointType): string {
  switch (object) {
    case PointType.Point_Normal:
      return "Point_Normal";
    case PointType.Point_Mis_Set:
      return "Point_Mis_Set";
    case PointType.Point_Natural:
      return "Point_Natural";
    default:
      return "Point_Mis_Set";
  }
}

/** The card */
export interface Card {
  rank: CardRank;
  suit: CardSuit;
  status: CardStatus;
}

export interface ListCard {
  cards: Card[];
  whotCards: WhotCard[];
}

export interface NewGame {
}

export interface Organize {
  /** The current state of the cards. */
  cards: ListCard | undefined;
}

export interface PresenceCards {
  presence: string;
  cards: Card[];
  whotCards: WhotCard[];
}

export interface UpdateDeal {
  presenceCard: PresenceCards | undefined;
  cardEvent: { [key: string]: CardEvent };
  topCard: WhotCard | undefined;
  idDealer: string;
}

export interface UpdateDeal_CardEventEntry {
  key: string;
  value: CardEvent;
}

export interface UpdateGameState {
  state: GameState;
  countDown: number;
  arrangeCard: ArrangeCard | undefined;
  presenceCards: PresenceCards[];
}

export interface ArrangeCard {
  Presence: string;
  cardEvent: CardEvent;
}

export interface HandBonus {
  win: string;
  lose: string;
  type: HandBonusType;
  factor: number;
}

export interface HandResult {
  ranking: HandRanking;
  point: number;
  lpoint: number;
}

export interface PointResult {
  front: HandResult | undefined;
  middle: HandResult | undefined;
  back: HandResult | undefined;
  natural: HandResult | undefined;
  type: PointType;
}

export interface ScoreResult {
  frontFactor: number;
  middleFactor: number;
  backFactor: number;
  frontBonusFactor: number;
  middleBonusFactor: number;
  backBonusFactor: number;
  naturalFactor: number;
  /** mis set, scoop, scoop all */
  bonusFactor: number;
  scoop: number;
  numHandWin: number;
  totalFactor: number;
}

export interface ComparisonResult {
  userId: string;
  scoreResult: ScoreResult | undefined;
  pointResult: PointResult | undefined;
}

export interface UpdateFinish {
  results: ComparisonResult[];
  bonuses: HandBonus[];
  resultWhots: WhotPlayerResult[];
  jackpot: Jackpot | undefined;
  jpTreasure: Jackpot | undefined;
}

function createBaseCard(): Card {
  return { rank: 0, suit: 0, status: 0 };
}

export const Card: MessageFns<Card> = {
  encode(message: Card, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rank !== 0) {
      writer.uint32(8).int32(message.rank);
    }
    if (message.suit !== 0) {
      writer.uint32(16).int32(message.suit);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Card {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.rank = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.suit = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Card {
    return {
      rank: isSet(object.rank) ? cardRankFromJSON(object.rank) : 0,
      suit: isSet(object.suit) ? cardSuitFromJSON(object.suit) : 0,
      status: isSet(object.status) ? cardStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: Card): unknown {
    const obj: any = {};
    if (message.rank !== 0) {
      obj.rank = cardRankToJSON(message.rank);
    }
    if (message.suit !== 0) {
      obj.suit = cardSuitToJSON(message.suit);
    }
    if (message.status !== 0) {
      obj.status = cardStatusToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Card>, I>>(base?: I): Card {
    return Card.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Card>, I>>(object: I): Card {
    const message = createBaseCard();
    message.rank = object.rank ?? 0;
    message.suit = object.suit ?? 0;
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseListCard(): ListCard {
  return { cards: [], whotCards: [] };
}

export const ListCard: MessageFns<ListCard> = {
  encode(message: ListCard, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.cards) {
      Card.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.whotCards) {
      WhotCard.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCard {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cards.push(Card.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.whotCards.push(WhotCard.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCard {
    return {
      cards: globalThis.Array.isArray(object?.cards) ? object.cards.map((e: any) => Card.fromJSON(e)) : [],
      whotCards: globalThis.Array.isArray(object?.whotCards)
        ? object.whotCards.map((e: any) => WhotCard.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListCard): unknown {
    const obj: any = {};
    if (message.cards?.length) {
      obj.cards = message.cards.map((e) => Card.toJSON(e));
    }
    if (message.whotCards?.length) {
      obj.whotCards = message.whotCards.map((e) => WhotCard.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListCard>, I>>(base?: I): ListCard {
    return ListCard.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListCard>, I>>(object: I): ListCard {
    const message = createBaseListCard();
    message.cards = object.cards?.map((e) => Card.fromPartial(e)) || [];
    message.whotCards = object.whotCards?.map((e) => WhotCard.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNewGame(): NewGame {
  return {};
}

export const NewGame: MessageFns<NewGame> = {
  encode(_: NewGame, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NewGame {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNewGame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): NewGame {
    return {};
  },

  toJSON(_: NewGame): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<NewGame>, I>>(base?: I): NewGame {
    return NewGame.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NewGame>, I>>(_: I): NewGame {
    const message = createBaseNewGame();
    return message;
  },
};

function createBaseOrganize(): Organize {
  return { cards: undefined };
}

export const Organize: MessageFns<Organize> = {
  encode(message: Organize, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cards !== undefined) {
      ListCard.encode(message.cards, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Organize {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrganize();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cards = ListCard.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Organize {
    return { cards: isSet(object.cards) ? ListCard.fromJSON(object.cards) : undefined };
  },

  toJSON(message: Organize): unknown {
    const obj: any = {};
    if (message.cards !== undefined) {
      obj.cards = ListCard.toJSON(message.cards);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Organize>, I>>(base?: I): Organize {
    return Organize.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Organize>, I>>(object: I): Organize {
    const message = createBaseOrganize();
    message.cards = (object.cards !== undefined && object.cards !== null)
      ? ListCard.fromPartial(object.cards)
      : undefined;
    return message;
  },
};

function createBasePresenceCards(): PresenceCards {
  return { presence: "", cards: [], whotCards: [] };
}

export const PresenceCards: MessageFns<PresenceCards> = {
  encode(message: PresenceCards, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.presence !== "") {
      writer.uint32(10).string(message.presence);
    }
    for (const v of message.cards) {
      Card.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.whotCards) {
      WhotCard.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PresenceCards {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePresenceCards();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.presence = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cards.push(Card.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.whotCards.push(WhotCard.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PresenceCards {
    return {
      presence: isSet(object.presence) ? globalThis.String(object.presence) : "",
      cards: globalThis.Array.isArray(object?.cards) ? object.cards.map((e: any) => Card.fromJSON(e)) : [],
      whotCards: globalThis.Array.isArray(object?.whotCards)
        ? object.whotCards.map((e: any) => WhotCard.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PresenceCards): unknown {
    const obj: any = {};
    if (message.presence !== "") {
      obj.presence = message.presence;
    }
    if (message.cards?.length) {
      obj.cards = message.cards.map((e) => Card.toJSON(e));
    }
    if (message.whotCards?.length) {
      obj.whotCards = message.whotCards.map((e) => WhotCard.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PresenceCards>, I>>(base?: I): PresenceCards {
    return PresenceCards.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PresenceCards>, I>>(object: I): PresenceCards {
    const message = createBasePresenceCards();
    message.presence = object.presence ?? "";
    message.cards = object.cards?.map((e) => Card.fromPartial(e)) || [];
    message.whotCards = object.whotCards?.map((e) => WhotCard.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUpdateDeal(): UpdateDeal {
  return { presenceCard: undefined, cardEvent: {}, topCard: undefined, idDealer: "" };
}

export const UpdateDeal: MessageFns<UpdateDeal> = {
  encode(message: UpdateDeal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.presenceCard !== undefined) {
      PresenceCards.encode(message.presenceCard, writer.uint32(10).fork()).join();
    }
    Object.entries(message.cardEvent).forEach(([key, value]) => {
      UpdateDeal_CardEventEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (message.topCard !== undefined) {
      WhotCard.encode(message.topCard, writer.uint32(26).fork()).join();
    }
    if (message.idDealer !== "") {
      writer.uint32(34).string(message.idDealer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateDeal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateDeal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.presenceCard = PresenceCards.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = UpdateDeal_CardEventEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.cardEvent[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.topCard = WhotCard.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.idDealer = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateDeal {
    return {
      presenceCard: isSet(object.presenceCard) ? PresenceCards.fromJSON(object.presenceCard) : undefined,
      cardEvent: isObject(object.cardEvent)
        ? Object.entries(object.cardEvent).reduce<{ [key: string]: CardEvent }>((acc, [key, value]) => {
          acc[key] = cardEventFromJSON(value);
          return acc;
        }, {})
        : {},
      topCard: isSet(object.topCard) ? WhotCard.fromJSON(object.topCard) : undefined,
      idDealer: isSet(object.idDealer) ? globalThis.String(object.idDealer) : "",
    };
  },

  toJSON(message: UpdateDeal): unknown {
    const obj: any = {};
    if (message.presenceCard !== undefined) {
      obj.presenceCard = PresenceCards.toJSON(message.presenceCard);
    }
    if (message.cardEvent) {
      const entries = Object.entries(message.cardEvent);
      if (entries.length > 0) {
        obj.cardEvent = {};
        entries.forEach(([k, v]) => {
          obj.cardEvent[k] = cardEventToJSON(v);
        });
      }
    }
    if (message.topCard !== undefined) {
      obj.topCard = WhotCard.toJSON(message.topCard);
    }
    if (message.idDealer !== "") {
      obj.idDealer = message.idDealer;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateDeal>, I>>(base?: I): UpdateDeal {
    return UpdateDeal.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateDeal>, I>>(object: I): UpdateDeal {
    const message = createBaseUpdateDeal();
    message.presenceCard = (object.presenceCard !== undefined && object.presenceCard !== null)
      ? PresenceCards.fromPartial(object.presenceCard)
      : undefined;
    message.cardEvent = Object.entries(object.cardEvent ?? {}).reduce<{ [key: string]: CardEvent }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value as CardEvent;
        }
        return acc;
      },
      {},
    );
    message.topCard = (object.topCard !== undefined && object.topCard !== null)
      ? WhotCard.fromPartial(object.topCard)
      : undefined;
    message.idDealer = object.idDealer ?? "";
    return message;
  },
};

function createBaseUpdateDeal_CardEventEntry(): UpdateDeal_CardEventEntry {
  return { key: "", value: 0 };
}

export const UpdateDeal_CardEventEntry: MessageFns<UpdateDeal_CardEventEntry> = {
  encode(message: UpdateDeal_CardEventEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateDeal_CardEventEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateDeal_CardEventEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateDeal_CardEventEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? cardEventFromJSON(object.value) : 0,
    };
  },

  toJSON(message: UpdateDeal_CardEventEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = cardEventToJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateDeal_CardEventEntry>, I>>(base?: I): UpdateDeal_CardEventEntry {
    return UpdateDeal_CardEventEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateDeal_CardEventEntry>, I>>(object: I): UpdateDeal_CardEventEntry {
    const message = createBaseUpdateDeal_CardEventEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseUpdateGameState(): UpdateGameState {
  return { state: 0, countDown: 0, arrangeCard: undefined, presenceCards: [] };
}

export const UpdateGameState: MessageFns<UpdateGameState> = {
  encode(message: UpdateGameState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    if (message.countDown !== 0) {
      writer.uint32(16).int64(message.countDown);
    }
    if (message.arrangeCard !== undefined) {
      ArrangeCard.encode(message.arrangeCard, writer.uint32(26).fork()).join();
    }
    for (const v of message.presenceCards) {
      PresenceCards.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateGameState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateGameState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.countDown = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.arrangeCard = ArrangeCard.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.presenceCards.push(PresenceCards.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateGameState {
    return {
      state: isSet(object.state) ? gameStateFromJSON(object.state) : 0,
      countDown: isSet(object.countDown) ? globalThis.Number(object.countDown) : 0,
      arrangeCard: isSet(object.arrangeCard) ? ArrangeCard.fromJSON(object.arrangeCard) : undefined,
      presenceCards: globalThis.Array.isArray(object?.presenceCards)
        ? object.presenceCards.map((e: any) => PresenceCards.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UpdateGameState): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = gameStateToJSON(message.state);
    }
    if (message.countDown !== 0) {
      obj.countDown = Math.round(message.countDown);
    }
    if (message.arrangeCard !== undefined) {
      obj.arrangeCard = ArrangeCard.toJSON(message.arrangeCard);
    }
    if (message.presenceCards?.length) {
      obj.presenceCards = message.presenceCards.map((e) => PresenceCards.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateGameState>, I>>(base?: I): UpdateGameState {
    return UpdateGameState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateGameState>, I>>(object: I): UpdateGameState {
    const message = createBaseUpdateGameState();
    message.state = object.state ?? 0;
    message.countDown = object.countDown ?? 0;
    message.arrangeCard = (object.arrangeCard !== undefined && object.arrangeCard !== null)
      ? ArrangeCard.fromPartial(object.arrangeCard)
      : undefined;
    message.presenceCards = object.presenceCards?.map((e) => PresenceCards.fromPartial(e)) || [];
    return message;
  },
};

function createBaseArrangeCard(): ArrangeCard {
  return { Presence: "", cardEvent: 0 };
}

export const ArrangeCard: MessageFns<ArrangeCard> = {
  encode(message: ArrangeCard, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Presence !== "") {
      writer.uint32(10).string(message.Presence);
    }
    if (message.cardEvent !== 0) {
      writer.uint32(16).int32(message.cardEvent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ArrangeCard {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArrangeCard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Presence = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.cardEvent = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ArrangeCard {
    return {
      Presence: isSet(object.Presence) ? globalThis.String(object.Presence) : "",
      cardEvent: isSet(object.cardEvent) ? cardEventFromJSON(object.cardEvent) : 0,
    };
  },

  toJSON(message: ArrangeCard): unknown {
    const obj: any = {};
    if (message.Presence !== "") {
      obj.Presence = message.Presence;
    }
    if (message.cardEvent !== 0) {
      obj.cardEvent = cardEventToJSON(message.cardEvent);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ArrangeCard>, I>>(base?: I): ArrangeCard {
    return ArrangeCard.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ArrangeCard>, I>>(object: I): ArrangeCard {
    const message = createBaseArrangeCard();
    message.Presence = object.Presence ?? "";
    message.cardEvent = object.cardEvent ?? 0;
    return message;
  },
};

function createBaseHandBonus(): HandBonus {
  return { win: "", lose: "", type: 0, factor: 0 };
}

export const HandBonus: MessageFns<HandBonus> = {
  encode(message: HandBonus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.win !== "") {
      writer.uint32(10).string(message.win);
    }
    if (message.lose !== "") {
      writer.uint32(18).string(message.lose);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.factor !== 0) {
      writer.uint32(32).int64(message.factor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HandBonus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHandBonus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.win = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.lose = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.factor = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HandBonus {
    return {
      win: isSet(object.win) ? globalThis.String(object.win) : "",
      lose: isSet(object.lose) ? globalThis.String(object.lose) : "",
      type: isSet(object.type) ? handBonusTypeFromJSON(object.type) : 0,
      factor: isSet(object.factor) ? globalThis.Number(object.factor) : 0,
    };
  },

  toJSON(message: HandBonus): unknown {
    const obj: any = {};
    if (message.win !== "") {
      obj.win = message.win;
    }
    if (message.lose !== "") {
      obj.lose = message.lose;
    }
    if (message.type !== 0) {
      obj.type = handBonusTypeToJSON(message.type);
    }
    if (message.factor !== 0) {
      obj.factor = Math.round(message.factor);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HandBonus>, I>>(base?: I): HandBonus {
    return HandBonus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HandBonus>, I>>(object: I): HandBonus {
    const message = createBaseHandBonus();
    message.win = object.win ?? "";
    message.lose = object.lose ?? "";
    message.type = object.type ?? 0;
    message.factor = object.factor ?? 0;
    return message;
  },
};

function createBaseHandResult(): HandResult {
  return { ranking: 0, point: 0, lpoint: 0 };
}

export const HandResult: MessageFns<HandResult> = {
  encode(message: HandResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ranking !== 0) {
      writer.uint32(8).int32(message.ranking);
    }
    if (message.point !== 0) {
      writer.uint32(16).uint64(message.point);
    }
    if (message.lpoint !== 0) {
      writer.uint32(24).uint64(message.lpoint);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HandResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHandResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.ranking = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.point = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.lpoint = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HandResult {
    return {
      ranking: isSet(object.ranking) ? handRankingFromJSON(object.ranking) : 0,
      point: isSet(object.point) ? globalThis.Number(object.point) : 0,
      lpoint: isSet(object.lpoint) ? globalThis.Number(object.lpoint) : 0,
    };
  },

  toJSON(message: HandResult): unknown {
    const obj: any = {};
    if (message.ranking !== 0) {
      obj.ranking = handRankingToJSON(message.ranking);
    }
    if (message.point !== 0) {
      obj.point = Math.round(message.point);
    }
    if (message.lpoint !== 0) {
      obj.lpoint = Math.round(message.lpoint);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HandResult>, I>>(base?: I): HandResult {
    return HandResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HandResult>, I>>(object: I): HandResult {
    const message = createBaseHandResult();
    message.ranking = object.ranking ?? 0;
    message.point = object.point ?? 0;
    message.lpoint = object.lpoint ?? 0;
    return message;
  },
};

function createBasePointResult(): PointResult {
  return { front: undefined, middle: undefined, back: undefined, natural: undefined, type: 0 };
}

export const PointResult: MessageFns<PointResult> = {
  encode(message: PointResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.front !== undefined) {
      HandResult.encode(message.front, writer.uint32(10).fork()).join();
    }
    if (message.middle !== undefined) {
      HandResult.encode(message.middle, writer.uint32(18).fork()).join();
    }
    if (message.back !== undefined) {
      HandResult.encode(message.back, writer.uint32(26).fork()).join();
    }
    if (message.natural !== undefined) {
      HandResult.encode(message.natural, writer.uint32(34).fork()).join();
    }
    if (message.type !== 0) {
      writer.uint32(40).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PointResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePointResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.front = HandResult.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.middle = HandResult.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.back = HandResult.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.natural = HandResult.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PointResult {
    return {
      front: isSet(object.front) ? HandResult.fromJSON(object.front) : undefined,
      middle: isSet(object.middle) ? HandResult.fromJSON(object.middle) : undefined,
      back: isSet(object.back) ? HandResult.fromJSON(object.back) : undefined,
      natural: isSet(object.natural) ? HandResult.fromJSON(object.natural) : undefined,
      type: isSet(object.type) ? pointTypeFromJSON(object.type) : 0,
    };
  },

  toJSON(message: PointResult): unknown {
    const obj: any = {};
    if (message.front !== undefined) {
      obj.front = HandResult.toJSON(message.front);
    }
    if (message.middle !== undefined) {
      obj.middle = HandResult.toJSON(message.middle);
    }
    if (message.back !== undefined) {
      obj.back = HandResult.toJSON(message.back);
    }
    if (message.natural !== undefined) {
      obj.natural = HandResult.toJSON(message.natural);
    }
    if (message.type !== 0) {
      obj.type = pointTypeToJSON(message.type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PointResult>, I>>(base?: I): PointResult {
    return PointResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PointResult>, I>>(object: I): PointResult {
    const message = createBasePointResult();
    message.front = (object.front !== undefined && object.front !== null)
      ? HandResult.fromPartial(object.front)
      : undefined;
    message.middle = (object.middle !== undefined && object.middle !== null)
      ? HandResult.fromPartial(object.middle)
      : undefined;
    message.back = (object.back !== undefined && object.back !== null)
      ? HandResult.fromPartial(object.back)
      : undefined;
    message.natural = (object.natural !== undefined && object.natural !== null)
      ? HandResult.fromPartial(object.natural)
      : undefined;
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseScoreResult(): ScoreResult {
  return {
    frontFactor: 0,
    middleFactor: 0,
    backFactor: 0,
    frontBonusFactor: 0,
    middleBonusFactor: 0,
    backBonusFactor: 0,
    naturalFactor: 0,
    bonusFactor: 0,
    scoop: 0,
    numHandWin: 0,
    totalFactor: 0,
  };
}

export const ScoreResult: MessageFns<ScoreResult> = {
  encode(message: ScoreResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.frontFactor !== 0) {
      writer.uint32(8).int64(message.frontFactor);
    }
    if (message.middleFactor !== 0) {
      writer.uint32(16).int64(message.middleFactor);
    }
    if (message.backFactor !== 0) {
      writer.uint32(24).int64(message.backFactor);
    }
    if (message.frontBonusFactor !== 0) {
      writer.uint32(32).int64(message.frontBonusFactor);
    }
    if (message.middleBonusFactor !== 0) {
      writer.uint32(40).int64(message.middleBonusFactor);
    }
    if (message.backBonusFactor !== 0) {
      writer.uint32(48).int64(message.backBonusFactor);
    }
    if (message.naturalFactor !== 0) {
      writer.uint32(56).int64(message.naturalFactor);
    }
    if (message.bonusFactor !== 0) {
      writer.uint32(64).int64(message.bonusFactor);
    }
    if (message.scoop !== 0) {
      writer.uint32(72).int64(message.scoop);
    }
    if (message.numHandWin !== 0) {
      writer.uint32(80).int32(message.numHandWin);
    }
    if (message.totalFactor !== 0) {
      writer.uint32(88).int64(message.totalFactor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScoreResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScoreResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.frontFactor = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.middleFactor = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.backFactor = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.frontBonusFactor = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.middleBonusFactor = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.backBonusFactor = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.naturalFactor = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.bonusFactor = longToNumber(reader.int64());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.scoop = longToNumber(reader.int64());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.numHandWin = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.totalFactor = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScoreResult {
    return {
      frontFactor: isSet(object.frontFactor) ? globalThis.Number(object.frontFactor) : 0,
      middleFactor: isSet(object.middleFactor) ? globalThis.Number(object.middleFactor) : 0,
      backFactor: isSet(object.backFactor) ? globalThis.Number(object.backFactor) : 0,
      frontBonusFactor: isSet(object.frontBonusFactor) ? globalThis.Number(object.frontBonusFactor) : 0,
      middleBonusFactor: isSet(object.middleBonusFactor) ? globalThis.Number(object.middleBonusFactor) : 0,
      backBonusFactor: isSet(object.backBonusFactor) ? globalThis.Number(object.backBonusFactor) : 0,
      naturalFactor: isSet(object.naturalFactor) ? globalThis.Number(object.naturalFactor) : 0,
      bonusFactor: isSet(object.bonusFactor) ? globalThis.Number(object.bonusFactor) : 0,
      scoop: isSet(object.scoop) ? globalThis.Number(object.scoop) : 0,
      numHandWin: isSet(object.numHandWin) ? globalThis.Number(object.numHandWin) : 0,
      totalFactor: isSet(object.totalFactor) ? globalThis.Number(object.totalFactor) : 0,
    };
  },

  toJSON(message: ScoreResult): unknown {
    const obj: any = {};
    if (message.frontFactor !== 0) {
      obj.frontFactor = Math.round(message.frontFactor);
    }
    if (message.middleFactor !== 0) {
      obj.middleFactor = Math.round(message.middleFactor);
    }
    if (message.backFactor !== 0) {
      obj.backFactor = Math.round(message.backFactor);
    }
    if (message.frontBonusFactor !== 0) {
      obj.frontBonusFactor = Math.round(message.frontBonusFactor);
    }
    if (message.middleBonusFactor !== 0) {
      obj.middleBonusFactor = Math.round(message.middleBonusFactor);
    }
    if (message.backBonusFactor !== 0) {
      obj.backBonusFactor = Math.round(message.backBonusFactor);
    }
    if (message.naturalFactor !== 0) {
      obj.naturalFactor = Math.round(message.naturalFactor);
    }
    if (message.bonusFactor !== 0) {
      obj.bonusFactor = Math.round(message.bonusFactor);
    }
    if (message.scoop !== 0) {
      obj.scoop = Math.round(message.scoop);
    }
    if (message.numHandWin !== 0) {
      obj.numHandWin = Math.round(message.numHandWin);
    }
    if (message.totalFactor !== 0) {
      obj.totalFactor = Math.round(message.totalFactor);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScoreResult>, I>>(base?: I): ScoreResult {
    return ScoreResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScoreResult>, I>>(object: I): ScoreResult {
    const message = createBaseScoreResult();
    message.frontFactor = object.frontFactor ?? 0;
    message.middleFactor = object.middleFactor ?? 0;
    message.backFactor = object.backFactor ?? 0;
    message.frontBonusFactor = object.frontBonusFactor ?? 0;
    message.middleBonusFactor = object.middleBonusFactor ?? 0;
    message.backBonusFactor = object.backBonusFactor ?? 0;
    message.naturalFactor = object.naturalFactor ?? 0;
    message.bonusFactor = object.bonusFactor ?? 0;
    message.scoop = object.scoop ?? 0;
    message.numHandWin = object.numHandWin ?? 0;
    message.totalFactor = object.totalFactor ?? 0;
    return message;
  },
};

function createBaseComparisonResult(): ComparisonResult {
  return { userId: "", scoreResult: undefined, pointResult: undefined };
}

export const ComparisonResult: MessageFns<ComparisonResult> = {
  encode(message: ComparisonResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.scoreResult !== undefined) {
      ScoreResult.encode(message.scoreResult, writer.uint32(18).fork()).join();
    }
    if (message.pointResult !== undefined) {
      PointResult.encode(message.pointResult, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComparisonResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComparisonResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.scoreResult = ScoreResult.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pointResult = PointResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComparisonResult {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      scoreResult: isSet(object.scoreResult) ? ScoreResult.fromJSON(object.scoreResult) : undefined,
      pointResult: isSet(object.pointResult) ? PointResult.fromJSON(object.pointResult) : undefined,
    };
  },

  toJSON(message: ComparisonResult): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.scoreResult !== undefined) {
      obj.scoreResult = ScoreResult.toJSON(message.scoreResult);
    }
    if (message.pointResult !== undefined) {
      obj.pointResult = PointResult.toJSON(message.pointResult);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ComparisonResult>, I>>(base?: I): ComparisonResult {
    return ComparisonResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ComparisonResult>, I>>(object: I): ComparisonResult {
    const message = createBaseComparisonResult();
    message.userId = object.userId ?? "";
    message.scoreResult = (object.scoreResult !== undefined && object.scoreResult !== null)
      ? ScoreResult.fromPartial(object.scoreResult)
      : undefined;
    message.pointResult = (object.pointResult !== undefined && object.pointResult !== null)
      ? PointResult.fromPartial(object.pointResult)
      : undefined;
    return message;
  },
};

function createBaseUpdateFinish(): UpdateFinish {
  return { results: [], bonuses: [], resultWhots: [], jackpot: undefined, jpTreasure: undefined };
}

export const UpdateFinish: MessageFns<UpdateFinish> = {
  encode(message: UpdateFinish, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.results) {
      ComparisonResult.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.bonuses) {
      HandBonus.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.resultWhots) {
      WhotPlayerResult.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.jackpot !== undefined) {
      Jackpot.encode(message.jackpot, writer.uint32(34).fork()).join();
    }
    if (message.jpTreasure !== undefined) {
      Jackpot.encode(message.jpTreasure, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateFinish {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateFinish();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.results.push(ComparisonResult.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bonuses.push(HandBonus.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.resultWhots.push(WhotPlayerResult.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.jackpot = Jackpot.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.jpTreasure = Jackpot.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateFinish {
    return {
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => ComparisonResult.fromJSON(e))
        : [],
      bonuses: globalThis.Array.isArray(object?.bonuses) ? object.bonuses.map((e: any) => HandBonus.fromJSON(e)) : [],
      resultWhots: globalThis.Array.isArray(object?.resultWhots)
        ? object.resultWhots.map((e: any) => WhotPlayerResult.fromJSON(e))
        : [],
      jackpot: isSet(object.jackpot) ? Jackpot.fromJSON(object.jackpot) : undefined,
      jpTreasure: isSet(object.jpTreasure) ? Jackpot.fromJSON(object.jpTreasure) : undefined,
    };
  },

  toJSON(message: UpdateFinish): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => ComparisonResult.toJSON(e));
    }
    if (message.bonuses?.length) {
      obj.bonuses = message.bonuses.map((e) => HandBonus.toJSON(e));
    }
    if (message.resultWhots?.length) {
      obj.resultWhots = message.resultWhots.map((e) => WhotPlayerResult.toJSON(e));
    }
    if (message.jackpot !== undefined) {
      obj.jackpot = Jackpot.toJSON(message.jackpot);
    }
    if (message.jpTreasure !== undefined) {
      obj.jpTreasure = Jackpot.toJSON(message.jpTreasure);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateFinish>, I>>(base?: I): UpdateFinish {
    return UpdateFinish.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateFinish>, I>>(object: I): UpdateFinish {
    const message = createBaseUpdateFinish();
    message.results = object.results?.map((e) => ComparisonResult.fromPartial(e)) || [];
    message.bonuses = object.bonuses?.map((e) => HandBonus.fromPartial(e)) || [];
    message.resultWhots = object.resultWhots?.map((e) => WhotPlayerResult.fromPartial(e)) || [];
    message.jackpot = (object.jackpot !== undefined && object.jackpot !== null)
      ? Jackpot.fromPartial(object.jackpot)
      : undefined;
    message.jpTreasure = (object.jpTreasure !== undefined && object.jpTreasure !== null)
      ? Jackpot.fromPartial(object.jpTreasure)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
