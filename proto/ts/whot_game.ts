// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: whot_game.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "proto";

export enum WhotCardSuit {
  WHOT_SUIT_UNSPECIFIED = 0,
  WHOT_SUIT_CIRCLE = 1,
  WHOT_SUIT_CROSS = 2,
  WHOT_SUIT_STAR = 3,
  WHOT_SUIT_SQUARE = 4,
  WHOT_SUIT_TRIANGLE = 5,
  UNRECOGNIZED = -1,
}

export function whotCardSuitFromJSON(object: any): WhotCardSuit {
  switch (object) {
    case 0:
    case "WHOT_SUIT_UNSPECIFIED":
      return WhotCardSuit.WHOT_SUIT_UNSPECIFIED;
    case 1:
    case "WHOT_SUIT_CIRCLE":
      return WhotCardSuit.WHOT_SUIT_CIRCLE;
    case 2:
    case "WHOT_SUIT_CROSS":
      return WhotCardSuit.WHOT_SUIT_CROSS;
    case 3:
    case "WHOT_SUIT_STAR":
      return WhotCardSuit.WHOT_SUIT_STAR;
    case 4:
    case "WHOT_SUIT_SQUARE":
      return WhotCardSuit.WHOT_SUIT_SQUARE;
    case 5:
    case "WHOT_SUIT_TRIANGLE":
      return WhotCardSuit.WHOT_SUIT_TRIANGLE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WhotCardSuit.UNRECOGNIZED;
  }
}

export function whotCardSuitToJSON(object: WhotCardSuit): string {
  switch (object) {
    case WhotCardSuit.WHOT_SUIT_UNSPECIFIED:
      return "WHOT_SUIT_UNSPECIFIED";
    case WhotCardSuit.WHOT_SUIT_CIRCLE:
      return "WHOT_SUIT_CIRCLE";
    case WhotCardSuit.WHOT_SUIT_CROSS:
      return "WHOT_SUIT_CROSS";
    case WhotCardSuit.WHOT_SUIT_STAR:
      return "WHOT_SUIT_STAR";
    case WhotCardSuit.WHOT_SUIT_SQUARE:
      return "WHOT_SUIT_SQUARE";
    case WhotCardSuit.WHOT_SUIT_TRIANGLE:
      return "WHOT_SUIT_TRIANGLE";
    case WhotCardSuit.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum WhotCardRank {
  WHOT_RANK_UNSPECIFIED = 0,
  WHOT_RANK_1 = 1,
  WHOT_RANK_2 = 2,
  WHOT_RANK_3 = 3,
  WHOT_RANK_4 = 4,
  WHOT_RANK_5 = 5,
  WHOT_RANK_7 = 7,
  WHOT_RANK_8 = 8,
  WHOT_RANK_10 = 10,
  WHOT_RANK_11 = 11,
  WHOT_RANK_12 = 12,
  WHOT_RANK_13 = 13,
  WHOT_RANK_14 = 14,
  WHOT_RANK_20 = 20,
  UNRECOGNIZED = -1,
}

export function whotCardRankFromJSON(object: any): WhotCardRank {
  switch (object) {
    case 0:
    case "WHOT_RANK_UNSPECIFIED":
      return WhotCardRank.WHOT_RANK_UNSPECIFIED;
    case 1:
    case "WHOT_RANK_1":
      return WhotCardRank.WHOT_RANK_1;
    case 2:
    case "WHOT_RANK_2":
      return WhotCardRank.WHOT_RANK_2;
    case 3:
    case "WHOT_RANK_3":
      return WhotCardRank.WHOT_RANK_3;
    case 4:
    case "WHOT_RANK_4":
      return WhotCardRank.WHOT_RANK_4;
    case 5:
    case "WHOT_RANK_5":
      return WhotCardRank.WHOT_RANK_5;
    case 7:
    case "WHOT_RANK_7":
      return WhotCardRank.WHOT_RANK_7;
    case 8:
    case "WHOT_RANK_8":
      return WhotCardRank.WHOT_RANK_8;
    case 10:
    case "WHOT_RANK_10":
      return WhotCardRank.WHOT_RANK_10;
    case 11:
    case "WHOT_RANK_11":
      return WhotCardRank.WHOT_RANK_11;
    case 12:
    case "WHOT_RANK_12":
      return WhotCardRank.WHOT_RANK_12;
    case 13:
    case "WHOT_RANK_13":
      return WhotCardRank.WHOT_RANK_13;
    case 14:
    case "WHOT_RANK_14":
      return WhotCardRank.WHOT_RANK_14;
    case 20:
    case "WHOT_RANK_20":
      return WhotCardRank.WHOT_RANK_20;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WhotCardRank.UNRECOGNIZED;
  }
}

export function whotCardRankToJSON(object: WhotCardRank): string {
  switch (object) {
    case WhotCardRank.WHOT_RANK_UNSPECIFIED:
      return "WHOT_RANK_UNSPECIFIED";
    case WhotCardRank.WHOT_RANK_1:
      return "WHOT_RANK_1";
    case WhotCardRank.WHOT_RANK_2:
      return "WHOT_RANK_2";
    case WhotCardRank.WHOT_RANK_3:
      return "WHOT_RANK_3";
    case WhotCardRank.WHOT_RANK_4:
      return "WHOT_RANK_4";
    case WhotCardRank.WHOT_RANK_5:
      return "WHOT_RANK_5";
    case WhotCardRank.WHOT_RANK_7:
      return "WHOT_RANK_7";
    case WhotCardRank.WHOT_RANK_8:
      return "WHOT_RANK_8";
    case WhotCardRank.WHOT_RANK_10:
      return "WHOT_RANK_10";
    case WhotCardRank.WHOT_RANK_11:
      return "WHOT_RANK_11";
    case WhotCardRank.WHOT_RANK_12:
      return "WHOT_RANK_12";
    case WhotCardRank.WHOT_RANK_13:
      return "WHOT_RANK_13";
    case WhotCardRank.WHOT_RANK_14:
      return "WHOT_RANK_14";
    case WhotCardRank.WHOT_RANK_20:
      return "WHOT_RANK_20";
    case WhotCardRank.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum WhotCardEvent {
  WHOT_EVENT_NONE = 0,
  WHOT_EVENT_PLAY = 1,
  WHOT_EVENT_DRAW = 2,
  WHOT_EVENT_PASS = 3,
  WHOT_EVENT_AUTO_PLAY = 4,
  UNRECOGNIZED = -1,
}

export function whotCardEventFromJSON(object: any): WhotCardEvent {
  switch (object) {
    case 0:
    case "WHOT_EVENT_NONE":
      return WhotCardEvent.WHOT_EVENT_NONE;
    case 1:
    case "WHOT_EVENT_PLAY":
      return WhotCardEvent.WHOT_EVENT_PLAY;
    case 2:
    case "WHOT_EVENT_DRAW":
      return WhotCardEvent.WHOT_EVENT_DRAW;
    case 3:
    case "WHOT_EVENT_PASS":
      return WhotCardEvent.WHOT_EVENT_PASS;
    case 4:
    case "WHOT_EVENT_AUTO_PLAY":
      return WhotCardEvent.WHOT_EVENT_AUTO_PLAY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WhotCardEvent.UNRECOGNIZED;
  }
}

export function whotCardEventToJSON(object: WhotCardEvent): string {
  switch (object) {
    case WhotCardEvent.WHOT_EVENT_NONE:
      return "WHOT_EVENT_NONE";
    case WhotCardEvent.WHOT_EVENT_PLAY:
      return "WHOT_EVENT_PLAY";
    case WhotCardEvent.WHOT_EVENT_DRAW:
      return "WHOT_EVENT_DRAW";
    case WhotCardEvent.WHOT_EVENT_PASS:
      return "WHOT_EVENT_PASS";
    case WhotCardEvent.WHOT_EVENT_AUTO_PLAY:
      return "WHOT_EVENT_AUTO_PLAY";
    case WhotCardEvent.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum WhotCardEffect {
  EFFECT_NONE = 0,
  HOLD_ON = 1,
  PICK_TWO = 2,
  PICK_THREE = 3,
  SUSPENSION = 4,
  GENERAL_MARKET = 5,
  WHOT = 6,
  CHOICE_SHAPE_GHOST = 7,
  UNRECOGNIZED = -1,
}

export function whotCardEffectFromJSON(object: any): WhotCardEffect {
  switch (object) {
    case 0:
    case "EFFECT_NONE":
      return WhotCardEffect.EFFECT_NONE;
    case 1:
    case "HOLD_ON":
      return WhotCardEffect.HOLD_ON;
    case 2:
    case "PICK_TWO":
      return WhotCardEffect.PICK_TWO;
    case 3:
    case "PICK_THREE":
      return WhotCardEffect.PICK_THREE;
    case 4:
    case "SUSPENSION":
      return WhotCardEffect.SUSPENSION;
    case 5:
    case "GENERAL_MARKET":
      return WhotCardEffect.GENERAL_MARKET;
    case 6:
    case "WHOT":
      return WhotCardEffect.WHOT;
    case 7:
    case "CHOICE_SHAPE_GHOST":
      return WhotCardEffect.CHOICE_SHAPE_GHOST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WhotCardEffect.UNRECOGNIZED;
  }
}

export function whotCardEffectToJSON(object: WhotCardEffect): string {
  switch (object) {
    case WhotCardEffect.EFFECT_NONE:
      return "EFFECT_NONE";
    case WhotCardEffect.HOLD_ON:
      return "HOLD_ON";
    case WhotCardEffect.PICK_TWO:
      return "PICK_TWO";
    case WhotCardEffect.PICK_THREE:
      return "PICK_THREE";
    case WhotCardEffect.SUSPENSION:
      return "SUSPENSION";
    case WhotCardEffect.GENERAL_MARKET:
      return "GENERAL_MARKET";
    case WhotCardEffect.WHOT:
      return "WHOT";
    case WhotCardEffect.CHOICE_SHAPE_GHOST:
      return "CHOICE_SHAPE_GHOST";
    case WhotCardEffect.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface WhotCard {
  rank: WhotCardRank;
  suit: WhotCardSuit;
}

export interface UpdateTurn {
  userId: string;
  countdown: number;
}

export interface UpdateCardState {
  userId: string;
  event: WhotCardEvent;
  playedCard: WhotCard | undefined;
  topCard: WhotCard | undefined;
  cardsAfter: WhotCard[];
  effect: WhotCardEffect;
  pickPenalty: number;
  targetUserId: string;
  isAutoPlay: boolean;
  deckCount: number;
  playerCardCounts: { [key: string]: number };
}

export interface UpdateCardState_PlayerCardCountsEntry {
  key: string;
  value: number;
}

export interface WhotPlayerResult {
  userId: string;
  totalPoints: number;
  winFactor: number;
  isWinner: boolean;
  remainingCards: WhotCard[];
}

function createBaseWhotCard(): WhotCard {
  return { rank: 0, suit: 0 };
}

export const WhotCard: MessageFns<WhotCard> = {
  encode(message: WhotCard, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rank !== 0) {
      writer.uint32(8).int32(message.rank);
    }
    if (message.suit !== 0) {
      writer.uint32(16).int32(message.suit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WhotCard {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWhotCard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.rank = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.suit = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WhotCard {
    return {
      rank: isSet(object.rank) ? whotCardRankFromJSON(object.rank) : 0,
      suit: isSet(object.suit) ? whotCardSuitFromJSON(object.suit) : 0,
    };
  },

  toJSON(message: WhotCard): unknown {
    const obj: any = {};
    if (message.rank !== 0) {
      obj.rank = whotCardRankToJSON(message.rank);
    }
    if (message.suit !== 0) {
      obj.suit = whotCardSuitToJSON(message.suit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WhotCard>, I>>(base?: I): WhotCard {
    return WhotCard.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WhotCard>, I>>(object: I): WhotCard {
    const message = createBaseWhotCard();
    message.rank = object.rank ?? 0;
    message.suit = object.suit ?? 0;
    return message;
  },
};

function createBaseUpdateTurn(): UpdateTurn {
  return { userId: "", countdown: 0 };
}

export const UpdateTurn: MessageFns<UpdateTurn> = {
  encode(message: UpdateTurn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.countdown !== 0) {
      writer.uint32(16).int64(message.countdown);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateTurn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateTurn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.countdown = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateTurn {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      countdown: isSet(object.countdown) ? globalThis.Number(object.countdown) : 0,
    };
  },

  toJSON(message: UpdateTurn): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.countdown !== 0) {
      obj.countdown = Math.round(message.countdown);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateTurn>, I>>(base?: I): UpdateTurn {
    return UpdateTurn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateTurn>, I>>(object: I): UpdateTurn {
    const message = createBaseUpdateTurn();
    message.userId = object.userId ?? "";
    message.countdown = object.countdown ?? 0;
    return message;
  },
};

function createBaseUpdateCardState(): UpdateCardState {
  return {
    userId: "",
    event: 0,
    playedCard: undefined,
    topCard: undefined,
    cardsAfter: [],
    effect: 0,
    pickPenalty: 0,
    targetUserId: "",
    isAutoPlay: false,
    deckCount: 0,
    playerCardCounts: {},
  };
}

export const UpdateCardState: MessageFns<UpdateCardState> = {
  encode(message: UpdateCardState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.event !== 0) {
      writer.uint32(16).int32(message.event);
    }
    if (message.playedCard !== undefined) {
      WhotCard.encode(message.playedCard, writer.uint32(26).fork()).join();
    }
    if (message.topCard !== undefined) {
      WhotCard.encode(message.topCard, writer.uint32(34).fork()).join();
    }
    for (const v of message.cardsAfter) {
      WhotCard.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.effect !== 0) {
      writer.uint32(48).int32(message.effect);
    }
    if (message.pickPenalty !== 0) {
      writer.uint32(56).int32(message.pickPenalty);
    }
    if (message.targetUserId !== "") {
      writer.uint32(66).string(message.targetUserId);
    }
    if (message.isAutoPlay !== false) {
      writer.uint32(72).bool(message.isAutoPlay);
    }
    if (message.deckCount !== 0) {
      writer.uint32(80).int32(message.deckCount);
    }
    Object.entries(message.playerCardCounts).forEach(([key, value]) => {
      UpdateCardState_PlayerCardCountsEntry.encode({ key: key as any, value }, writer.uint32(90).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateCardState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCardState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.event = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.playedCard = WhotCard.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.topCard = WhotCard.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.cardsAfter.push(WhotCard.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.effect = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.pickPenalty = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.targetUserId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.isAutoPlay = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.deckCount = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          const entry11 = UpdateCardState_PlayerCardCountsEntry.decode(reader, reader.uint32());
          if (entry11.value !== undefined) {
            message.playerCardCounts[entry11.key] = entry11.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCardState {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      event: isSet(object.event) ? whotCardEventFromJSON(object.event) : 0,
      playedCard: isSet(object.playedCard) ? WhotCard.fromJSON(object.playedCard) : undefined,
      topCard: isSet(object.topCard) ? WhotCard.fromJSON(object.topCard) : undefined,
      cardsAfter: globalThis.Array.isArray(object?.cardsAfter)
        ? object.cardsAfter.map((e: any) => WhotCard.fromJSON(e))
        : [],
      effect: isSet(object.effect) ? whotCardEffectFromJSON(object.effect) : 0,
      pickPenalty: isSet(object.pickPenalty) ? globalThis.Number(object.pickPenalty) : 0,
      targetUserId: isSet(object.targetUserId) ? globalThis.String(object.targetUserId) : "",
      isAutoPlay: isSet(object.isAutoPlay) ? globalThis.Boolean(object.isAutoPlay) : false,
      deckCount: isSet(object.deckCount) ? globalThis.Number(object.deckCount) : 0,
      playerCardCounts: isObject(object.playerCardCounts)
        ? Object.entries(object.playerCardCounts).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: UpdateCardState): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.event !== 0) {
      obj.event = whotCardEventToJSON(message.event);
    }
    if (message.playedCard !== undefined) {
      obj.playedCard = WhotCard.toJSON(message.playedCard);
    }
    if (message.topCard !== undefined) {
      obj.topCard = WhotCard.toJSON(message.topCard);
    }
    if (message.cardsAfter?.length) {
      obj.cardsAfter = message.cardsAfter.map((e) => WhotCard.toJSON(e));
    }
    if (message.effect !== 0) {
      obj.effect = whotCardEffectToJSON(message.effect);
    }
    if (message.pickPenalty !== 0) {
      obj.pickPenalty = Math.round(message.pickPenalty);
    }
    if (message.targetUserId !== "") {
      obj.targetUserId = message.targetUserId;
    }
    if (message.isAutoPlay !== false) {
      obj.isAutoPlay = message.isAutoPlay;
    }
    if (message.deckCount !== 0) {
      obj.deckCount = Math.round(message.deckCount);
    }
    if (message.playerCardCounts) {
      const entries = Object.entries(message.playerCardCounts);
      if (entries.length > 0) {
        obj.playerCardCounts = {};
        entries.forEach(([k, v]) => {
          obj.playerCardCounts[k] = Math.round(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateCardState>, I>>(base?: I): UpdateCardState {
    return UpdateCardState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateCardState>, I>>(object: I): UpdateCardState {
    const message = createBaseUpdateCardState();
    message.userId = object.userId ?? "";
    message.event = object.event ?? 0;
    message.playedCard = (object.playedCard !== undefined && object.playedCard !== null)
      ? WhotCard.fromPartial(object.playedCard)
      : undefined;
    message.topCard = (object.topCard !== undefined && object.topCard !== null)
      ? WhotCard.fromPartial(object.topCard)
      : undefined;
    message.cardsAfter = object.cardsAfter?.map((e) => WhotCard.fromPartial(e)) || [];
    message.effect = object.effect ?? 0;
    message.pickPenalty = object.pickPenalty ?? 0;
    message.targetUserId = object.targetUserId ?? "";
    message.isAutoPlay = object.isAutoPlay ?? false;
    message.deckCount = object.deckCount ?? 0;
    message.playerCardCounts = Object.entries(object.playerCardCounts ?? {}).reduce<{ [key: string]: number }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.Number(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseUpdateCardState_PlayerCardCountsEntry(): UpdateCardState_PlayerCardCountsEntry {
  return { key: "", value: 0 };
}

export const UpdateCardState_PlayerCardCountsEntry: MessageFns<UpdateCardState_PlayerCardCountsEntry> = {
  encode(message: UpdateCardState_PlayerCardCountsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateCardState_PlayerCardCountsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCardState_PlayerCardCountsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCardState_PlayerCardCountsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: UpdateCardState_PlayerCardCountsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateCardState_PlayerCardCountsEntry>, I>>(
    base?: I,
  ): UpdateCardState_PlayerCardCountsEntry {
    return UpdateCardState_PlayerCardCountsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateCardState_PlayerCardCountsEntry>, I>>(
    object: I,
  ): UpdateCardState_PlayerCardCountsEntry {
    const message = createBaseUpdateCardState_PlayerCardCountsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseWhotPlayerResult(): WhotPlayerResult {
  return { userId: "", totalPoints: 0, winFactor: 0, isWinner: false, remainingCards: [] };
}

export const WhotPlayerResult: MessageFns<WhotPlayerResult> = {
  encode(message: WhotPlayerResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.totalPoints !== 0) {
      writer.uint32(16).int64(message.totalPoints);
    }
    if (message.winFactor !== 0) {
      writer.uint32(25).double(message.winFactor);
    }
    if (message.isWinner !== false) {
      writer.uint32(32).bool(message.isWinner);
    }
    for (const v of message.remainingCards) {
      WhotCard.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WhotPlayerResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWhotPlayerResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalPoints = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.winFactor = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isWinner = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.remainingCards.push(WhotCard.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WhotPlayerResult {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      totalPoints: isSet(object.totalPoints) ? globalThis.Number(object.totalPoints) : 0,
      winFactor: isSet(object.winFactor) ? globalThis.Number(object.winFactor) : 0,
      isWinner: isSet(object.isWinner) ? globalThis.Boolean(object.isWinner) : false,
      remainingCards: globalThis.Array.isArray(object?.remainingCards)
        ? object.remainingCards.map((e: any) => WhotCard.fromJSON(e))
        : [],
    };
  },

  toJSON(message: WhotPlayerResult): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.totalPoints !== 0) {
      obj.totalPoints = Math.round(message.totalPoints);
    }
    if (message.winFactor !== 0) {
      obj.winFactor = message.winFactor;
    }
    if (message.isWinner !== false) {
      obj.isWinner = message.isWinner;
    }
    if (message.remainingCards?.length) {
      obj.remainingCards = message.remainingCards.map((e) => WhotCard.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WhotPlayerResult>, I>>(base?: I): WhotPlayerResult {
    return WhotPlayerResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WhotPlayerResult>, I>>(object: I): WhotPlayerResult {
    const message = createBaseWhotPlayerResult();
    message.userId = object.userId ?? "";
    message.totalPoints = object.totalPoints ?? 0;
    message.winFactor = object.winFactor ?? 0;
    message.isWinner = object.isWinner ?? false;
    message.remainingCards = object.remainingCards?.map((e) => WhotCard.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
